
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005b74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e6  00802000  00005b74  00005c08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001e7e  008020e6  008020e6  00005cee  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00005cee  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000e00  00000000  00000000  00005d50  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00015b3e  00000000  00000000  00006b50  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00005458  00000000  00000000  0001c68e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000925f  00000000  00000000  00021ae6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00002c40  00000000  00000000  0002ad48  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000554f  00000000  00000000  0002d988  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000cf97  00000000  00000000  00032ed7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000be8  00000000  00000000  0003fe70  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	85 c3       	rjmp	.+1802   	; 0x70c <__ctors_end>
       2:	00 00       	nop
       4:	a9 c3       	rjmp	.+1874   	; 0x758 <__bad_interrupt>
       6:	00 00       	nop
       8:	a7 c3       	rjmp	.+1870   	; 0x758 <__bad_interrupt>
       a:	00 00       	nop
       c:	a5 c3       	rjmp	.+1866   	; 0x758 <__bad_interrupt>
       e:	00 00       	nop
      10:	a3 c3       	rjmp	.+1862   	; 0x758 <__bad_interrupt>
      12:	00 00       	nop
      14:	a1 c3       	rjmp	.+1858   	; 0x758 <__bad_interrupt>
      16:	00 00       	nop
      18:	9f c3       	rjmp	.+1854   	; 0x758 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9d c3       	rjmp	.+1850   	; 0x758 <__bad_interrupt>
      1e:	00 00       	nop
      20:	9b c3       	rjmp	.+1846   	; 0x758 <__bad_interrupt>
      22:	00 00       	nop
      24:	99 c3       	rjmp	.+1842   	; 0x758 <__bad_interrupt>
      26:	00 00       	nop
      28:	97 c3       	rjmp	.+1838   	; 0x758 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	95 c3       	rjmp	.+1834   	; 0x758 <__bad_interrupt>
      2e:	00 00       	nop
      30:	a2 c4       	rjmp	.+2372   	; 0x976 <__vector_12>
      32:	00 00       	nop
      34:	6b c4       	rjmp	.+2262   	; 0x90c <__vector_13>
      36:	00 00       	nop
      38:	00 c6       	rjmp	.+3072   	; 0xc3a <__vector_14>
      3a:	00 00       	nop
      3c:	8d c3       	rjmp	.+1818   	; 0x758 <__bad_interrupt>
      3e:	00 00       	nop
      40:	8b c3       	rjmp	.+1814   	; 0x758 <__bad_interrupt>
      42:	00 00       	nop
      44:	89 c3       	rjmp	.+1810   	; 0x758 <__bad_interrupt>
      46:	00 00       	nop
      48:	87 c3       	rjmp	.+1806   	; 0x758 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	85 c3       	rjmp	.+1802   	; 0x758 <__bad_interrupt>
      4e:	00 00       	nop
      50:	0c 94 80 26 	jmp	0x4d00	; 0x4d00 <__vector_20>
      54:	81 c3       	rjmp	.+1794   	; 0x758 <__bad_interrupt>
      56:	00 00       	nop
      58:	7f c3       	rjmp	.+1790   	; 0x758 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7d c3       	rjmp	.+1786   	; 0x758 <__bad_interrupt>
      5e:	00 00       	nop
      60:	7b c3       	rjmp	.+1782   	; 0x758 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 03 23 	jmp	0x4606	; 0x4606 <__vector_25>
      68:	0c 94 0b 24 	jmp	0x4816	; 0x4816 <__vector_26>
      6c:	75 c3       	rjmp	.+1770   	; 0x758 <__bad_interrupt>
      6e:	00 00       	nop
      70:	73 c3       	rjmp	.+1766   	; 0x758 <__bad_interrupt>
      72:	00 00       	nop
      74:	71 c3       	rjmp	.+1762   	; 0x758 <__bad_interrupt>
      76:	00 00       	nop
      78:	6f c3       	rjmp	.+1758   	; 0x758 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6d c3       	rjmp	.+1754   	; 0x758 <__bad_interrupt>
      7e:	00 00       	nop
      80:	6b c3       	rjmp	.+1750   	; 0x758 <__bad_interrupt>
      82:	00 00       	nop
      84:	69 c3       	rjmp	.+1746   	; 0x758 <__bad_interrupt>
      86:	00 00       	nop
      88:	67 c3       	rjmp	.+1742   	; 0x758 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	65 c3       	rjmp	.+1738   	; 0x758 <__bad_interrupt>
      8e:	00 00       	nop
      90:	63 c3       	rjmp	.+1734   	; 0x758 <__bad_interrupt>
      92:	00 00       	nop
      94:	61 c3       	rjmp	.+1730   	; 0x758 <__bad_interrupt>
      96:	00 00       	nop
      98:	5f c3       	rjmp	.+1726   	; 0x758 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5d c3       	rjmp	.+1722   	; 0x758 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5b c3       	rjmp	.+1718   	; 0x758 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	59 c3       	rjmp	.+1714   	; 0x758 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	57 c3       	rjmp	.+1710   	; 0x758 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	55 c3       	rjmp	.+1706   	; 0x758 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	53 c3       	rjmp	.+1702   	; 0x758 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	51 c3       	rjmp	.+1698   	; 0x758 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	4f c3       	rjmp	.+1694   	; 0x758 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4d c3       	rjmp	.+1690   	; 0x758 <__bad_interrupt>
      be:	00 00       	nop
      c0:	4b c3       	rjmp	.+1686   	; 0x758 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	49 c3       	rjmp	.+1682   	; 0x758 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	47 c3       	rjmp	.+1678   	; 0x758 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	45 c3       	rjmp	.+1674   	; 0x758 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	43 c3       	rjmp	.+1670   	; 0x758 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	41 c3       	rjmp	.+1666   	; 0x758 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	3f c3       	rjmp	.+1662   	; 0x758 <__bad_interrupt>
      da:	00 00       	nop
      dc:	3d c3       	rjmp	.+1658   	; 0x758 <__bad_interrupt>
      de:	00 00       	nop
      e0:	3b c3       	rjmp	.+1654   	; 0x758 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	39 c3       	rjmp	.+1650   	; 0x758 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	0c 94 b3 23 	jmp	0x4766	; 0x4766 <__vector_58>
      ec:	0c 94 d1 24 	jmp	0x49a2	; 0x49a2 <__vector_59>
      f0:	33 c3       	rjmp	.+1638   	; 0x758 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	31 c3       	rjmp	.+1634   	; 0x758 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	2f c3       	rjmp	.+1630   	; 0x758 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	2d c3       	rjmp	.+1626   	; 0x758 <__bad_interrupt>
      fe:	00 00       	nop
     100:	2b c3       	rjmp	.+1622   	; 0x758 <__bad_interrupt>
     102:	00 00       	nop
     104:	29 c3       	rjmp	.+1618   	; 0x758 <__bad_interrupt>
     106:	00 00       	nop
     108:	27 c3       	rjmp	.+1614   	; 0x758 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	25 c3       	rjmp	.+1610   	; 0x758 <__bad_interrupt>
     10e:	00 00       	nop
     110:	23 c3       	rjmp	.+1606   	; 0x758 <__bad_interrupt>
     112:	00 00       	nop
     114:	21 c3       	rjmp	.+1602   	; 0x758 <__bad_interrupt>
     116:	00 00       	nop
     118:	1f c3       	rjmp	.+1598   	; 0x758 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	1d c3       	rjmp	.+1594   	; 0x758 <__bad_interrupt>
     11e:	00 00       	nop
     120:	1b c3       	rjmp	.+1590   	; 0x758 <__bad_interrupt>
     122:	00 00       	nop
     124:	19 c3       	rjmp	.+1586   	; 0x758 <__bad_interrupt>
     126:	00 00       	nop
     128:	17 c3       	rjmp	.+1582   	; 0x758 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	15 c3       	rjmp	.+1578   	; 0x758 <__bad_interrupt>
     12e:	00 00       	nop
     130:	13 c3       	rjmp	.+1574   	; 0x758 <__bad_interrupt>
     132:	00 00       	nop
     134:	11 c3       	rjmp	.+1570   	; 0x758 <__bad_interrupt>
     136:	00 00       	nop
     138:	0f c3       	rjmp	.+1566   	; 0x758 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	0d c3       	rjmp	.+1562   	; 0x758 <__bad_interrupt>
     13e:	00 00       	nop
     140:	0b c3       	rjmp	.+1558   	; 0x758 <__bad_interrupt>
     142:	00 00       	nop
     144:	09 c3       	rjmp	.+1554   	; 0x758 <__bad_interrupt>
     146:	00 00       	nop
     148:	07 c3       	rjmp	.+1550   	; 0x758 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	05 c3       	rjmp	.+1546   	; 0x758 <__bad_interrupt>
     14e:	00 00       	nop
     150:	03 c3       	rjmp	.+1542   	; 0x758 <__bad_interrupt>
     152:	00 00       	nop
     154:	01 c3       	rjmp	.+1538   	; 0x758 <__bad_interrupt>
     156:	00 00       	nop
     158:	ff c2       	rjmp	.+1534   	; 0x758 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	fd c2       	rjmp	.+1530   	; 0x758 <__bad_interrupt>
     15e:	00 00       	nop
     160:	0c 94 5b 23 	jmp	0x46b6	; 0x46b6 <__vector_88>
     164:	0c 94 6e 24 	jmp	0x48dc	; 0x48dc <__vector_89>
     168:	f7 c2       	rjmp	.+1518   	; 0x758 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	f5 c2       	rjmp	.+1514   	; 0x758 <__bad_interrupt>
     16e:	00 00       	nop
     170:	f3 c2       	rjmp	.+1510   	; 0x758 <__bad_interrupt>
     172:	00 00       	nop
     174:	f1 c2       	rjmp	.+1506   	; 0x758 <__bad_interrupt>
     176:	00 00       	nop
     178:	ef c2       	rjmp	.+1502   	; 0x758 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	ed c2       	rjmp	.+1498   	; 0x758 <__bad_interrupt>
     17e:	00 00       	nop
     180:	eb c2       	rjmp	.+1494   	; 0x758 <__bad_interrupt>
     182:	00 00       	nop
     184:	e9 c2       	rjmp	.+1490   	; 0x758 <__bad_interrupt>
     186:	00 00       	nop
     188:	e7 c2       	rjmp	.+1486   	; 0x758 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	e5 c2       	rjmp	.+1482   	; 0x758 <__bad_interrupt>
     18e:	00 00       	nop
     190:	e3 c2       	rjmp	.+1478   	; 0x758 <__bad_interrupt>
     192:	00 00       	nop
     194:	e1 c2       	rjmp	.+1474   	; 0x758 <__bad_interrupt>
     196:	00 00       	nop
     198:	df c2       	rjmp	.+1470   	; 0x758 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	dd c2       	rjmp	.+1466   	; 0x758 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	db c2       	rjmp	.+1462   	; 0x758 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	d9 c2       	rjmp	.+1458   	; 0x758 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	d7 c2       	rjmp	.+1454   	; 0x758 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	d5 c2       	rjmp	.+1450   	; 0x758 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	d3 c2       	rjmp	.+1446   	; 0x758 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	d1 c2       	rjmp	.+1442   	; 0x758 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	cf c2       	rjmp	.+1438   	; 0x758 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	cd c2       	rjmp	.+1434   	; 0x758 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	cb c2       	rjmp	.+1430   	; 0x758 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	c9 c2       	rjmp	.+1426   	; 0x758 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	c7 c2       	rjmp	.+1422   	; 0x758 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	c5 c2       	rjmp	.+1418   	; 0x758 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	c3 c2       	rjmp	.+1414   	; 0x758 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	c1 c2       	rjmp	.+1410   	; 0x758 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	bf c2       	rjmp	.+1406   	; 0x758 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	bd c2       	rjmp	.+1402   	; 0x758 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	bb c2       	rjmp	.+1398   	; 0x758 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	b9 c2       	rjmp	.+1394   	; 0x758 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	b7 c2       	rjmp	.+1390   	; 0x758 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	b5 c2       	rjmp	.+1386   	; 0x758 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	b3 c2       	rjmp	.+1382   	; 0x758 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	b1 c2       	rjmp	.+1378   	; 0x758 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	af c2       	rjmp	.+1374   	; 0x758 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	84 1d       	adc	r24, r4
     1fe:	13 1e       	adc	r1, r19
     200:	8e 1d       	adc	r24, r14
     202:	d2 1d       	adc	r29, r2
     204:	de 1d       	adc	r29, r14
     206:	f2 1d       	adc	r31, r2
     208:	03 1e       	adc	r0, r19

0000020a <__trampolines_end>:
     20a:	00 00       	nop
     20c:	00 00       	nop
     20e:	03 83       	std	Z+3, r16	; 0x03
     210:	6b f2       	brvs	.-102    	; 0x1ac <__SREG__+0x16d>
     212:	f7 70       	andi	r31, 0x07	; 7
     214:	3b e1       	ldi	r19, 0x1B	; 27
     216:	f4 f3       	brlt	.-4      	; 0x214 <__trampolines_end+0xa>
     218:	50 13       	cpse	r21, r16
     21a:	1f 97       	sbiw	r26, 0x0f	; 15
     21c:	9a c7       	rjmp	.+3892   	; 0x1152 <xQueueCreateMutex+0x36>
     21e:	1c 14       	cp	r1, r12
     220:	f1 35       	cpi	r31, 0x51	; 81
     222:	e8 e7       	ldi	r30, 0x78	; 120
     224:	a1 26       	eor	r10, r17
     226:	eb 64       	ori	r30, 0x4B	; 75
     228:	ca d4       	rcall	.+2452   	; 0xbbe <vPortYield+0x34>
     22a:	cf 58       	subi	r28, 0x8F	; 143
     22c:	d9 8a       	std	Y+17, r13	; 0x11
     22e:	cc db       	rcall	.-2152   	; 0xfffff9c8 <__eeprom_end+0xff7ef9c8>
     230:	b2 78       	andi	r27, 0x82	; 130
     232:	38 28       	or	r3, r8
     234:	e2 6b       	ori	r30, 0xB2	; 178
     236:	3b ab       	std	Y+51, r19	; 0x33
     238:	89 99       	sbic	0x11, 1	; 17
     23a:	d0 cf       	rjmp	.-96     	; 0x1dc <__SREG__+0x19d>
     23c:	43 4d       	sbci	r20, 0xD3	; 211
     23e:	d3 4c       	sbci	r29, 0xC3	; 195
     240:	28 bf       	out	0x38, r18	; 56
     242:	27 bf       	out	0x37, r18	; 55
     244:	78 ac       	ldd	r7, Y+56	; 0x38
     246:	24 3c       	cpi	r18, 0xC4	; 196
     248:	13 5e       	subi	r17, 0xE3	; 227
     24a:	6f c7       	rjmp	.+3806   	; 0x112a <xQueueCreateMutex+0xe>
     24c:	5e 10       	cpse	r5, r14
     24e:	6c 44       	sbci	r22, 0x4C	; 76
     250:	35 e2       	ldi	r19, 0x25	; 37
     252:	98 b7       	in	r25, 0x38	; 56
     254:	65 f1       	brhs	.+88     	; 0x2ae <__trampolines_end+0xa4>
     256:	9b 34       	cpi	r25, 0x4B	; 75
     258:	0e 03       	fmul	r16, r22
     25a:	70 50       	subi	r23, 0x00	; 0
     25c:	c4 d7       	rcall	.+3976   	; 0x11e6 <xQueueGenericReceive+0x26>
     25e:	73 d3       	rcall	.+1766   	; 0x946 <__vector_13+0x3a>
     260:	af 25       	eor	r26, r15
     262:	87 20       	and	r8, r7
     264:	ff 36       	cpi	r31, 0x6F	; 111
     266:	84 a3       	std	Z+36, r24	; 0x24
     268:	94 c4       	rjmp	.+2344   	; 0xb92 <vPortYield+0x8>
     26a:	a0 9f       	mul	r26, r16
     26c:	87 9a       	sbi	0x10, 7	; 16
     26e:	a3 1c       	adc	r10, r3
     270:	ec 68       	ori	r30, 0x8C	; 140
     272:	57 ef       	ldi	r21, 0xF7	; 247
     274:	bc 7b       	andi	r27, 0xBC	; 188
     276:	54 6c       	ori	r21, 0xC4	; 196
     278:	d7 89       	ldd	r29, Z+23	; 0x17
     27a:	bf 08       	sbc	r11, r15
     27c:	1d 5d       	subi	r17, 0xDD	; 221
     27e:	bc 8b       	std	Y+20, r27	; 0x14
     280:	76 af       	std	Z+62, r23	; 0x3e
     282:	48 78       	andi	r20, 0x88	; 136
     284:	26 bc       	out	0x26, r2	; 38
     286:	4b fb       	.word	0xfb4b	; ????
     288:	4d 4e       	sbci	r20, 0xED	; 237
     28a:	de 8e       	std	Y+30, r13	; 0x1e
     28c:	bd 20       	and	r11, r13
     28e:	dd 0d       	add	r29, r13
     290:	d6 d2       	rcall	.+1452   	; 0x83e <TWI_CSP_SlaveProcessData+0x18>
     292:	29 fe       	.word	0xfe29	; ????
     294:	86 c1       	rjmp	.+780    	; 0x5a2 <__trampolines_end+0x398>
     296:	2a 7d       	andi	r18, 0xDA	; 218
     298:	ed 33       	cpi	r30, 0x3D	; 61
     29a:	c1 19       	sub	r28, r1
     29c:	27 e7       	ldi	r18, 0x77	; 119
     29e:	c2 9a       	sbi	0x18, 2	; 24
     2a0:	4c 15       	cp	r20, r12
     2a2:	36 69       	ori	r19, 0x96	; 150
     2a4:	1c 06       	cpc	r1, r28
     2a6:	35 ea       	ldi	r19, 0xA5	; 165
     2a8:	77 f4       	brid	.+28     	; 0x2c6 <__trampolines_end+0xbc>
     2aa:	11 d6       	rcall	.+3106   	; 0xece <prvCopyDataFromQueue+0x16>
     2ac:	64 aa       	std	Z+52, r6	; 0x34
     2ae:	12 55       	subi	r17, 0x52	; 82
     2b0:	0f 58       	subi	r16, 0x8F	; 143
     2b2:	e6 a6       	std	Z+46, r14	; 0x2e
     2b4:	5f 4b       	sbci	r21, 0xBF	; 191
     2b6:	e5 25       	eor	r30, r5
     2b8:	34 b9       	out	0x04, r19	; 4
     2ba:	0e 41       	sbci	r16, 0x1E	; 30
     2bc:	fe 6d       	ori	r31, 0xDE	; 222
     2be:	0d c2       	rjmp	.+1050   	; 0x6da <__c.2159+0xcc>
     2c0:	95 9f       	mul	r25, r21
     2c2:	f9 31       	cpi	r31, 0x19	; 25
     2c4:	c5 8c       	ldd	r12, Z+29	; 0x1d
     2c6:	fa b2       	in	r15, 0x1a	; 26
     2c8:	ae 7e       	andi	r26, 0xEE	; 238
     2ca:	b1 49       	sbci	r27, 0x91	; 145
     2cc:	e3 30       	cpi	r30, 0x03	; 3
     2ce:	b2 ca       	rjmp	.-2716   	; 0xfffff834 <__eeprom_end+0xff7ef834>
     2d0:	88 c2       	rjmp	.+1296   	; 0x7e2 <cspTask+0x88>
     2d2:	46 39       	cpi	r20, 0x96	; 150
     2d4:	d8 d1       	rcall	.+944    	; 0x686 <__c.2159+0x78>
     2d6:	45 ba       	out	0x15, r4	; 21
     2d8:	b3 23       	and	r27, r19
     2da:	ae de       	rcall	.-676    	; 0x38 <__RAMPD__>
     2dc:	79 f7       	brne	.-34     	; 0x2bc <__trampolines_end+0xb2>
     2de:	ad 5d       	subi	r26, 0xDD	; 221
     2e0:	12 05       	cpc	r17, r2
     2e2:	59 ae       	std	Y+57, r5	; 0x39
     2e4:	42 16       	cp	r4, r18
     2e6:	5a 2d       	mov	r21, r10
     2e8:	29 e4       	ldi	r18, 0x49	; 73
     2ea:	7e 11       	cpse	r23, r14
     2ec:	3a ba       	out	0x1a, r3	; 26
     2ee:	7d 92       	st	X+, r7
     2f0:	51 48       	sbci	r21, 0x81	; 129
     2f2:	89 61       	ori	r24, 0x19	; 25
     2f4:	01 5b       	subi	r16, 0xB1	; 177
     2f6:	8a e2       	ldi	r24, 0x2A	; 42
     2f8:	6a a9       	ldd	r22, Y+50	; 0x32
     2fa:	61 86       	std	Z+9, r6	; 0x09
     2fc:	a0 7d       	andi	r26, 0xD0	; 208
     2fe:	62 05       	cpc	r22, r2
     300:	cb 8f       	std	Y+27, r28	; 0x1b
     302:	96 f6       	brtc	.-92     	; 0x2a8 <__trampolines_end+0x9e>
     304:	9b 9c       	mul	r9, r11
     306:	95 75       	andi	r25, 0x55	; 85
     308:	f0 6e       	ori	r31, 0xE0	; 224
     30a:	bc 1d       	adc	r27, r12
     30c:	7b 41       	sbci	r23, 0x1B	; 27
     30e:	bf 9e       	mul	r11, r31
     310:	10 b3       	in	r17, 0x10	; 16
     312:	4b 6d       	ori	r20, 0xDB	; 219
     314:	40 a0       	ldd	r4, Z+32	; 0x20
     316:	48 ee       	ldi	r20, 0xE8	; 232
     318:	2b 52       	subi	r18, 0x2B	; 43
     31a:	a3 8a       	std	Z+19, r10	; 0x13
     31c:	e1 86       	std	Z+9, r14	; 0x09
     31e:	a0 09       	sbc	r26, r0
     320:	8a 74       	andi	r24, 0x4A	; 74
     322:	54 fa       	bst	r5, 4
     324:	da 67       	ori	r29, 0x7A	; 122
     326:	57 79       	andi	r21, 0x97	; 151
     328:	b1 95       	neg	r27
     32a:	73 45       	sbci	r23, 0x53	; 83
     32c:	a2 cb       	rjmp	.-2236   	; 0xfffffa72 <__eeprom_end+0xff7efa72>
     32e:	70 c6       	rjmp	.+3296   	; 0x1010 <xQueueGenericSend+0x4>
     330:	c9 39       	cpi	r28, 0x99	; 153
     332:	84 35       	cpi	r24, 0x54	; 84
     334:	99 2a       	or	r9, r25
     336:	87 b6       	in	r8, 0x37	; 55
     338:	f2 d8       	rcall	.-3612   	; 0xfffff51e <__eeprom_end+0xff7ef51e>
     33a:	6c d2       	rcall	.+1240   	; 0x814 <cspTask+0xba>
     33c:	38 0c       	add	r3, r8
     33e:	6f 51       	subi	r22, 0x1F	; 31
     340:	53 fe       	sbrs	r5, 3
     342:	9b a2       	std	Y+35, r9	; 0x23
     344:	03 ed       	ldi	r16, 0xD3	; 211
     346:	98 21       	and	r25, r8
     348:	68 1f       	adc	r22, r24
     34a:	d3 da       	rcall	.-2650   	; 0xfffff8f2 <__eeprom_end+0xff7ef8f2>
     34c:	25 51       	subi	r18, 0x15	; 21
     34e:	d0 59       	subi	r29, 0x90	; 144
     350:	4e a3       	std	Y+38, r20	; 0x26
     352:	24 aa       	std	Z+52, r2	; 0x34
     354:	1e b0       	in	r1, 0x0e	; 14
     356:	27 29       	or	r18, r7
     358:	75 42       	sbci	r23, 0x25	; 37
     35a:	cc 4d       	sbci	r28, 0xDC	; 220
     35c:	bf 96       	adiw	r30, 0x2f	; 47
     35e:	cf ce       	rjmp	.-610    	; 0xfe <__SREG__+0xbf>
     360:	d4 64       	ori	r29, 0x44	; 68
     362:	3b 3d       	cpi	r19, 0xDB	; 219
     364:	84 77       	andi	r24, 0x74	; 116
     366:	38 be       	out	0x38, r3	; 56
     368:	ef 85       	ldd	r30, Y+15	; 0x0f
     36a:	1c 82       	std	Y+4, r1	; 0x04
     36c:	fc db       	rcall	.-2056   	; 0xfffffb66 <__eeprom_end+0xff7efb66>
     36e:	1f 01       	movw	r2, r30
     370:	97 29       	or	r25, r7
     372:	eb f2       	brvs	.-70     	; 0x32e <__trampolines_end+0x124>
     374:	c7 3a       	cpi	r28, 0xA7	; 167
     376:	e8 71       	andi	r30, 0x18	; 24
     378:	ac c8       	rjmp	.-3752   	; 0xfffff4d2 <__eeprom_end+0xff7ef4d2>
     37a:	03 15       	cp	r16, r3
     37c:	66 1c       	adc	r6, r6
     37e:	00 96       	adiw	r24, 0x00	; 0
     380:	0d ee       	ldi	r16, 0xED	; 237
     382:	f4 65       	ori	r31, 0x54	; 84
     384:	5d fd       	.word	0xfd5d	; ????
     386:	f7 e6       	ldi	r31, 0x67	; 103
     388:	36 0f       	add	r19, r22
     38a:	62 93       	st	-Z, r22
     38c:	c6 61       	ori	r28, 0x16	; 22
     38e:	61 10       	cpse	r6, r1
     390:	ad 93       	st	X+, r26	; undefined
     392:	95 e3       	ldi	r25, 0x35	; 53
     394:	fd 80       	ldd	r15, Y+5	; 0x05
     396:	96 60       	ori	r25, 0x06	; 6
     398:	96 72       	andi	r25, 0x26	; 38
     39a:	7d 04       	cpc	r7, r13
     39c:	5c a6       	std	Y+44, r5	; 0x2c
     39e:	7e 87       	std	Y+14, r23	; 0x0e
     3a0:	37 54       	subi	r19, 0x47	; 71
     3a2:	8a 74       	andi	r24, 0x4A	; 74
     3a4:	67 47       	sbci	r22, 0x77	; 119
     3a6:	89 f7       	brne	.-30     	; 0x38a <__trampolines_end+0x180>
     3a8:	0c b5       	in	r16, 0x2c	; 44
     3aa:	ad cb       	rjmp	.-2214   	; 0xfffffb06 <__eeprom_end+0xff7efb06>
     3ac:	1f eb       	ldi	r17, 0xBF	; 191
     3ae:	ae 48       	sbci	r26, 0x8E	; 142
     3b0:	74 19       	sub	r23, r4
     3b2:	5a bb       	out	0x1a, r21	; 26
     3b4:	24 0a       	sbc	r2, r20
     3b6:	59 38       	cpi	r21, 0x89	; 137
     3b8:	4f f8       	.word	0xf84f	; ????
     3ba:	b2 5c       	subi	r27, 0xC2	; 194
     3bc:	85 2c       	mov	r8, r5
     3be:	b1 df       	rcall	.-158    	; 0x322 <__trampolines_end+0x118>
     3c0:	ee de       	rcall	.-548    	; 0x19e <__SREG__+0x15f>
     3c2:	45 2c       	mov	r4, r5
     3c4:	be cd       	rjmp	.-1156   	; 0xffffff42 <__eeprom_end+0xff7eff42>
     3c6:	46 af       	std	Z+62, r20	; 0x3e
     3c8:	d5 3f       	cpi	r29, 0xF5	; 245
     3ca:	0d 54       	subi	r16, 0x4D	; 77
     3cc:	98 71       	andi	r25, 0x18	; 24
     3ce:	0e d7       	rcall	.+3612   	; 0x11ec <xQueueGenericReceive+0x2c>
     3d0:	f3 83       	std	Z+3, r31	; 0x03
     3d2:	fa 24       	eor	r15, r10
     3d4:	a3 90       	.word	0x90a3	; ????
     3d6:	f9 a7       	std	Y+41, r31	; 0x29
     3d8:	c8 62       	ori	r28, 0x28	; 40
     3da:	12 c3       	rjmp	.+1572   	; 0xa00 <pvPortMalloc+0x20>
     3dc:	02 b6       	in	r0, 0x32	; 50
     3de:	11 40       	sbci	r17, 0x01	; 1
     3e0:	69 44       	sbci	r22, 0x49	; 73
     3e2:	e5 b3       	in	r30, 0x15	; 21
     3e4:	39 57       	subi	r19, 0x79	; 121
     3e6:	e6 30       	cpi	r30, 0x06	; 6
     3e8:	52 a5       	ldd	r21, Z+42	; 0x2a
     3ea:	c2 0c       	add	r12, r2
     3ec:	41 fb       	bst	r20, 1
     3ee:	c1 8f       	std	Z+25, r28	; 0x19
     3f0:	2a 09       	sbc	r18, r10
     3f2:	35 7c       	andi	r19, 0xC5	; 197
     3f4:	7a 1a       	sub	r7, r26
     3f6:	36 ff       	sbrs	r19, 6
     3f8:	11 e8       	ldi	r17, 0x81	; 129
     3fa:	dd 9b       	sbis	0x1b, 5	; 27
     3fc:	db 3c       	cpi	r29, 0xCB	; 203
     3fe:	de 18       	sub	r13, r14
     400:	b0 ce       	rjmp	.-672    	; 0x162 <__SREG__+0x123>
     402:	2a eb       	ldi	r18, 0xBA	; 186
     404:	e0 dd       	rcall	.-1088   	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     406:	29 68       	ori	r18, 0x89	; 137
     408:	8b 2f       	mov	r24, r27
     40a:	78 3b       	cpi	r23, 0xB8	; 184
     40c:	f6 82       	std	Z+6, r15	; 0x06
     40e:	7b b8       	out	0x0b, r7	; 11
     410:	9d 70       	andi	r25, 0x0D	; 13
     412:	8f 4b       	sbci	r24, 0xBF	; 191
     414:	cd 63       	ori	r28, 0x3D	; 61
     416:	8c c8       	rjmp	.-3816   	; 0xfffff530 <__eeprom_end+0xff7ef530>
     418:	a6 91       	elpm	r26, Z
     41a:	67 ac       	ldd	r6, Z+63	; 0x3f
     41c:	6c 45       	sbci	r22, 0x5C	; 92
     41e:	64 2f       	mov	r22, r20
     420:	07 b7       	in	r16, 0x37	; 55
     422:	90 dc       	rcall	.-1760   	; 0xfffffd44 <__eeprom_end+0xff7efd44>
     424:	57 a4       	ldd	r5, Z+47	; 0x2f
     426:	93 5f       	subi	r25, 0xF3	; 243
     428:	3c 56       	subi	r19, 0x6C	; 108
     42a:	b7 63       	ori	r27, 0x37	; 55
     42c:	2f 08       	sbc	r2, r15
     42e:	b4 e0       	ldi	r27, 0x04	; 4
     430:	44 fa       	bst	r4, 4
     432:	40 13       	cpse	r20, r16
     434:	14 e9       	ldi	r17, 0x94	; 148
     436:	43 90       	.word	0x9043	; ????
     438:	7f 1b       	sub	r23, r31
     43a:	a8 f4       	brcc	.+42     	; 0x466 <__trampolines_end+0x25c>
     43c:	b5 cf       	rjmp	.-150    	; 0x3a8 <__trampolines_end+0x19e>
     43e:	ab 77       	andi	r26, 0x7B	; 123
     440:	de 3d       	cpi	r29, 0xDE	; 222
     442:	5f 84       	ldd	r5, Y+15	; 0x0f
     444:	8e 2e       	mov	r8, r30
     446:	5c 07       	cpc	r21, r28
     448:	e5 dc       	rcall	.-1590   	; 0xfffffe14 <__eeprom_end+0xff7efe14>
     44a:	17 fc       	sbrc	r1, 7
     44c:	a8 92       	.word	0x92a8	; ????
     44e:	14 7f       	andi	r17, 0xF4	; 244
     450:	c3 60       	ori	r28, 0x03	; 3
     452:	e0 8c       	ldd	r14, Z+24	; 0x18
     454:	93 73       	andi	r25, 0x33	; 51
     456:	e3 0f       	add	r30, r19
     458:	f8 81       	ld	r31, Y
     45a:	08 6b       	ori	r16, 0xB8	; 184
     45c:	32 55       	subi	r19, 0x52	; 82
     45e:	0b e8       	ldi	r16, 0x8B	; 139
     460:	59 a7       	std	Y+41, r21	; 0x29
     462:	ff 1b       	sub	r31, r31
     464:	09 b4       	in	r0, 0x29	; 41
     466:	fc 98       	cbi	0x1f, 4	; 31
     468:	62 46       	sbci	r22, 0x62	; 98
     46a:	d8 a4       	ldd	r13, Y+40	; 0x28
     46c:	71 18       	sub	r7, r1
     46e:	db 27       	eor	r29, r27
     470:	1a ea       	ldi	r17, 0xAA	; 170
     472:	2f d4       	rcall	.+2142   	; 0xcd2 <__vector_14+0x98>
     474:	4a f9       	.word	0xf94a	; ????
     476:	2c 57       	subi	r18, 0x7C	; 124
     478:	21 0b       	sbc	r18, r17
     47a:	c7 33       	cpi	r28, 0x37	; 55
     47c:	eb df       	rcall	.-42     	; 0x454 <__trampolines_end+0x24a>
     47e:	c4 b0       	in	r12, 0x04	; 4
     480:	80 2d       	mov	r24, r0
     482:	30 43       	sbci	r19, 0x30	; 48
     484:	d0 3e       	cpi	r29, 0xE0	; 224
     486:	33 c0       	rjmp	.+102    	; 0x4ee <__trampolines_end+0x2e4>
     488:	bb cc       	rjmp	.-1674   	; 0xfffffe00 <__eeprom_end+0xff7efe00>
     48a:	a6 b5       	in	r26, 0x26	; 38
     48c:	4b a2       	std	Y+35, r4	; 0x23
     48e:	a5 36       	cpi	r26, 0x65	; 101
     490:	20 50       	subi	r18, 0x00	; 0
     492:	51 c5       	rjmp	.+2722   	; 0xf36 <prvUnlockQueue+0x4a>
     494:	70 43       	sbci	r23, 0x30	; 48
     496:	52 46       	sbci	r21, 0x62	; 98
     498:	1b b1       	in	r17, 0x0b	; 11
     49a:	b9 22       	and	r11, r25
     49c:	d1 65       	ori	r29, 0x51	; 81
     49e:	ba a1       	ldd	r27, Y+34	; 0x22
     4a0:	ba 97       	sbiw	r30, 0x2a	; 42
     4a2:	4e 52       	subi	r20, 0x2E	; 46
     4a4:	ea 84       	ldd	r14, Y+10	; 0x0a
     4a6:	4d d1       	rcall	.+666    	; 0x742 <__do_clear_bss+0x2>
     4a8:	81 76       	andi	r24, 0x61	; 97
     4aa:	69 ed       	ldi	r22, 0xD9	; 217
     4ac:	92 28       	or	r9, r2
     4ae:	6a 6e       	ori	r22, 0xEA	; 234
     4b0:	f9 da       	rcall	.-2574   	; 0xfffffaa4 <__eeprom_end+0xff7efaa4>
     4b2:	9e 9d       	mul	r25, r14
     4b4:	a9 c9       	rjmp	.-3246   	; 0xfffff808 <__eeprom_end+0xff7ef808>
     4b6:	9d 1e       	adc	r9, r29
     4b8:	c2 3b       	cpi	r28, 0xB2	; 178
     4ba:	76 7a       	andi	r23, 0xA6	; 166
     4bc:	08 ef       	ldi	r16, 0xF8	; 248
     4be:	75 f9       	bld	r23, 5
     4c0:	63 1d       	adc	r22, r3
     4c2:	81 0a       	sbc	r8, r17
     4c4:	33 0e       	add	r3, r19
     4c6:	82 89       	ldd	r24, Z+18	; 0x12
     4c8:	58 fc       	.word	0xfc58	; ????
     4ca:	c9 72       	andi	r28, 0x29	; 41
     4cc:	15 b2       	in	r1, 0x15	; 21
     4ce:	ca f1       	brmi	.+114    	; 0x542 <__trampolines_end+0x338>
     4d0:	7e 40       	sbci	r23, 0x0E	; 14
     4d2:	3e 02       	muls	r19, r30
     4d4:	2e 53       	subi	r18, 0x3E	; 62
     4d6:	3d 81       	ldd	r19, Y+5	; 0x05
     4d8:	45 a1       	ldd	r20, Z+37	; 0x25
     4da:	d6 e5       	ldi	r29, 0x56	; 86
     4dc:	8f 75       	andi	r24, 0x5F	; 95
     4de:	d5 66       	ori	r29, 0x65	; 101
     4e0:	e4 87       	std	Z+12, r30	; 0x0c
     4e2:	21 95       	neg	r18
     4e4:	b4 94       	.word	0x94b4	; ????
     4e6:	22 16       	cp	r2, r18
     4e8:	df 66       	ori	r29, 0x6F	; 111
     4ea:	06 2a       	or	r0, r22
     4ec:	cc 38       	cpi	r28, 0x8C	; 140
     4ee:	05 a9       	ldd	r16, Z+53	; 0x35
     4f0:	a7 ca       	rjmp	.-2738   	; 0xfffffa40 <__eeprom_end+0xff7efa40>
     4f2:	f1 5a       	subi	r31, 0xA1	; 161
     4f4:	f7 d9       	rcall	.-3090   	; 0xfffff8e4 <__eeprom_end+0xff7ef8e4>
     4f6:	f2 d9       	rcall	.-3100   	; 0xfffff8dc <__eeprom_end+0xff7ef8dc>
     4f8:	9c 2b       	or	r25, r28
     4fa:	19 bd       	out	0x29, r17	; 41
     4fc:	56 ff       	sbrs	r21, 6
     4fe:	1a 3e       	cpi	r17, 0xEA	; 234
     500:	3d 0d       	add	r19, r13
     502:	ee cd       	rjmp	.-1060   	; 0xe0 <__SREG__+0xa1>
     504:	6d 1e       	adc	r6, r29
     506:	ed 4e       	sbci	r30, 0xED	; 237
     508:	06 ec       	ldi	r16, 0xC6	; 198
     50a:	c4 26       	eor	r12, r20
     50c:	8d c3       	rjmp	.+1818   	; 0xc28 <vPortYield+0x9e>
     50e:	c7 a5       	ldd	r28, Z+47	; 0x2f
     510:	e6 31       	cpi	r30, 0x16	; 22
     512:	33 56       	subi	r19, 0x63	; 99
     514:	b6 22       	and	r11, r22
     516:	30 d5       	rcall	.+2656   	; 0xf78 <xQueueCreate+0x4>
     518:	dd d0       	rcall	.+442    	; 0x6d4 <__c.2159+0xc6>
     51a:	db b1       	in	r29, 0x0b	; 11
     51c:	17 04       	cpc	r1, r7
     51e:	d8 32       	cpi	r29, 0x28	; 40
     520:	7c f6       	brge	.-98     	; 0x4c0 <__trampolines_end+0x2b6>
     522:	2c c1       	rjmp	.+600    	; 0x77c <cspTask+0x22>
     524:	2c e5       	ldi	r18, 0x5C	; 92
     526:	2f 42       	sbci	r18, 0x2F	; 47
     528:	47 17       	cp	r20, r23
     52a:	0b 7e       	andi	r16, 0xEB	; 235
     52c:	54 49       	sbci	r21, 0x94	; 148
     52e:	08 fd       	.word	0xfd08	; ????
     530:	3f bb       	out	0x1f, r19	; 31
     532:	fc 0e       	add	r15, r28
     534:	6f a8       	ldd	r6, Y+55	; 0x37
     536:	ff 8d       	ldd	r31, Y+31	; 0x1f
     538:	04 5a       	subi	r16, 0xA4	; 164
     53a:	14 e9       	ldi	r17, 0x94	; 148
     53c:	ce 8e       	std	Y+30, r12	; 0x1e
     53e:	17 6a       	ori	r17, 0xA7	; 167
     540:	a5 7c       	andi	r26, 0xC5	; 197
     542:	e3 99       	sbic	0x1c, 3	; 28
     544:	f5 6f       	ori	r31, 0xF5	; 245
     546:	e0 1a       	sub	r14, r16
     548:	9e 9d       	mul	r25, r14
     54a:	ab e1       	ldi	r26, 0x1B	; 27
     54c:	d3 d3       	rcall	.+1958   	; 0xcf4 <vListInitialise+0x8>
     54e:	a8 62       	ori	r26, 0x28	; 40
     550:	b8 21       	and	r27, r8
     552:	5c 91       	ld	r21, X
     554:	e8 32       	cpi	r30, 0x28	; 40
     556:	5f 12       	cpse	r5, r31
     558:	83 c0       	rjmp	.+262    	; 0x660 <__c.2159+0x52>
     55a:	b4 76       	andi	r27, 0x64	; 100
     55c:	49 14       	cp	r4, r9
     55e:	b7 f5       	brid	.+108    	; 0x5cc <__trampolines_end+0x3c2>
     560:	22 e6       	ldi	r18, 0x62	; 98
     562:	43 06       	cpc	r4, r19
     564:	72 f5       	brpl	.+92     	; 0x5c2 <__trampolines_end+0x3b8>
     566:	40 85       	ldd	r20, Z+8	; 0x08
     568:	19 07       	cpc	r17, r25
     56a:	64 b9       	out	0x04, r22	; 4
     56c:	0a 59       	subi	r16, 0x9A	; 154
     56e:	67 3a       	cpi	r22, 0xA7	; 167
     570:	61 ab       	std	Z+49, r22	; 0x31
     572:	93 c9       	rjmp	.-3290   	; 0xfffff89a <__eeprom_end+0xff7ef89a>
     574:	31 b8       	out	0x01, r3	; 1
     576:	90 4a       	sbci	r25, 0xA0	; 160
     578:	5a 4a       	sbci	r21, 0xAA	; 170
     57a:	7b 2e       	mov	r7, r27
     57c:	90 9e       	mul	r9, r16
     57e:	78 ad       	ldd	r23, Y+56	; 0x38
     580:	fb 6c       	ori	r31, 0xCB	; 203
     582:	8c 5e       	subi	r24, 0xEC	; 236
     584:	ab 7f       	andi	r26, 0xFB	; 251
     586:	8f dd       	rcall	.-1250   	; 0xa6 <__SREG__+0x67>
     588:	c0 8d       	ldd	r28, Z+24	; 0x18
     58a:	1a a8       	ldd	r1, Y+50	; 0x32
     58c:	30 e3       	ldi	r19, 0x30	; 48
     58e:	19 2b       	or	r17, r25
     590:	5b 11       	cpse	r21, r11
     592:	ed d8       	rcall	.-3622   	; 0xfffff76e <__eeprom_end+0xff7ef76e>
     594:	0b 02       	muls	r16, r27
     596:	ee 5b       	subi	r30, 0xBE	; 190
     598:	60 f0       	brcs	.+24     	; 0x5b2 <__trampolines_end+0x3a8>
     59a:	05 3f       	cpi	r16, 0xF5	; 245
     59c:	aa 24       	eor	r10, r10
     59e:	06 bc       	out	0x26, r0	; 38
     5a0:	c1 d6       	rcall	.+3458   	; 0x1324 <xQueueReceiveFromISR+0x8>
     5a2:	f2 4f       	sbci	r31, 0xF2	; 242
     5a4:	91 c5       	rjmp	.+2850   	; 0x10c8 <xQueueGenericSend+0xbc>
     5a6:	f1 cc       	rjmp	.-1566   	; 0xffffff8a <__eeprom_end+0xff7eff8a>
     5a8:	fa 37       	cpi	r31, 0x7A	; 122
     5aa:	d5 f0       	brhs	.+52     	; 0x5e0 <__trampolines_end+0x3d6>
     5ac:	e9 69       	ori	r30, 0x99	; 153
     5ae:	d6 73       	andi	r29, 0x36	; 54
     5b0:	82 9b       	sbis	0x10, 2	; 16
     5b2:	22 80       	ldd	r2, Z+2	; 0x02
     5b4:	d2 88       	ldd	r13, Z+18	; 0x12
     5b6:	21 03       	mulsu	r18, r17
     5b8:	b9 7a       	andi	r27, 0xA9	; 169
     5ba:	ca 67       	ori	r28, 0x7A	; 122
     5bc:	73 ae       	std	Z+59, r7	; 0x3b
     5be:	c9 e4       	ldi	r28, 0x49	; 73
     5c0:	18 5c       	subi	r17, 0xC8	; 200
     5c2:	3d 17       	cp	r19, r29
     5c4:	48 4f       	sbci	r20, 0xF8	; 248
     5c6:	3e 94 23 bd 	call	0xd7a46	; 0xd7a46 <__data_load_end+0xd1dec>
     5ca:	75 6f       	ori	r23, 0xF5	; 245
     5cc:	6e f3       	brts	.-38     	; 0x5a8 <__trampolines_end+0x39e>
     5ce:	76 ec       	ldi	r23, 0xC6	; 198
     5d0:	05 01       	movw	r0, r10
     5d2:	82 1f       	adc	r24, r18
     5d4:	55 12       	cpse	r5, r21
     5d6:	81 9c       	mul	r8, r1
     5d8:	3e e0       	ldi	r19, 0x0E	; 14
     5da:	6a f8       	.word	0xf86a	; ????
     5dc:	f4 34       	cpi	r31, 0x44	; 68
     5de:	69 7b       	andi	r22, 0xB9	; 185
     5e0:	9f c6       	rjmp	.+3390   	; 0x1320 <xQueueReceiveFromISR+0x4>
     5e2:	9d 88       	ldd	r9, Y+21	; 0x15
     5e4:	cf d5       	rcall	.+2974   	; 0x1184 <xQueueGenericSendFromISR+0x18>
     5e6:	9e 0b       	sbc	r25, r30
     5e8:	a4 27       	eor	r26, r20
     5ea:	ba 37       	cpi	r27, 0x7A	; 122
     5ec:	b7 79       	andi	r27, 0x97	; 151
     5ee:	b9 b4       	in	r11, 0x29	; 41
     5f0:	dc 8b       	std	Y+20, r29	; 0x14
     5f2:	4d 47       	sbci	r20, 0x7D	; 125
     5f4:	8c 98       	cbi	0x11, 4	; 17
     5f6:	4e c4       	rjmp	.+2204   	; 0xe94 <prvCopyDataToQueue+0x74>
     5f8:	e7 6a       	ori	r30, 0xA7	; 167
     5fa:	a5 a0       	ldd	r10, Z+37	; 0x25
     5fc:	2d be       	out	0x3d, r2	; 61
     5fe:	a6 23       	and	r26, r22
     600:	46 4c       	sbci	r20, 0xC6	; 198
     602:	52 d0       	rcall	.+164    	; 0x6a8 <__c.2159+0x9a>
     604:	16 5f       	subi	r17, 0xF6	; 246
     606:	51 53       	subi	r21, 0x31	; 49
     608:	7d ad       	ldd	r23, Y+61	; 0x3d

0000060a <__c.2161>:
     60a:	6e 61 6e 00                                         nan.

0000060e <__c.2159>:
     60e:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     61e:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     62e:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     63e:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     64e:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     65e:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     66e:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     67e:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     68e:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     69e:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     6ae:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     6be:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     6ce:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     6de:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     6ee:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     6fe:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000070c <__ctors_end>:
     70c:	11 24       	eor	r1, r1
     70e:	1f be       	out	0x3f, r1	; 63
     710:	cf ef       	ldi	r28, 0xFF	; 255
     712:	cd bf       	out	0x3d, r28	; 61
     714:	df e3       	ldi	r29, 0x3F	; 63
     716:	de bf       	out	0x3e, r29	; 62
     718:	00 e0       	ldi	r16, 0x00	; 0
     71a:	0c bf       	out	0x3c, r16	; 60
     71c:	18 be       	out	0x38, r1	; 56
     71e:	19 be       	out	0x39, r1	; 57
     720:	1a be       	out	0x3a, r1	; 58
     722:	1b be       	out	0x3b, r1	; 59

00000724 <__do_copy_data>:
     724:	10 e2       	ldi	r17, 0x20	; 32
     726:	a0 e0       	ldi	r26, 0x00	; 0
     728:	b0 e2       	ldi	r27, 0x20	; 32
     72a:	e4 e7       	ldi	r30, 0x74	; 116
     72c:	fb e5       	ldi	r31, 0x5B	; 91
     72e:	00 e0       	ldi	r16, 0x00	; 0
     730:	0b bf       	out	0x3b, r16	; 59
     732:	02 c0       	rjmp	.+4      	; 0x738 <__do_copy_data+0x14>
     734:	07 90       	elpm	r0, Z+
     736:	0d 92       	st	X+, r0
     738:	a6 3e       	cpi	r26, 0xE6	; 230
     73a:	b1 07       	cpc	r27, r17
     73c:	d9 f7       	brne	.-10     	; 0x734 <__do_copy_data+0x10>
     73e:	1b be       	out	0x3b, r1	; 59

00000740 <__do_clear_bss>:
     740:	2f e3       	ldi	r18, 0x3F	; 63
     742:	a6 ee       	ldi	r26, 0xE6	; 230
     744:	b0 e2       	ldi	r27, 0x20	; 32
     746:	01 c0       	rjmp	.+2      	; 0x74a <.do_clear_bss_start>

00000748 <.do_clear_bss_loop>:
     748:	1d 92       	st	X+, r1

0000074a <.do_clear_bss_start>:
     74a:	a4 36       	cpi	r26, 0x64	; 100
     74c:	b2 07       	cpc	r27, r18
     74e:	e1 f7       	brne	.-8      	; 0x748 <.do_clear_bss_loop>
     750:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <main>
     754:	0c 94 b8 2d 	jmp	0x5b70	; 0x5b70 <_exit>

00000758 <__bad_interrupt>:
     758:	53 cc       	rjmp	.-1882   	; 0x0 <__vectors>

0000075a <cspTask>:
/*	Task that handles CSP incoming packets								*/
/* -------------------------------------------------------------------- */
void cspTask(void *p) {
	
	/* Create socket without any socket options */
	csp_socket_t * sock = csp_socket(CSP_SO_NONE);
     75a:	60 e0       	ldi	r22, 0x00	; 0
     75c:	70 e0       	ldi	r23, 0x00	; 0
     75e:	cb 01       	movw	r24, r22
     760:	0e 94 da 16 	call	0x2db4	; 0x2db4 <csp_socket>
     764:	7c 01       	movw	r14, r24

	/* Bind all ports to socket */
	csp_bind(sock, CSP_ANY);
     766:	60 e2       	ldi	r22, 0x20	; 32
     768:	0e 94 fe 18 	call	0x31fc	; 0x31fc <csp_bind>

	/* Create 10 connections backlog queue */
	csp_listen(sock, 10);
     76c:	6a e0       	ldi	r22, 0x0A	; 10
     76e:	70 e0       	ldi	r23, 0x00	; 0
     770:	c7 01       	movw	r24, r14
     772:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <csp_listen>

	/* Pointer to current connection and packet */
	csp_conn_t * conn;
	csp_packet_t * packet;
	
	xCSPEventQueue = xQueueCreate(10, (portBASE_TYPE) sizeof(xCSPStackEvent_t));
     776:	63 e0       	ldi	r22, 0x03	; 3
     778:	8a e0       	ldi	r24, 0x0A	; 10
     77a:	fc d3       	rcall	.+2040   	; 0xf74 <xQueueCreate>
     77c:	80 93 9f 3e 	sts	0x3E9F, r24
     780:	90 93 a0 3e 	sts	0x3EA0, r25

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
     784:	0f 2e       	mov	r0, r31
     786:	f0 e6       	ldi	r31, 0x60	; 96
     788:	cf 2e       	mov	r12, r31
     78a:	f6 e0       	ldi	r31, 0x06	; 6
     78c:	df 2e       	mov	r13, r31
     78e:	f0 2d       	mov	r31, r0
     790:	bb 24       	eor	r11, r11
     792:	b3 94       	inc	r11
				break;
				
				// response to ping
				case 32:

					newEvent->eEventType = pingReceivedEvent;
     794:	68 94       	set
     796:	aa 24       	eor	r10, r10
     798:	a1 f8       	bld	r10, 1

	/* Process incoming connections */
	while (1) {
		
		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
     79a:	40 e1       	ldi	r20, 0x10	; 16
     79c:	57 e2       	ldi	r21, 0x27	; 39
     79e:	60 e0       	ldi	r22, 0x00	; 0
     7a0:	70 e0       	ldi	r23, 0x00	; 0
     7a2:	c7 01       	movw	r24, r14
     7a4:	0e 94 20 17 	call	0x2e40	; 0x2e40 <csp_accept>
     7a8:	8c 01       	movw	r16, r24
     7aa:	00 97       	sbiw	r24, 0x00	; 0
     7ac:	b1 f3       	breq	.-20     	; 0x79a <cspTask+0x40>
     7ae:	f6 01       	movw	r30, r12
     7b0:	b7 82       	std	Z+7, r11	; 0x07
     7b2:	2b c0       	rjmp	.+86     	; 0x80a <cspTask+0xb0>
		led_red_toggle();

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 10)) != NULL) {

			switch (csp_conn_dport(conn)) {
     7b4:	c8 01       	movw	r24, r16
     7b6:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <csp_conn_dport>
     7ba:	8f 30       	cpi	r24, 0x0F	; 15
     7bc:	91 05       	cpc	r25, r1
     7be:	19 f0       	breq	.+6      	; 0x7c6 <cspTask+0x6c>
     7c0:	80 97       	sbiw	r24, 0x20	; 32
     7c2:	81 f0       	breq	.+32     	; 0x7e4 <cspTask+0x8a>
     7c4:	1e c0       	rjmp	.+60     	; 0x802 <cspTask+0xa8>
				
				// response to all except ping
				case 15:
				
					newEvent->eEventType = generalCommEvent;
     7c6:	60 e0       	ldi	r22, 0x00	; 0
     7c8:	70 e0       	ldi	r23, 0x00	; 0
     7ca:	fb 01       	movw	r30, r22
     7cc:	b0 82       	st	Z, r11
					newEvent->pvData = packet;
     7ce:	c1 83       	std	Z+1, r28	; 0x01
     7d0:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	4a e0       	ldi	r20, 0x0A	; 10
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	80 91 9f 3e 	lds	r24, 0x3E9F
     7dc:	90 91 a0 3e 	lds	r25, 0x3EA0
     7e0:	15 d4       	rcall	.+2090   	; 0x100c <xQueueGenericSend>
					
				break;
     7e2:	13 c0       	rjmp	.+38     	; 0x80a <cspTask+0xb0>
				
				// response to ping
				case 32:

					newEvent->eEventType = pingReceivedEvent;
     7e4:	60 e0       	ldi	r22, 0x00	; 0
     7e6:	70 e0       	ldi	r23, 0x00	; 0
     7e8:	fb 01       	movw	r30, r22
     7ea:	a0 82       	st	Z, r10
					newEvent->pvData = packet;
     7ec:	c1 83       	std	Z+1, r28	; 0x01
     7ee:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
     7f0:	20 e0       	ldi	r18, 0x00	; 0
     7f2:	4a e0       	ldi	r20, 0x0A	; 10
     7f4:	50 e0       	ldi	r21, 0x00	; 0
     7f6:	80 91 9f 3e 	lds	r24, 0x3E9F
     7fa:	90 91 a0 3e 	lds	r25, 0x3EA0
     7fe:	06 d4       	rcall	.+2060   	; 0x100c <xQueueGenericSend>
				
				break;
     800:	04 c0       	rjmp	.+8      	; 0x80a <cspTask+0xb0>
				
				/* Process packet here */
				default:
				
				/* Let the service handler reply pings, buffer use, etc. */
				csp_service_handler(conn, packet);
     802:	be 01       	movw	r22, r28
     804:	c8 01       	movw	r24, r16
     806:	0e 94 6e 1d 	call	0x3adc	; 0x3adc <csp_service_handler>
		continue;
		
		led_red_toggle();

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 10)) != NULL) {
     80a:	4a e0       	ldi	r20, 0x0A	; 10
     80c:	50 e0       	ldi	r21, 0x00	; 0
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	70 e0       	ldi	r23, 0x00	; 0
     812:	c8 01       	movw	r24, r16
     814:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <csp_read>
     818:	ec 01       	movw	r28, r24
     81a:	00 97       	sbiw	r24, 0x00	; 0
     81c:	59 f6       	brne	.-106    	; 0x7b4 <cspTask+0x5a>
				break;
			}
		}

		/* Close current connection, and handle next */
		csp_close(conn);
     81e:	c8 01       	movw	r24, r16
     820:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <csp_close>
     824:	ba cf       	rjmp	.-140    	; 0x79a <cspTask+0x40>

00000826 <TWI_CSP_SlaveProcessData>:
TWI_Slave_t twi_csp_slave;			/*!< TWI slave module. */
i2c_callback_t callbackFunction;

// this function processes received data on the I2C Slave line
// It is call by the I2C driver
void TWI_CSP_SlaveProcessData(void) {
     826:	cf 93       	push	r28
     828:	df 93       	push	r29
     82a:	cd b7       	in	r28, 0x3d	; 61
     82c:	de b7       	in	r29, 0x3e	; 62
     82e:	ca 50       	subi	r28, 0x0A	; 10
     830:	d1 40       	sbci	r29, 0x01	; 1
     832:	cd bf       	out	0x3d, r28	; 61
     834:	de bf       	out	0x3e, r29	; 62
	
	if (twi_csp_slave.result == TWIS_RESULT_OK) {
     836:	80 91 f1 3e 	lds	r24, 0x3EF1
     83a:	81 30       	cpi	r24, 0x01	; 1
     83c:	49 f5       	brne	.+82     	; 0x890 <TWI_CSP_SlaveProcessData+0x6a>
		
		i2c_frame_t newFrame;
		
		if (twi_csp_slave.bytesReceived > 0) {
     83e:	80 91 ee 3e 	lds	r24, 0x3EEE
     842:	88 23       	and	r24, r24
     844:	e1 f0       	breq	.+56     	; 0x87e <TWI_CSP_SlaveProcessData+0x58>
			
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
     846:	ee ee       	ldi	r30, 0xEE	; 238
     848:	fe e3       	ldi	r31, 0x3E	; 62
     84a:	80 81       	ld	r24, Z
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	89 87       	std	Y+9, r24	; 0x09
     850:	9a 87       	std	Y+10, r25	; 0x0a
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
     852:	80 81       	ld	r24, Z
     854:	88 23       	and	r24, r24
     856:	99 f0       	breq	.+38     	; 0x87e <TWI_CSP_SlaveProcessData+0x58>
     858:	fe 01       	movw	r30, r28
     85a:	3b 96       	adiw	r30, 0x0b	; 11
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	4e ee       	ldi	r20, 0xEE	; 238
     862:	5e e3       	ldi	r21, 0x3E	; 62
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
     864:	dc 01       	movw	r26, r24
     866:	af 55       	subi	r26, 0x5F	; 95
     868:	b1 4c       	sbci	r27, 0xC1	; 193
     86a:	14 96       	adiw	r26, 0x04	; 4
     86c:	2c 91       	ld	r18, X
     86e:	21 93       	st	Z+, r18
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
     870:	01 96       	adiw	r24, 0x01	; 1
     872:	da 01       	movw	r26, r20
     874:	2c 91       	ld	r18, X
     876:	30 e0       	ldi	r19, 0x00	; 0
     878:	82 17       	cp	r24, r18
     87a:	93 07       	cpc	r25, r19
     87c:	9c f3       	brlt	.-26     	; 0x864 <TWI_CSP_SlaveProcessData+0x3e>
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
			}
		}
		
		callbackFunction(&newFrame, false);
     87e:	e0 91 45 3f 	lds	r30, 0x3F45
     882:	f0 91 46 3f 	lds	r31, 0x3F46
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	19 95       	eicall
		
	}
}
     890:	c6 5f       	subi	r28, 0xF6	; 246
     892:	de 4f       	sbci	r29, 0xFE	; 254
     894:	cd bf       	out	0x3d, r28	; 61
     896:	de bf       	out	0x3e, r29	; 62
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	08 95       	ret

0000089e <i2c_init>:

// Initialize the i2c interface for CSP
int i2c_init(int handle, int mode, uint8_t addr, uint16_t speed, int queue_len_tx, int queue_len_rx, i2c_callback_t callback) {
     89e:	cf 92       	push	r12
     8a0:	df 92       	push	r13
     8a2:	cf 93       	push	r28
     8a4:	c4 2f       	mov	r28, r20
	
	// Initialize TWI master for CSP
	TWI_MasterInit(&twi_csp_master, &CSP_I2C_INTERFACE, TWI_MASTER_INTLVL_LO_gc, speed);
     8a6:	40 e4       	ldi	r20, 0x40	; 64
     8a8:	60 e8       	ldi	r22, 0x80	; 128
     8aa:	74 e0       	ldi	r23, 0x04	; 4
     8ac:	83 ef       	ldi	r24, 0xF3	; 243
     8ae:	9e e3       	ldi	r25, 0x3E	; 62
     8b0:	0e 94 ca 20 	call	0x4194	; 0x4194 <TWI_MasterInit>
			
	// Initialize TWI slave for CSP
	TWI_SlaveInitializeDriver(&twi_csp_slave, &CSP_I2C_INTERFACE, TWI_CSP_SlaveProcessData);
     8b4:	43 e1       	ldi	r20, 0x13	; 19
     8b6:	54 e0       	ldi	r21, 0x04	; 4
     8b8:	60 e8       	ldi	r22, 0x80	; 128
     8ba:	74 e0       	ldi	r23, 0x04	; 4
     8bc:	81 ea       	ldi	r24, 0xA1	; 161
     8be:	9e e3       	ldi	r25, 0x3E	; 62
     8c0:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <TWI_SlaveInitializeDriver>
	TWI_SlaveInitializeModule(&twi_csp_slave, addr, TWI_SLAVE_INTLVL_LO_gc);
     8c4:	40 e4       	ldi	r20, 0x40	; 64
     8c6:	6c 2f       	mov	r22, r28
     8c8:	81 ea       	ldi	r24, 0xA1	; 161
     8ca:	9e e3       	ldi	r25, 0x3E	; 62
     8cc:	0e 94 01 22 	call	0x4402	; 0x4402 <TWI_SlaveInitializeModule>
	
	callbackFunction = callback;
     8d0:	c0 92 45 3f 	sts	0x3F45, r12
     8d4:	d0 92 46 3f 	sts	0x3F46, r13
	
	return E_NO_ERR;
}
     8d8:	8f ef       	ldi	r24, 0xFF	; 255
     8da:	9f ef       	ldi	r25, 0xFF	; 255
     8dc:	cf 91       	pop	r28
     8de:	df 90       	pop	r13
     8e0:	cf 90       	pop	r12
     8e2:	08 95       	ret

000008e4 <i2c_send>:
 * @param timeout Ticks to wait
 * @return Error code
 */
int i2c_send(int handle, i2c_frame_t * frame, uint16_t timeout) {
		
	if (TWI_MasterWrite(&twi_csp_master, frame->dest, (uint8_t *) frame->data, frame->len)) {
     8e4:	ab 01       	movw	r20, r22
     8e6:	46 5f       	subi	r20, 0xF6	; 246
     8e8:	5f 4f       	sbci	r21, 0xFF	; 255
     8ea:	fb 01       	movw	r30, r22
     8ec:	20 85       	ldd	r18, Z+8	; 0x08
     8ee:	66 81       	ldd	r22, Z+6	; 0x06
     8f0:	83 ef       	ldi	r24, 0xF3	; 243
     8f2:	9e e3       	ldi	r25, 0x3E	; 62
     8f4:	0e 94 3b 21 	call	0x4276	; 0x4276 <TWI_MasterWrite>
     8f8:	88 23       	and	r24, r24
     8fa:	19 f0       	breq	.+6      	; 0x902 <i2c_send+0x1e>
		
		return E_NO_ERR;
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	9f ef       	ldi	r25, 0xFF	; 255
     900:	08 95       	ret
	} else {
		
		return 1;
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	90 e0       	ldi	r25, 0x00	; 0
	}
}
     906:	08 95       	ret

00000908 <clock_get_time>:

/* User functions required */
void clock_get_time(csp_timestamp_t * time) {
     908:	08 95       	ret

0000090a <clock_set_time>:
	
	
}

extern void clock_set_time(csp_timestamp_t * time) {
     90a:	08 95       	ret

0000090c <__vector_13>:
	
}

/*! CSP Master Interrupt vector. */
ISR(CSP_I2C_TWIM)
{
     90c:	1f 92       	push	r1
     90e:	0f 92       	push	r0
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	0f 92       	push	r0
     914:	11 24       	eor	r1, r1
     916:	08 b6       	in	r0, 0x38	; 56
     918:	0f 92       	push	r0
     91a:	18 be       	out	0x38, r1	; 56
     91c:	09 b6       	in	r0, 0x39	; 57
     91e:	0f 92       	push	r0
     920:	19 be       	out	0x39, r1	; 57
     922:	0b b6       	in	r0, 0x3b	; 59
     924:	0f 92       	push	r0
     926:	1b be       	out	0x3b, r1	; 59
     928:	2f 93       	push	r18
     92a:	3f 93       	push	r19
     92c:	4f 93       	push	r20
     92e:	5f 93       	push	r21
     930:	6f 93       	push	r22
     932:	7f 93       	push	r23
     934:	8f 93       	push	r24
     936:	9f 93       	push	r25
     938:	af 93       	push	r26
     93a:	bf 93       	push	r27
     93c:	ef 93       	push	r30
     93e:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twi_csp_master);
     940:	83 ef       	ldi	r24, 0xF3	; 243
     942:	9e e3       	ldi	r25, 0x3E	; 62
     944:	0e 94 d7 21 	call	0x43ae	; 0x43ae <TWI_MasterInterruptHandler>
}
     948:	ff 91       	pop	r31
     94a:	ef 91       	pop	r30
     94c:	bf 91       	pop	r27
     94e:	af 91       	pop	r26
     950:	9f 91       	pop	r25
     952:	8f 91       	pop	r24
     954:	7f 91       	pop	r23
     956:	6f 91       	pop	r22
     958:	5f 91       	pop	r21
     95a:	4f 91       	pop	r20
     95c:	3f 91       	pop	r19
     95e:	2f 91       	pop	r18
     960:	0f 90       	pop	r0
     962:	0b be       	out	0x3b, r0	; 59
     964:	0f 90       	pop	r0
     966:	09 be       	out	0x39, r0	; 57
     968:	0f 90       	pop	r0
     96a:	08 be       	out	0x38, r0	; 56
     96c:	0f 90       	pop	r0
     96e:	0f be       	out	0x3f, r0	; 63
     970:	0f 90       	pop	r0
     972:	1f 90       	pop	r1
     974:	18 95       	reti

00000976 <__vector_12>:

/*! CPS Slave Interrupt vector. */
ISR(CSP_I2C_TWIS)
{
     976:	1f 92       	push	r1
     978:	0f 92       	push	r0
     97a:	0f b6       	in	r0, 0x3f	; 63
     97c:	0f 92       	push	r0
     97e:	11 24       	eor	r1, r1
     980:	08 b6       	in	r0, 0x38	; 56
     982:	0f 92       	push	r0
     984:	18 be       	out	0x38, r1	; 56
     986:	09 b6       	in	r0, 0x39	; 57
     988:	0f 92       	push	r0
     98a:	19 be       	out	0x39, r1	; 57
     98c:	0b b6       	in	r0, 0x3b	; 59
     98e:	0f 92       	push	r0
     990:	1b be       	out	0x3b, r1	; 59
     992:	2f 93       	push	r18
     994:	3f 93       	push	r19
     996:	4f 93       	push	r20
     998:	5f 93       	push	r21
     99a:	6f 93       	push	r22
     99c:	7f 93       	push	r23
     99e:	8f 93       	push	r24
     9a0:	9f 93       	push	r25
     9a2:	af 93       	push	r26
     9a4:	bf 93       	push	r27
     9a6:	ef 93       	push	r30
     9a8:	ff 93       	push	r31
	TWI_SlaveInterruptHandler(&twi_csp_slave);
     9aa:	81 ea       	ldi	r24, 0xA1	; 161
     9ac:	9e e3       	ldi	r25, 0x3E	; 62
     9ae:	0e 94 d0 22 	call	0x45a0	; 0x45a0 <TWI_SlaveInterruptHandler>
     9b2:	ff 91       	pop	r31
     9b4:	ef 91       	pop	r30
     9b6:	bf 91       	pop	r27
     9b8:	af 91       	pop	r26
     9ba:	9f 91       	pop	r25
     9bc:	8f 91       	pop	r24
     9be:	7f 91       	pop	r23
     9c0:	6f 91       	pop	r22
     9c2:	5f 91       	pop	r21
     9c4:	4f 91       	pop	r20
     9c6:	3f 91       	pop	r19
     9c8:	2f 91       	pop	r18
     9ca:	0f 90       	pop	r0
     9cc:	0b be       	out	0x3b, r0	; 59
     9ce:	0f 90       	pop	r0
     9d0:	09 be       	out	0x39, r0	; 57
     9d2:	0f 90       	pop	r0
     9d4:	08 be       	out	0x38, r0	; 56
     9d6:	0f 90       	pop	r0
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	0f 90       	pop	r0
     9dc:	1f 90       	pop	r1
     9de:	18 95       	reti

000009e0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     9e6:	d4 d6       	rcall	.+3496   	; 0x1790 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     9e8:	40 91 e6 20 	lds	r20, 0x20E6
     9ec:	50 91 e7 20 	lds	r21, 0x20E7
     9f0:	9e 01       	movw	r18, r28
     9f2:	24 0f       	add	r18, r20
     9f4:	35 1f       	adc	r19, r21
     9f6:	28 35       	cpi	r18, 0x58	; 88
     9f8:	8b e1       	ldi	r24, 0x1B	; 27
     9fa:	38 07       	cpc	r19, r24
     9fc:	58 f4       	brcc	.+22     	; 0xa14 <pvPortMalloc+0x34>
     9fe:	42 17       	cp	r20, r18
     a00:	53 07       	cpc	r21, r19
     a02:	58 f4       	brcc	.+22     	; 0xa1a <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     a04:	ea 01       	movw	r28, r20
     a06:	c8 51       	subi	r28, 0x18	; 24
     a08:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     a0a:	20 93 e6 20 	sts	0x20E6, r18
     a0e:	30 93 e7 20 	sts	0x20E7, r19
     a12:	05 c0       	rjmp	.+10     	; 0xa1e <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     a14:	c0 e0       	ldi	r28, 0x00	; 0
     a16:	d0 e0       	ldi	r29, 0x00	; 0
     a18:	02 c0       	rjmp	.+4      	; 0xa1e <pvPortMalloc+0x3e>
     a1a:	c0 e0       	ldi	r28, 0x00	; 0
     a1c:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     a1e:	8c d7       	rcall	.+3864   	; 0x1938 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     a20:	ce 01       	movw	r24, r28
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	08 95       	ret

00000a28 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a28:	08 95       	ret

00000a2a <pxPortInitialiseStack>:
    /* Should not get here. */
    return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler(void) {
     a2a:	31 e1       	ldi	r19, 0x11	; 17
     a2c:	fc 01       	movw	r30, r24
     a2e:	30 83       	st	Z, r19
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	22 e2       	ldi	r18, 0x22	; 34
     a34:	20 83       	st	Z, r18
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	a3 e3       	ldi	r26, 0x33	; 51
     a3a:	a0 83       	st	Z, r26
     a3c:	31 97       	sbiw	r30, 0x01	; 1
     a3e:	60 83       	st	Z, r22
     a40:	31 97       	sbiw	r30, 0x01	; 1
     a42:	70 83       	st	Z, r23
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	10 82       	st	Z, r1
     a48:	31 97       	sbiw	r30, 0x01	; 1
     a4a:	10 82       	st	Z, r1
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	60 e8       	ldi	r22, 0x80	; 128
     a50:	60 83       	st	Z, r22
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	10 82       	st	Z, r1
     a56:	31 97       	sbiw	r30, 0x01	; 1
     a58:	62 e0       	ldi	r22, 0x02	; 2
     a5a:	60 83       	st	Z, r22
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	63 e0       	ldi	r22, 0x03	; 3
     a60:	60 83       	st	Z, r22
     a62:	31 97       	sbiw	r30, 0x01	; 1
     a64:	64 e0       	ldi	r22, 0x04	; 4
     a66:	60 83       	st	Z, r22
     a68:	31 97       	sbiw	r30, 0x01	; 1
     a6a:	65 e0       	ldi	r22, 0x05	; 5
     a6c:	60 83       	st	Z, r22
     a6e:	31 97       	sbiw	r30, 0x01	; 1
     a70:	66 e0       	ldi	r22, 0x06	; 6
     a72:	60 83       	st	Z, r22
     a74:	31 97       	sbiw	r30, 0x01	; 1
     a76:	67 e0       	ldi	r22, 0x07	; 7
     a78:	60 83       	st	Z, r22
     a7a:	31 97       	sbiw	r30, 0x01	; 1
     a7c:	68 e0       	ldi	r22, 0x08	; 8
     a7e:	60 83       	st	Z, r22
     a80:	31 97       	sbiw	r30, 0x01	; 1
     a82:	69 e0       	ldi	r22, 0x09	; 9
     a84:	60 83       	st	Z, r22
     a86:	31 97       	sbiw	r30, 0x01	; 1
     a88:	60 e1       	ldi	r22, 0x10	; 16
     a8a:	60 83       	st	Z, r22
     a8c:	31 97       	sbiw	r30, 0x01	; 1
     a8e:	30 83       	st	Z, r19
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	32 e1       	ldi	r19, 0x12	; 18
     a94:	30 83       	st	Z, r19
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	33 e1       	ldi	r19, 0x13	; 19
     a9a:	30 83       	st	Z, r19
     a9c:	31 97       	sbiw	r30, 0x01	; 1
     a9e:	34 e1       	ldi	r19, 0x14	; 20
     aa0:	30 83       	st	Z, r19
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	35 e1       	ldi	r19, 0x15	; 21
     aa6:	30 83       	st	Z, r19
     aa8:	31 97       	sbiw	r30, 0x01	; 1
     aaa:	36 e1       	ldi	r19, 0x16	; 22
     aac:	30 83       	st	Z, r19
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	37 e1       	ldi	r19, 0x17	; 23
     ab2:	30 83       	st	Z, r19
     ab4:	31 97       	sbiw	r30, 0x01	; 1
     ab6:	38 e1       	ldi	r19, 0x18	; 24
     ab8:	30 83       	st	Z, r19
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	39 e1       	ldi	r19, 0x19	; 25
     abe:	30 83       	st	Z, r19
     ac0:	31 97       	sbiw	r30, 0x01	; 1
     ac2:	30 e2       	ldi	r19, 0x20	; 32
     ac4:	30 83       	st	Z, r19
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	31 e2       	ldi	r19, 0x21	; 33
     aca:	30 83       	st	Z, r19
     acc:	31 97       	sbiw	r30, 0x01	; 1
     ace:	20 83       	st	Z, r18
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	23 e2       	ldi	r18, 0x23	; 35
     ad4:	20 83       	st	Z, r18
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	40 83       	st	Z, r20
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	50 83       	st	Z, r21
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	26 e2       	ldi	r18, 0x26	; 38
     ae2:	20 83       	st	Z, r18
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	27 e2       	ldi	r18, 0x27	; 39
     ae8:	20 83       	st	Z, r18
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	28 e2       	ldi	r18, 0x28	; 40
     aee:	20 83       	st	Z, r18
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	29 e2       	ldi	r18, 0x29	; 41
     af4:	20 83       	st	Z, r18
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	20 e3       	ldi	r18, 0x30	; 48
     afa:	20 83       	st	Z, r18
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	21 e3       	ldi	r18, 0x31	; 49
     b00:	20 83       	st	Z, r18
     b02:	87 97       	sbiw	r24, 0x27	; 39
     b04:	08 95       	ret

00000b06 <xPortStartScheduler>:
     b06:	65 e0       	ldi	r22, 0x05	; 5
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	98 e0       	ldi	r25, 0x08	; 8
     b0c:	0e 94 b2 20 	call	0x4164	; 0x4164 <TC0_ConfigClockSource>
     b10:	83 ef       	ldi	r24, 0xF3	; 243
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	e0 e0       	ldi	r30, 0x00	; 0
     b16:	f8 e0       	ldi	r31, 0x08	; 8
     b18:	86 a3       	std	Z+38, r24	; 0x26
     b1a:	97 a3       	std	Z+39, r25	; 0x27
     b1c:	61 e0       	ldi	r22, 0x01	; 1
     b1e:	80 e0       	ldi	r24, 0x00	; 0
     b20:	98 e0       	ldi	r25, 0x08	; 8
     b22:	0e 94 be 20 	call	0x417c	; 0x417c <TC0_SetOverflowIntLevel>
     b26:	e0 ea       	ldi	r30, 0xA0	; 160
     b28:	f0 e0       	ldi	r31, 0x00	; 0
     b2a:	82 81       	ldd	r24, Z+2	; 0x02
     b2c:	81 60       	ori	r24, 0x01	; 1
     b2e:	82 83       	std	Z+2, r24	; 0x02
     b30:	a0 91 b3 3c 	lds	r26, 0x3CB3
     b34:	b0 91 b4 3c 	lds	r27, 0x3CB4
     b38:	cd 91       	ld	r28, X+
     b3a:	cd bf       	out	0x3d, r28	; 61
     b3c:	dd 91       	ld	r29, X+
     b3e:	de bf       	out	0x3e, r29	; 62
     b40:	ff 91       	pop	r31
     b42:	ef 91       	pop	r30
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	bf 91       	pop	r27
     b4a:	af 91       	pop	r26
     b4c:	9f 91       	pop	r25
     b4e:	8f 91       	pop	r24
     b50:	7f 91       	pop	r23
     b52:	6f 91       	pop	r22
     b54:	5f 91       	pop	r21
     b56:	4f 91       	pop	r20
     b58:	3f 91       	pop	r19
     b5a:	2f 91       	pop	r18
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	ff 90       	pop	r15
     b62:	ef 90       	pop	r14
     b64:	df 90       	pop	r13
     b66:	cf 90       	pop	r12
     b68:	bf 90       	pop	r11
     b6a:	af 90       	pop	r10
     b6c:	9f 90       	pop	r9
     b6e:	8f 90       	pop	r8
     b70:	7f 90       	pop	r7
     b72:	6f 90       	pop	r6
     b74:	5f 90       	pop	r5
     b76:	4f 90       	pop	r4
     b78:	3f 90       	pop	r3
     b7a:	2f 90       	pop	r2
     b7c:	1f 90       	pop	r1
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	0f 90       	pop	r0
     b84:	08 95       	ret
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	08 95       	ret

00000b8a <vPortYield>:
 * Manual context switch.  The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield(void) __attribute__ ( ( naked ) );
void vPortYield(void) {
    portSAVE_CONTEXT();
     b8a:	0f 92       	push	r0
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
     b92:	1f 92       	push	r1
     b94:	11 24       	eor	r1, r1
     b96:	2f 92       	push	r2
     b98:	3f 92       	push	r3
     b9a:	4f 92       	push	r4
     b9c:	5f 92       	push	r5
     b9e:	6f 92       	push	r6
     ba0:	7f 92       	push	r7
     ba2:	8f 92       	push	r8
     ba4:	9f 92       	push	r9
     ba6:	af 92       	push	r10
     ba8:	bf 92       	push	r11
     baa:	cf 92       	push	r12
     bac:	df 92       	push	r13
     bae:	ef 92       	push	r14
     bb0:	ff 92       	push	r15
     bb2:	0f 93       	push	r16
     bb4:	1f 93       	push	r17
     bb6:	2f 93       	push	r18
     bb8:	3f 93       	push	r19
     bba:	4f 93       	push	r20
     bbc:	5f 93       	push	r21
     bbe:	6f 93       	push	r22
     bc0:	7f 93       	push	r23
     bc2:	8f 93       	push	r24
     bc4:	9f 93       	push	r25
     bc6:	af 93       	push	r26
     bc8:	bf 93       	push	r27
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	ef 93       	push	r30
     bd0:	ff 93       	push	r31
     bd2:	a0 91 b3 3c 	lds	r26, 0x3CB3
     bd6:	b0 91 b4 3c 	lds	r27, 0x3CB4
     bda:	0d b6       	in	r0, 0x3d	; 61
     bdc:	0d 92       	st	X+, r0
     bde:	0e b6       	in	r0, 0x3e	; 62
     be0:	0d 92       	st	X+, r0
    vTaskSwitchContext();
     be2:	a2 d7       	rcall	.+3908   	; 0x1b28 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     be4:	a0 91 b3 3c 	lds	r26, 0x3CB3
     be8:	b0 91 b4 3c 	lds	r27, 0x3CB4
     bec:	cd 91       	ld	r28, X+
     bee:	cd bf       	out	0x3d, r28	; 61
     bf0:	dd 91       	ld	r29, X+
     bf2:	de bf       	out	0x3e, r29	; 62
     bf4:	ff 91       	pop	r31
     bf6:	ef 91       	pop	r30
     bf8:	df 91       	pop	r29
     bfa:	cf 91       	pop	r28
     bfc:	bf 91       	pop	r27
     bfe:	af 91       	pop	r26
     c00:	9f 91       	pop	r25
     c02:	8f 91       	pop	r24
     c04:	7f 91       	pop	r23
     c06:	6f 91       	pop	r22
     c08:	5f 91       	pop	r21
     c0a:	4f 91       	pop	r20
     c0c:	3f 91       	pop	r19
     c0e:	2f 91       	pop	r18
     c10:	1f 91       	pop	r17
     c12:	0f 91       	pop	r16
     c14:	ff 90       	pop	r15
     c16:	ef 90       	pop	r14
     c18:	df 90       	pop	r13
     c1a:	cf 90       	pop	r12
     c1c:	bf 90       	pop	r11
     c1e:	af 90       	pop	r10
     c20:	9f 90       	pop	r9
     c22:	8f 90       	pop	r8
     c24:	7f 90       	pop	r7
     c26:	6f 90       	pop	r6
     c28:	5f 90       	pop	r5
     c2a:	4f 90       	pop	r4
     c2c:	3f 90       	pop	r3
     c2e:	2f 90       	pop	r2
     c30:	1f 90       	pop	r1
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
     c36:	0f 90       	pop	r0

    asm volatile ( "ret" );
     c38:	08 95       	ret

00000c3a <__vector_14>:
     * Context switch function used by the tick.  This must be identical to
     * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
     * difference from vPortYield() is the tick count is incremented as the
     * call comes from the tick ISR.
     */
    portSAVE_CONTEXT();
     c3a:	0f 92       	push	r0
     c3c:	0f b6       	in	r0, 0x3f	; 63
     c3e:	f8 94       	cli
     c40:	0f 92       	push	r0
     c42:	1f 92       	push	r1
     c44:	11 24       	eor	r1, r1
     c46:	2f 92       	push	r2
     c48:	3f 92       	push	r3
     c4a:	4f 92       	push	r4
     c4c:	5f 92       	push	r5
     c4e:	6f 92       	push	r6
     c50:	7f 92       	push	r7
     c52:	8f 92       	push	r8
     c54:	9f 92       	push	r9
     c56:	af 92       	push	r10
     c58:	bf 92       	push	r11
     c5a:	cf 92       	push	r12
     c5c:	df 92       	push	r13
     c5e:	ef 92       	push	r14
     c60:	ff 92       	push	r15
     c62:	0f 93       	push	r16
     c64:	1f 93       	push	r17
     c66:	2f 93       	push	r18
     c68:	3f 93       	push	r19
     c6a:	4f 93       	push	r20
     c6c:	5f 93       	push	r21
     c6e:	6f 93       	push	r22
     c70:	7f 93       	push	r23
     c72:	8f 93       	push	r24
     c74:	9f 93       	push	r25
     c76:	af 93       	push	r26
     c78:	bf 93       	push	r27
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	ef 93       	push	r30
     c80:	ff 93       	push	r31
     c82:	a0 91 b3 3c 	lds	r26, 0x3CB3
     c86:	b0 91 b4 3c 	lds	r27, 0x3CB4
     c8a:	0d b6       	in	r0, 0x3d	; 61
     c8c:	0d 92       	st	X+, r0
     c8e:	0e b6       	in	r0, 0x3e	; 62
     c90:	0d 92       	st	X+, r0
    vTaskIncrementTick();
     c92:	91 d5       	rcall	.+2850   	; 0x17b6 <vTaskIncrementTick>
    vTaskSwitchContext();
     c94:	49 d7       	rcall	.+3730   	; 0x1b28 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     c96:	a0 91 b3 3c 	lds	r26, 0x3CB3
     c9a:	b0 91 b4 3c 	lds	r27, 0x3CB4
     c9e:	cd 91       	ld	r28, X+
     ca0:	cd bf       	out	0x3d, r28	; 61
     ca2:	dd 91       	ld	r29, X+
     ca4:	de bf       	out	0x3e, r29	; 62
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	df 91       	pop	r29
     cac:	cf 91       	pop	r28
     cae:	bf 91       	pop	r27
     cb0:	af 91       	pop	r26
     cb2:	9f 91       	pop	r25
     cb4:	8f 91       	pop	r24
     cb6:	7f 91       	pop	r23
     cb8:	6f 91       	pop	r22
     cba:	5f 91       	pop	r21
     cbc:	4f 91       	pop	r20
     cbe:	3f 91       	pop	r19
     cc0:	2f 91       	pop	r18
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	8f 90       	pop	r8
     cd6:	7f 90       	pop	r7
     cd8:	6f 90       	pop	r6
     cda:	5f 90       	pop	r5
     cdc:	4f 90       	pop	r4
     cde:	3f 90       	pop	r3
     ce0:	2f 90       	pop	r2
     ce2:	1f 90       	pop	r1
     ce4:	0f 90       	pop	r0
     ce6:	0f be       	out	0x3f, r0	; 63
     ce8:	0f 90       	pop	r0
    asm volatile ( "reti" );
     cea:	18 95       	reti

00000cec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     cec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     cee:	03 96       	adiw	r24, 0x03	; 3
     cf0:	81 83       	std	Z+1, r24	; 0x01
     cf2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     cf4:	2f ef       	ldi	r18, 0xFF	; 255
     cf6:	3f ef       	ldi	r19, 0xFF	; 255
     cf8:	23 83       	std	Z+3, r18	; 0x03
     cfa:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     cfc:	85 83       	std	Z+5, r24	; 0x05
     cfe:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     d00:	87 83       	std	Z+7, r24	; 0x07
     d02:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     d04:	10 82       	st	Z, r1
     d06:	08 95       	ret

00000d08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d08:	fc 01       	movw	r30, r24
     d0a:	10 86       	std	Z+8, r1	; 0x08
     d0c:	11 86       	std	Z+9, r1	; 0x09
     d0e:	08 95       	ret

00000d10 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	fc 01       	movw	r30, r24
     d16:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     d18:	21 81       	ldd	r18, Z+1	; 0x01
     d1a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     d1c:	e9 01       	movw	r28, r18
     d1e:	8a 81       	ldd	r24, Y+2	; 0x02
     d20:	9b 81       	ldd	r25, Y+3	; 0x03
     d22:	12 96       	adiw	r26, 0x02	; 2
     d24:	8d 93       	st	X+, r24
     d26:	9c 93       	st	X, r25
     d28:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
     d2a:	81 81       	ldd	r24, Z+1	; 0x01
     d2c:	92 81       	ldd	r25, Z+2	; 0x02
     d2e:	14 96       	adiw	r26, 0x04	; 4
     d30:	8d 93       	st	X+, r24
     d32:	9c 93       	st	X, r25
     d34:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     d36:	8a 81       	ldd	r24, Y+2	; 0x02
     d38:	9b 81       	ldd	r25, Y+3	; 0x03
     d3a:	ec 01       	movw	r28, r24
     d3c:	6c 83       	std	Y+4, r22	; 0x04
     d3e:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     d40:	e9 01       	movw	r28, r18
     d42:	6a 83       	std	Y+2, r22	; 0x02
     d44:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     d46:	61 83       	std	Z+1, r22	; 0x01
     d48:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d4a:	18 96       	adiw	r26, 0x08	; 8
     d4c:	ed 93       	st	X+, r30
     d4e:	fc 93       	st	X, r31
     d50:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
     d52:	80 81       	ld	r24, Z
     d54:	8f 5f       	subi	r24, 0xFF	; 255
     d56:	80 83       	st	Z, r24
}
     d58:	df 91       	pop	r29
     d5a:	cf 91       	pop	r28
     d5c:	08 95       	ret

00000d5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d64:	48 81       	ld	r20, Y
     d66:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d68:	4f 3f       	cpi	r20, 0xFF	; 255
     d6a:	2f ef       	ldi	r18, 0xFF	; 255
     d6c:	52 07       	cpc	r21, r18
     d6e:	31 f4       	brne	.+12     	; 0xd7c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d70:	dc 01       	movw	r26, r24
     d72:	17 96       	adiw	r26, 0x07	; 7
     d74:	ed 91       	ld	r30, X+
     d76:	fc 91       	ld	r31, X
     d78:	18 97       	sbiw	r26, 0x08	; 8
     d7a:	17 c0       	rjmp	.+46     	; 0xdaa <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     d7c:	fc 01       	movw	r30, r24
     d7e:	33 96       	adiw	r30, 0x03	; 3
     d80:	dc 01       	movw	r26, r24
     d82:	15 96       	adiw	r26, 0x05	; 5
     d84:	2d 91       	ld	r18, X+
     d86:	3c 91       	ld	r19, X
     d88:	16 97       	sbiw	r26, 0x06	; 6
     d8a:	d9 01       	movw	r26, r18
     d8c:	2d 91       	ld	r18, X+
     d8e:	3c 91       	ld	r19, X
     d90:	42 17       	cp	r20, r18
     d92:	53 07       	cpc	r21, r19
     d94:	50 f0       	brcs	.+20     	; 0xdaa <vListInsert+0x4c>
     d96:	02 80       	ldd	r0, Z+2	; 0x02
     d98:	f3 81       	ldd	r31, Z+3	; 0x03
     d9a:	e0 2d       	mov	r30, r0
     d9c:	a2 81       	ldd	r26, Z+2	; 0x02
     d9e:	b3 81       	ldd	r27, Z+3	; 0x03
     da0:	2d 91       	ld	r18, X+
     da2:	3c 91       	ld	r19, X
     da4:	42 17       	cp	r20, r18
     da6:	53 07       	cpc	r21, r19
     da8:	b0 f7       	brcc	.-20     	; 0xd96 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     daa:	a2 81       	ldd	r26, Z+2	; 0x02
     dac:	b3 81       	ldd	r27, Z+3	; 0x03
     dae:	aa 83       	std	Y+2, r26	; 0x02
     db0:	bb 83       	std	Y+3, r27	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     db2:	14 96       	adiw	r26, 0x04	; 4
     db4:	cd 93       	st	X+, r28
     db6:	dc 93       	st	X, r29
     db8:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxIterator;
     dba:	ec 83       	std	Y+4, r30	; 0x04
     dbc:	fd 83       	std	Y+5, r31	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     dbe:	c2 83       	std	Z+2, r28	; 0x02
     dc0:	d3 83       	std	Z+3, r29	; 0x03

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     dc2:	88 87       	std	Y+8, r24	; 0x08
     dc4:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     dc6:	fc 01       	movw	r30, r24
     dc8:	20 81       	ld	r18, Z
     dca:	2f 5f       	subi	r18, 0xFF	; 255
     dcc:	20 83       	st	Z, r18
}
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	08 95       	ret

00000dd4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     dd4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     dd6:	a2 81       	ldd	r26, Z+2	; 0x02
     dd8:	b3 81       	ldd	r27, Z+3	; 0x03
     dda:	84 81       	ldd	r24, Z+4	; 0x04
     ddc:	95 81       	ldd	r25, Z+5	; 0x05
     dde:	14 96       	adiw	r26, 0x04	; 4
     de0:	8d 93       	st	X+, r24
     de2:	9c 93       	st	X, r25
     de4:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     de6:	a4 81       	ldd	r26, Z+4	; 0x04
     de8:	b5 81       	ldd	r27, Z+5	; 0x05
     dea:	82 81       	ldd	r24, Z+2	; 0x02
     dec:	93 81       	ldd	r25, Z+3	; 0x03
     dee:	12 96       	adiw	r26, 0x02	; 2
     df0:	8d 93       	st	X+, r24
     df2:	9c 93       	st	X, r25
     df4:	13 97       	sbiw	r26, 0x03	; 3
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     df6:	a0 85       	ldd	r26, Z+8	; 0x08
     df8:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     dfa:	11 96       	adiw	r26, 0x01	; 1
     dfc:	8d 91       	ld	r24, X+
     dfe:	9c 91       	ld	r25, X
     e00:	12 97       	sbiw	r26, 0x02	; 2
     e02:	8e 17       	cp	r24, r30
     e04:	9f 07       	cpc	r25, r31
     e06:	31 f4       	brne	.+12     	; 0xe14 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e08:	84 81       	ldd	r24, Z+4	; 0x04
     e0a:	95 81       	ldd	r25, Z+5	; 0x05
     e0c:	11 96       	adiw	r26, 0x01	; 1
     e0e:	8d 93       	st	X+, r24
     e10:	9c 93       	st	X, r25
     e12:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     e14:	10 86       	std	Z+8, r1	; 0x08
     e16:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     e18:	8c 91       	ld	r24, X
     e1a:	81 50       	subi	r24, 0x01	; 1
     e1c:	8c 93       	st	X, r24
     e1e:	08 95       	ret

00000e20 <prvCopyDataToQueue>:

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );

	return xReturn;
}
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
     e24:	ec 01       	movw	r28, r24
     e26:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e28:	81 11       	cpse	r24, r1
     e2a:	0b c0       	rjmp	.+22     	; 0xe42 <prvCopyDataToQueue+0x22>
     e2c:	88 81       	ld	r24, Y
     e2e:	99 81       	ldd	r25, Y+1	; 0x01
     e30:	89 2b       	or	r24, r25
     e32:	e1 f5       	brne	.+120    	; 0xeac <prvCopyDataToQueue+0x8c>
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	9b 81       	ldd	r25, Y+3	; 0x03
     e38:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vTaskPriorityDisinherit>
     e3c:	1a 82       	std	Y+2, r1	; 0x02
     e3e:	1b 82       	std	Y+3, r1	; 0x03
     e40:	35 c0       	rjmp	.+106    	; 0xeac <prvCopyDataToQueue+0x8c>
     e42:	41 11       	cpse	r20, r1
     e44:	17 c0       	rjmp	.+46     	; 0xe74 <prvCopyDataToQueue+0x54>
     e46:	48 2f       	mov	r20, r24
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	8c 81       	ldd	r24, Y+4	; 0x04
     e4c:	9d 81       	ldd	r25, Y+5	; 0x05
     e4e:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
     e52:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e54:	8c 81       	ldd	r24, Y+4	; 0x04
     e56:	9d 81       	ldd	r25, Y+5	; 0x05
     e58:	82 0f       	add	r24, r18
     e5a:	91 1d       	adc	r25, r1
     e5c:	8c 83       	std	Y+4, r24	; 0x04
     e5e:	9d 83       	std	Y+5, r25	; 0x05
     e60:	2a 81       	ldd	r18, Y+2	; 0x02
     e62:	3b 81       	ldd	r19, Y+3	; 0x03
     e64:	82 17       	cp	r24, r18
     e66:	93 07       	cpc	r25, r19
     e68:	08 f1       	brcs	.+66     	; 0xeac <prvCopyDataToQueue+0x8c>
     e6a:	88 81       	ld	r24, Y
     e6c:	99 81       	ldd	r25, Y+1	; 0x01
     e6e:	8c 83       	std	Y+4, r24	; 0x04
     e70:	9d 83       	std	Y+5, r25	; 0x05
     e72:	1c c0       	rjmp	.+56     	; 0xeac <prvCopyDataToQueue+0x8c>
     e74:	48 2f       	mov	r20, r24
     e76:	50 e0       	ldi	r21, 0x00	; 0
     e78:	8e 81       	ldd	r24, Y+6	; 0x06
     e7a:	9f 81       	ldd	r25, Y+7	; 0x07
     e7c:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
     e80:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e82:	30 e0       	ldi	r19, 0x00	; 0
     e84:	31 95       	neg	r19
     e86:	21 95       	neg	r18
     e88:	31 09       	sbc	r19, r1
     e8a:	8e 81       	ldd	r24, Y+6	; 0x06
     e8c:	9f 81       	ldd	r25, Y+7	; 0x07
     e8e:	82 0f       	add	r24, r18
     e90:	93 1f       	adc	r25, r19
     e92:	8e 83       	std	Y+6, r24	; 0x06
     e94:	9f 83       	std	Y+7, r25	; 0x07
     e96:	48 81       	ld	r20, Y
     e98:	59 81       	ldd	r21, Y+1	; 0x01
     e9a:	84 17       	cp	r24, r20
     e9c:	95 07       	cpc	r25, r21
     e9e:	30 f4       	brcc	.+12     	; 0xeac <prvCopyDataToQueue+0x8c>
     ea0:	8a 81       	ldd	r24, Y+2	; 0x02
     ea2:	9b 81       	ldd	r25, Y+3	; 0x03
     ea4:	28 0f       	add	r18, r24
     ea6:	39 1f       	adc	r19, r25
     ea8:	2e 83       	std	Y+6, r18	; 0x06
     eaa:	3f 83       	std	Y+7, r19	; 0x07
     eac:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	8a 8f       	std	Y+26, r24	; 0x1a
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	08 95       	ret

00000eb8 <prvCopyDataFromQueue>:
     eb8:	fc 01       	movw	r30, r24
     eba:	cb 01       	movw	r24, r22
     ebc:	a0 81       	ld	r26, Z
     ebe:	b1 81       	ldd	r27, Z+1	; 0x01
     ec0:	10 97       	sbiw	r26, 0x00	; 0
     ec2:	99 f0       	breq	.+38     	; 0xeea <prvCopyDataFromQueue+0x32>
     ec4:	44 8d       	ldd	r20, Z+28	; 0x1c
     ec6:	50 e0       	ldi	r21, 0x00	; 0
     ec8:	26 81       	ldd	r18, Z+6	; 0x06
     eca:	37 81       	ldd	r19, Z+7	; 0x07
     ecc:	24 0f       	add	r18, r20
     ece:	35 1f       	adc	r19, r21
     ed0:	26 83       	std	Z+6, r18	; 0x06
     ed2:	37 83       	std	Z+7, r19	; 0x07
     ed4:	62 81       	ldd	r22, Z+2	; 0x02
     ed6:	73 81       	ldd	r23, Z+3	; 0x03
     ed8:	26 17       	cp	r18, r22
     eda:	37 07       	cpc	r19, r23
     edc:	10 f0       	brcs	.+4      	; 0xee2 <prvCopyDataFromQueue+0x2a>
     ede:	a6 83       	std	Z+6, r26	; 0x06
     ee0:	b7 83       	std	Z+7, r27	; 0x07
     ee2:	66 81       	ldd	r22, Z+6	; 0x06
     ee4:	77 81       	ldd	r23, Z+7	; 0x07
     ee6:	0c 94 3c 2c 	jmp	0x5878	; 0x5878 <memcpy>
     eea:	08 95       	ret

00000eec <prvUnlockQueue>:
     eec:	0f 93       	push	r16
     eee:	1f 93       	push	r17
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	ec 01       	movw	r28, r24
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	f8 94       	cli
     efa:	0f 92       	push	r0
     efc:	8e 8d       	ldd	r24, Y+30	; 0x1e
     efe:	18 16       	cp	r1, r24
     f00:	9c f4       	brge	.+38     	; 0xf28 <prvUnlockQueue+0x3c>
     f02:	89 89       	ldd	r24, Y+17	; 0x11
     f04:	88 23       	and	r24, r24
     f06:	81 f0       	breq	.+32     	; 0xf28 <prvUnlockQueue+0x3c>
     f08:	8e 01       	movw	r16, r28
     f0a:	0f 5e       	subi	r16, 0xEF	; 239
     f0c:	1f 4f       	sbci	r17, 0xFF	; 255
     f0e:	03 c0       	rjmp	.+6      	; 0xf16 <prvUnlockQueue+0x2a>
     f10:	89 89       	ldd	r24, Y+17	; 0x11
     f12:	88 23       	and	r24, r24
     f14:	49 f0       	breq	.+18     	; 0xf28 <prvUnlockQueue+0x3c>
     f16:	c8 01       	movw	r24, r16
     f18:	f7 d6       	rcall	.+3566   	; 0x1d08 <xTaskRemoveFromEventList>
     f1a:	81 11       	cpse	r24, r1
     f1c:	81 d7       	rcall	.+3842   	; 0x1e20 <vTaskMissedYield>
     f1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f20:	81 50       	subi	r24, 0x01	; 1
     f22:	8e 8f       	std	Y+30, r24	; 0x1e
     f24:	18 16       	cp	r1, r24
     f26:	a4 f3       	brlt	.-24     	; 0xf10 <prvUnlockQueue+0x24>
     f28:	8f ef       	ldi	r24, 0xFF	; 255
     f2a:	8e 8f       	std	Y+30, r24	; 0x1e
     f2c:	0f 90       	pop	r0
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	f8 94       	cli
     f34:	0f 92       	push	r0
     f36:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f38:	18 16       	cp	r1, r24
     f3a:	9c f4       	brge	.+38     	; 0xf62 <prvUnlockQueue+0x76>
     f3c:	88 85       	ldd	r24, Y+8	; 0x08
     f3e:	88 23       	and	r24, r24
     f40:	81 f0       	breq	.+32     	; 0xf62 <prvUnlockQueue+0x76>
     f42:	8e 01       	movw	r16, r28
     f44:	08 5f       	subi	r16, 0xF8	; 248
     f46:	1f 4f       	sbci	r17, 0xFF	; 255
     f48:	03 c0       	rjmp	.+6      	; 0xf50 <prvUnlockQueue+0x64>
     f4a:	88 85       	ldd	r24, Y+8	; 0x08
     f4c:	88 23       	and	r24, r24
     f4e:	49 f0       	breq	.+18     	; 0xf62 <prvUnlockQueue+0x76>
     f50:	c8 01       	movw	r24, r16
     f52:	da d6       	rcall	.+3508   	; 0x1d08 <xTaskRemoveFromEventList>
     f54:	81 11       	cpse	r24, r1
     f56:	64 d7       	rcall	.+3784   	; 0x1e20 <vTaskMissedYield>
     f58:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f5a:	81 50       	subi	r24, 0x01	; 1
     f5c:	8d 8f       	std	Y+29, r24	; 0x1d
     f5e:	18 16       	cp	r1, r24
     f60:	a4 f3       	brlt	.-24     	; 0xf4a <prvUnlockQueue+0x5e>
     f62:	8f ef       	ldi	r24, 0xFF	; 255
     f64:	8d 8f       	std	Y+29, r24	; 0x1d
     f66:	0f 90       	pop	r0
     f68:	0f be       	out	0x3f, r0	; 63
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	1f 91       	pop	r17
     f70:	0f 91       	pop	r16
     f72:	08 95       	ret

00000f74 <xQueueCreate>:
     f74:	cf 92       	push	r12
     f76:	df 92       	push	r13
     f78:	ef 92       	push	r14
     f7a:	ff 92       	push	r15
     f7c:	0f 93       	push	r16
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29
     f84:	d8 2e       	mov	r13, r24
     f86:	c6 2e       	mov	r12, r22
     f88:	88 23       	and	r24, r24
     f8a:	a1 f1       	breq	.+104    	; 0xff4 <xQueueCreate+0x80>
     f8c:	8f e1       	ldi	r24, 0x1F	; 31
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	27 dd       	rcall	.-1458   	; 0x9e0 <pvPortMalloc>
     f92:	ec 01       	movw	r28, r24
     f94:	00 97       	sbiw	r24, 0x00	; 0
     f96:	81 f1       	breq	.+96     	; 0xff8 <xQueueCreate+0x84>
     f98:	ec 2c       	mov	r14, r12
     f9a:	f1 2c       	mov	r15, r1
     f9c:	de 9c       	mul	r13, r14
     f9e:	80 01       	movw	r16, r0
     fa0:	df 9c       	mul	r13, r15
     fa2:	10 0d       	add	r17, r0
     fa4:	11 24       	eor	r1, r1
     fa6:	c8 01       	movw	r24, r16
     fa8:	01 96       	adiw	r24, 0x01	; 1
     faa:	1a dd       	rcall	.-1484   	; 0x9e0 <pvPortMalloc>
     fac:	88 83       	st	Y, r24
     fae:	99 83       	std	Y+1, r25	; 0x01
     fb0:	00 97       	sbiw	r24, 0x00	; 0
     fb2:	d9 f0       	breq	.+54     	; 0xfea <xQueueCreate+0x76>
     fb4:	ac 01       	movw	r20, r24
     fb6:	40 0f       	add	r20, r16
     fb8:	51 1f       	adc	r21, r17
     fba:	4a 83       	std	Y+2, r20	; 0x02
     fbc:	5b 83       	std	Y+3, r21	; 0x03
     fbe:	1a 8e       	std	Y+26, r1	; 0x1a
     fc0:	8c 83       	std	Y+4, r24	; 0x04
     fc2:	9d 83       	std	Y+5, r25	; 0x05
     fc4:	0e 19       	sub	r16, r14
     fc6:	1f 09       	sbc	r17, r15
     fc8:	9c 01       	movw	r18, r24
     fca:	20 0f       	add	r18, r16
     fcc:	31 1f       	adc	r19, r17
     fce:	2e 83       	std	Y+6, r18	; 0x06
     fd0:	3f 83       	std	Y+7, r19	; 0x07
     fd2:	db 8e       	std	Y+27, r13	; 0x1b
     fd4:	cc 8e       	std	Y+28, r12	; 0x1c
     fd6:	8f ef       	ldi	r24, 0xFF	; 255
     fd8:	8d 8f       	std	Y+29, r24	; 0x1d
     fda:	8e 8f       	std	Y+30, r24	; 0x1e
     fdc:	ce 01       	movw	r24, r28
     fde:	08 96       	adiw	r24, 0x08	; 8
     fe0:	85 de       	rcall	.-758    	; 0xcec <vListInitialise>
     fe2:	ce 01       	movw	r24, r28
     fe4:	41 96       	adiw	r24, 0x11	; 17
     fe6:	82 de       	rcall	.-764    	; 0xcec <vListInitialise>
     fe8:	07 c0       	rjmp	.+14     	; 0xff8 <xQueueCreate+0x84>
     fea:	ce 01       	movw	r24, r28
     fec:	1d dd       	rcall	.-1478   	; 0xa28 <vPortFree>
     fee:	c0 e0       	ldi	r28, 0x00	; 0
     ff0:	d0 e0       	ldi	r29, 0x00	; 0
     ff2:	02 c0       	rjmp	.+4      	; 0xff8 <xQueueCreate+0x84>
     ff4:	c0 e0       	ldi	r28, 0x00	; 0
     ff6:	d0 e0       	ldi	r29, 0x00	; 0
     ff8:	ce 01       	movw	r24, r28
     ffa:	df 91       	pop	r29
     ffc:	cf 91       	pop	r28
     ffe:	1f 91       	pop	r17
    1000:	0f 91       	pop	r16
    1002:	ff 90       	pop	r15
    1004:	ef 90       	pop	r14
    1006:	df 90       	pop	r13
    1008:	cf 90       	pop	r12
    100a:	08 95       	ret

0000100c <xQueueGenericSend>:
    100c:	af 92       	push	r10
    100e:	bf 92       	push	r11
    1010:	cf 92       	push	r12
    1012:	df 92       	push	r13
    1014:	ef 92       	push	r14
    1016:	ff 92       	push	r15
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	cd b7       	in	r28, 0x3d	; 61
    1022:	de b7       	in	r29, 0x3e	; 62
    1024:	25 97       	sbiw	r28, 0x05	; 5
    1026:	cd bf       	out	0x3d, r28	; 61
    1028:	de bf       	out	0x3e, r29	; 62
    102a:	8c 01       	movw	r16, r24
    102c:	6b 01       	movw	r12, r22
    102e:	4c 83       	std	Y+4, r20	; 0x04
    1030:	5d 83       	std	Y+5, r21	; 0x05
    1032:	a2 2e       	mov	r10, r18
    1034:	b1 2c       	mov	r11, r1
    1036:	7c 01       	movw	r14, r24
    1038:	88 e0       	ldi	r24, 0x08	; 8
    103a:	e8 0e       	add	r14, r24
    103c:	f1 1c       	adc	r15, r1
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	f8 94       	cli
    1042:	0f 92       	push	r0
    1044:	f8 01       	movw	r30, r16
    1046:	92 8d       	ldd	r25, Z+26	; 0x1a
    1048:	83 8d       	ldd	r24, Z+27	; 0x1b
    104a:	98 17       	cp	r25, r24
    104c:	90 f4       	brcc	.+36     	; 0x1072 <xQueueGenericSend+0x66>
    104e:	4a 2d       	mov	r20, r10
    1050:	b6 01       	movw	r22, r12
    1052:	c8 01       	movw	r24, r16
    1054:	e5 de       	rcall	.-566    	; 0xe20 <prvCopyDataToQueue>
    1056:	f8 01       	movw	r30, r16
    1058:	81 89       	ldd	r24, Z+17	; 0x11
    105a:	88 23       	and	r24, r24
    105c:	31 f0       	breq	.+12     	; 0x106a <xQueueGenericSend+0x5e>
    105e:	c8 01       	movw	r24, r16
    1060:	41 96       	adiw	r24, 0x11	; 17
    1062:	52 d6       	rcall	.+3236   	; 0x1d08 <xTaskRemoveFromEventList>
    1064:	81 30       	cpi	r24, 0x01	; 1
    1066:	09 f4       	brne	.+2      	; 0x106a <xQueueGenericSend+0x5e>
    1068:	90 dd       	rcall	.-1248   	; 0xb8a <vPortYield>
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	47 c0       	rjmp	.+142    	; 0x1100 <xQueueGenericSend+0xf4>
    1072:	ec 81       	ldd	r30, Y+4	; 0x04
    1074:	fd 81       	ldd	r31, Y+5	; 0x05
    1076:	ef 2b       	or	r30, r31
    1078:	21 f4       	brne	.+8      	; 0x1082 <xQueueGenericSend+0x76>
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63
    107e:	80 e0       	ldi	r24, 0x00	; 0
    1080:	3f c0       	rjmp	.+126    	; 0x1100 <xQueueGenericSend+0xf4>
    1082:	b1 10       	cpse	r11, r1
    1084:	05 c0       	rjmp	.+10     	; 0x1090 <xQueueGenericSend+0x84>
    1086:	ce 01       	movw	r24, r28
    1088:	01 96       	adiw	r24, 0x01	; 1
    108a:	81 d6       	rcall	.+3330   	; 0x1d8e <vTaskSetTimeOutState>
    108c:	bb 24       	eor	r11, r11
    108e:	b3 94       	inc	r11
    1090:	0f 90       	pop	r0
    1092:	0f be       	out	0x3f, r0	; 63
    1094:	7d d3       	rcall	.+1786   	; 0x1790 <vTaskSuspendAll>
    1096:	0f b6       	in	r0, 0x3f	; 63
    1098:	f8 94       	cli
    109a:	0f 92       	push	r0
    109c:	f8 01       	movw	r30, r16
    109e:	85 8d       	ldd	r24, Z+29	; 0x1d
    10a0:	8f 3f       	cpi	r24, 0xFF	; 255
    10a2:	09 f4       	brne	.+2      	; 0x10a6 <xQueueGenericSend+0x9a>
    10a4:	15 8e       	std	Z+29, r1	; 0x1d
    10a6:	f8 01       	movw	r30, r16
    10a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    10aa:	8f 3f       	cpi	r24, 0xFF	; 255
    10ac:	09 f4       	brne	.+2      	; 0x10b0 <xQueueGenericSend+0xa4>
    10ae:	16 8e       	std	Z+30, r1	; 0x1e
    10b0:	0f 90       	pop	r0
    10b2:	0f be       	out	0x3f, r0	; 63
    10b4:	be 01       	movw	r22, r28
    10b6:	6c 5f       	subi	r22, 0xFC	; 252
    10b8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ba:	ce 01       	movw	r24, r28
    10bc:	01 96       	adiw	r24, 0x01	; 1
    10be:	72 d6       	rcall	.+3300   	; 0x1da4 <xTaskCheckForTimeOut>
    10c0:	81 11       	cpse	r24, r1
    10c2:	1a c0       	rjmp	.+52     	; 0x10f8 <xQueueGenericSend+0xec>
    10c4:	0f b6       	in	r0, 0x3f	; 63
    10c6:	f8 94       	cli
    10c8:	0f 92       	push	r0
    10ca:	f8 01       	movw	r30, r16
    10cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    10ce:	0f 90       	pop	r0
    10d0:	0f be       	out	0x3f, r0	; 63
    10d2:	f8 01       	movw	r30, r16
    10d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10d6:	98 13       	cpse	r25, r24
    10d8:	0b c0       	rjmp	.+22     	; 0x10f0 <xQueueGenericSend+0xe4>
    10da:	6c 81       	ldd	r22, Y+4	; 0x04
    10dc:	7d 81       	ldd	r23, Y+5	; 0x05
    10de:	c7 01       	movw	r24, r14
    10e0:	d1 d5       	rcall	.+2978   	; 0x1c84 <vTaskPlaceOnEventList>
    10e2:	c8 01       	movw	r24, r16
    10e4:	03 df       	rcall	.-506    	; 0xeec <prvUnlockQueue>
    10e6:	28 d4       	rcall	.+2128   	; 0x1938 <xTaskResumeAll>
    10e8:	81 11       	cpse	r24, r1
    10ea:	a9 cf       	rjmp	.-174    	; 0x103e <xQueueGenericSend+0x32>
    10ec:	4e dd       	rcall	.-1380   	; 0xb8a <vPortYield>
    10ee:	a7 cf       	rjmp	.-178    	; 0x103e <xQueueGenericSend+0x32>
    10f0:	c8 01       	movw	r24, r16
    10f2:	fc de       	rcall	.-520    	; 0xeec <prvUnlockQueue>
    10f4:	21 d4       	rcall	.+2114   	; 0x1938 <xTaskResumeAll>
    10f6:	a3 cf       	rjmp	.-186    	; 0x103e <xQueueGenericSend+0x32>
    10f8:	c8 01       	movw	r24, r16
    10fa:	f8 de       	rcall	.-528    	; 0xeec <prvUnlockQueue>
    10fc:	1d d4       	rcall	.+2106   	; 0x1938 <xTaskResumeAll>
    10fe:	80 e0       	ldi	r24, 0x00	; 0
    1100:	25 96       	adiw	r28, 0x05	; 5
    1102:	cd bf       	out	0x3d, r28	; 61
    1104:	de bf       	out	0x3e, r29	; 62
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	ff 90       	pop	r15
    1110:	ef 90       	pop	r14
    1112:	df 90       	pop	r13
    1114:	cf 90       	pop	r12
    1116:	bf 90       	pop	r11
    1118:	af 90       	pop	r10
    111a:	08 95       	ret

0000111c <xQueueCreateMutex>:
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
    1120:	8f e1       	ldi	r24, 0x1F	; 31
    1122:	90 e0       	ldi	r25, 0x00	; 0
    1124:	5d dc       	rcall	.-1862   	; 0x9e0 <pvPortMalloc>
    1126:	ec 01       	movw	r28, r24
    1128:	00 97       	sbiw	r24, 0x00	; 0
    112a:	e1 f0       	breq	.+56     	; 0x1164 <xQueueCreateMutex+0x48>
    112c:	1a 82       	std	Y+2, r1	; 0x02
    112e:	1b 82       	std	Y+3, r1	; 0x03
    1130:	18 82       	st	Y, r1
    1132:	19 82       	std	Y+1, r1	; 0x01
    1134:	1c 82       	std	Y+4, r1	; 0x04
    1136:	1d 82       	std	Y+5, r1	; 0x05
    1138:	1e 82       	std	Y+6, r1	; 0x06
    113a:	1f 82       	std	Y+7, r1	; 0x07
    113c:	1a 8e       	std	Y+26, r1	; 0x1a
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	8b 8f       	std	Y+27, r24	; 0x1b
    1142:	1c 8e       	std	Y+28, r1	; 0x1c
    1144:	8f ef       	ldi	r24, 0xFF	; 255
    1146:	8d 8f       	std	Y+29, r24	; 0x1d
    1148:	8e 8f       	std	Y+30, r24	; 0x1e
    114a:	ce 01       	movw	r24, r28
    114c:	08 96       	adiw	r24, 0x08	; 8
    114e:	ce dd       	rcall	.-1124   	; 0xcec <vListInitialise>
    1150:	ce 01       	movw	r24, r28
    1152:	41 96       	adiw	r24, 0x11	; 17
    1154:	cb dd       	rcall	.-1130   	; 0xcec <vListInitialise>
    1156:	20 e0       	ldi	r18, 0x00	; 0
    1158:	40 e0       	ldi	r20, 0x00	; 0
    115a:	50 e0       	ldi	r21, 0x00	; 0
    115c:	60 e0       	ldi	r22, 0x00	; 0
    115e:	70 e0       	ldi	r23, 0x00	; 0
    1160:	ce 01       	movw	r24, r28
    1162:	54 df       	rcall	.-344    	; 0x100c <xQueueGenericSend>
    1164:	ce 01       	movw	r24, r28
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <xQueueGenericSendFromISR>:
    116c:	0f 93       	push	r16
    116e:	1f 93       	push	r17
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	ec 01       	movw	r28, r24
    1176:	8a 01       	movw	r16, r20
    1178:	9a 8d       	ldd	r25, Y+26	; 0x1a
    117a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    117c:	98 17       	cp	r25, r24
    117e:	b0 f4       	brcc	.+44     	; 0x11ac <xQueueGenericSendFromISR+0x40>
    1180:	42 2f       	mov	r20, r18
    1182:	ce 01       	movw	r24, r28
    1184:	4d de       	rcall	.-870    	; 0xe20 <prvCopyDataToQueue>
    1186:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1188:	8f 3f       	cpi	r24, 0xFF	; 255
    118a:	61 f4       	brne	.+24     	; 0x11a4 <xQueueGenericSendFromISR+0x38>
    118c:	89 89       	ldd	r24, Y+17	; 0x11
    118e:	88 23       	and	r24, r24
    1190:	79 f0       	breq	.+30     	; 0x11b0 <xQueueGenericSendFromISR+0x44>
    1192:	ce 01       	movw	r24, r28
    1194:	41 96       	adiw	r24, 0x11	; 17
    1196:	b8 d5       	rcall	.+2928   	; 0x1d08 <xTaskRemoveFromEventList>
    1198:	88 23       	and	r24, r24
    119a:	61 f0       	breq	.+24     	; 0x11b4 <xQueueGenericSendFromISR+0x48>
    119c:	81 e0       	ldi	r24, 0x01	; 1
    119e:	f8 01       	movw	r30, r16
    11a0:	80 83       	st	Z, r24
    11a2:	09 c0       	rjmp	.+18     	; 0x11b6 <xQueueGenericSendFromISR+0x4a>
    11a4:	8f 5f       	subi	r24, 0xFF	; 255
    11a6:	8e 8f       	std	Y+30, r24	; 0x1e
    11a8:	81 e0       	ldi	r24, 0x01	; 1
    11aa:	05 c0       	rjmp	.+10     	; 0x11b6 <xQueueGenericSendFromISR+0x4a>
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	03 c0       	rjmp	.+6      	; 0x11b6 <xQueueGenericSendFromISR+0x4a>
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	01 c0       	rjmp	.+2      	; 0x11b6 <xQueueGenericSendFromISR+0x4a>
    11b4:	81 e0       	ldi	r24, 0x01	; 1
    11b6:	df 91       	pop	r29
    11b8:	cf 91       	pop	r28
    11ba:	1f 91       	pop	r17
    11bc:	0f 91       	pop	r16
    11be:	08 95       	ret

000011c0 <xQueueGenericReceive>:
    11c0:	af 92       	push	r10
    11c2:	bf 92       	push	r11
    11c4:	cf 92       	push	r12
    11c6:	df 92       	push	r13
    11c8:	ef 92       	push	r14
    11ca:	ff 92       	push	r15
    11cc:	0f 93       	push	r16
    11ce:	1f 93       	push	r17
    11d0:	cf 93       	push	r28
    11d2:	df 93       	push	r29
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	25 97       	sbiw	r28, 0x05	; 5
    11da:	cd bf       	out	0x3d, r28	; 61
    11dc:	de bf       	out	0x3e, r29	; 62
    11de:	8c 01       	movw	r16, r24
    11e0:	6b 01       	movw	r12, r22
    11e2:	4c 83       	std	Y+4, r20	; 0x04
    11e4:	5d 83       	std	Y+5, r21	; 0x05
    11e6:	b2 2e       	mov	r11, r18
    11e8:	a1 2c       	mov	r10, r1
    11ea:	7c 01       	movw	r14, r24
    11ec:	81 e1       	ldi	r24, 0x11	; 17
    11ee:	e8 0e       	add	r14, r24
    11f0:	f1 1c       	adc	r15, r1
    11f2:	0f b6       	in	r0, 0x3f	; 63
    11f4:	f8 94       	cli
    11f6:	0f 92       	push	r0
    11f8:	f8 01       	movw	r30, r16
    11fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    11fc:	88 23       	and	r24, r24
    11fe:	69 f1       	breq	.+90     	; 0x125a <xQueueGenericReceive+0x9a>
    1200:	e6 80       	ldd	r14, Z+6	; 0x06
    1202:	f7 80       	ldd	r15, Z+7	; 0x07
    1204:	b6 01       	movw	r22, r12
    1206:	c8 01       	movw	r24, r16
    1208:	57 de       	rcall	.-850    	; 0xeb8 <prvCopyDataFromQueue>
    120a:	b1 10       	cpse	r11, r1
    120c:	17 c0       	rjmp	.+46     	; 0x123c <xQueueGenericReceive+0x7c>
    120e:	f8 01       	movw	r30, r16
    1210:	82 8d       	ldd	r24, Z+26	; 0x1a
    1212:	81 50       	subi	r24, 0x01	; 1
    1214:	82 8f       	std	Z+26, r24	; 0x1a
    1216:	80 81       	ld	r24, Z
    1218:	91 81       	ldd	r25, Z+1	; 0x01
    121a:	89 2b       	or	r24, r25
    121c:	21 f4       	brne	.+8      	; 0x1226 <xQueueGenericReceive+0x66>
    121e:	04 d6       	rcall	.+3080   	; 0x1e28 <xTaskGetCurrentTaskHandle>
    1220:	f8 01       	movw	r30, r16
    1222:	82 83       	std	Z+2, r24	; 0x02
    1224:	93 83       	std	Z+3, r25	; 0x03
    1226:	f8 01       	movw	r30, r16
    1228:	80 85       	ldd	r24, Z+8	; 0x08
    122a:	88 23       	and	r24, r24
    122c:	91 f0       	breq	.+36     	; 0x1252 <xQueueGenericReceive+0x92>
    122e:	c8 01       	movw	r24, r16
    1230:	08 96       	adiw	r24, 0x08	; 8
    1232:	6a d5       	rcall	.+2772   	; 0x1d08 <xTaskRemoveFromEventList>
    1234:	81 30       	cpi	r24, 0x01	; 1
    1236:	69 f4       	brne	.+26     	; 0x1252 <xQueueGenericReceive+0x92>
    1238:	a8 dc       	rcall	.-1712   	; 0xb8a <vPortYield>
    123a:	0b c0       	rjmp	.+22     	; 0x1252 <xQueueGenericReceive+0x92>
    123c:	f8 01       	movw	r30, r16
    123e:	e6 82       	std	Z+6, r14	; 0x06
    1240:	f7 82       	std	Z+7, r15	; 0x07
    1242:	81 89       	ldd	r24, Z+17	; 0x11
    1244:	88 23       	and	r24, r24
    1246:	29 f0       	breq	.+10     	; 0x1252 <xQueueGenericReceive+0x92>
    1248:	c8 01       	movw	r24, r16
    124a:	41 96       	adiw	r24, 0x11	; 17
    124c:	5d d5       	rcall	.+2746   	; 0x1d08 <xTaskRemoveFromEventList>
    124e:	81 11       	cpse	r24, r1
    1250:	9c dc       	rcall	.-1736   	; 0xb8a <vPortYield>
    1252:	0f 90       	pop	r0
    1254:	0f be       	out	0x3f, r0	; 63
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	53 c0       	rjmp	.+166    	; 0x1300 <xQueueGenericReceive+0x140>
    125a:	4c 81       	ldd	r20, Y+4	; 0x04
    125c:	5d 81       	ldd	r21, Y+5	; 0x05
    125e:	45 2b       	or	r20, r21
    1260:	21 f4       	brne	.+8      	; 0x126a <xQueueGenericReceive+0xaa>
    1262:	0f 90       	pop	r0
    1264:	0f be       	out	0x3f, r0	; 63
    1266:	80 e0       	ldi	r24, 0x00	; 0
    1268:	4b c0       	rjmp	.+150    	; 0x1300 <xQueueGenericReceive+0x140>
    126a:	a1 10       	cpse	r10, r1
    126c:	05 c0       	rjmp	.+10     	; 0x1278 <xQueueGenericReceive+0xb8>
    126e:	ce 01       	movw	r24, r28
    1270:	01 96       	adiw	r24, 0x01	; 1
    1272:	8d d5       	rcall	.+2842   	; 0x1d8e <vTaskSetTimeOutState>
    1274:	aa 24       	eor	r10, r10
    1276:	a3 94       	inc	r10
    1278:	0f 90       	pop	r0
    127a:	0f be       	out	0x3f, r0	; 63
    127c:	89 d2       	rcall	.+1298   	; 0x1790 <vTaskSuspendAll>
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	0f 92       	push	r0
    1284:	f8 01       	movw	r30, r16
    1286:	85 8d       	ldd	r24, Z+29	; 0x1d
    1288:	8f 3f       	cpi	r24, 0xFF	; 255
    128a:	09 f4       	brne	.+2      	; 0x128e <xQueueGenericReceive+0xce>
    128c:	15 8e       	std	Z+29, r1	; 0x1d
    128e:	f8 01       	movw	r30, r16
    1290:	86 8d       	ldd	r24, Z+30	; 0x1e
    1292:	8f 3f       	cpi	r24, 0xFF	; 255
    1294:	09 f4       	brne	.+2      	; 0x1298 <xQueueGenericReceive+0xd8>
    1296:	16 8e       	std	Z+30, r1	; 0x1e
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	be 01       	movw	r22, r28
    129e:	6c 5f       	subi	r22, 0xFC	; 252
    12a0:	7f 4f       	sbci	r23, 0xFF	; 255
    12a2:	ce 01       	movw	r24, r28
    12a4:	01 96       	adiw	r24, 0x01	; 1
    12a6:	7e d5       	rcall	.+2812   	; 0x1da4 <xTaskCheckForTimeOut>
    12a8:	81 11       	cpse	r24, r1
    12aa:	26 c0       	rjmp	.+76     	; 0x12f8 <xQueueGenericReceive+0x138>
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	f8 94       	cli
    12b0:	0f 92       	push	r0
    12b2:	f8 01       	movw	r30, r16
    12b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    12b6:	0f 90       	pop	r0
    12b8:	0f be       	out	0x3f, r0	; 63
    12ba:	81 11       	cpse	r24, r1
    12bc:	19 c0       	rjmp	.+50     	; 0x12f0 <xQueueGenericReceive+0x130>
    12be:	f8 01       	movw	r30, r16
    12c0:	80 81       	ld	r24, Z
    12c2:	91 81       	ldd	r25, Z+1	; 0x01
    12c4:	89 2b       	or	r24, r25
    12c6:	49 f4       	brne	.+18     	; 0x12da <xQueueGenericReceive+0x11a>
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	0f 92       	push	r0
    12ce:	f8 01       	movw	r30, r16
    12d0:	82 81       	ldd	r24, Z+2	; 0x02
    12d2:	93 81       	ldd	r25, Z+3	; 0x03
    12d4:	bc d5       	rcall	.+2936   	; 0x1e4e <vTaskPriorityInherit>
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63
    12da:	6c 81       	ldd	r22, Y+4	; 0x04
    12dc:	7d 81       	ldd	r23, Y+5	; 0x05
    12de:	c7 01       	movw	r24, r14
    12e0:	d1 d4       	rcall	.+2466   	; 0x1c84 <vTaskPlaceOnEventList>
    12e2:	c8 01       	movw	r24, r16
    12e4:	03 de       	rcall	.-1018   	; 0xeec <prvUnlockQueue>
    12e6:	28 d3       	rcall	.+1616   	; 0x1938 <xTaskResumeAll>
    12e8:	81 11       	cpse	r24, r1
    12ea:	83 cf       	rjmp	.-250    	; 0x11f2 <xQueueGenericReceive+0x32>
    12ec:	4e dc       	rcall	.-1892   	; 0xb8a <vPortYield>
    12ee:	81 cf       	rjmp	.-254    	; 0x11f2 <xQueueGenericReceive+0x32>
    12f0:	c8 01       	movw	r24, r16
    12f2:	fc dd       	rcall	.-1032   	; 0xeec <prvUnlockQueue>
    12f4:	21 d3       	rcall	.+1602   	; 0x1938 <xTaskResumeAll>
    12f6:	7d cf       	rjmp	.-262    	; 0x11f2 <xQueueGenericReceive+0x32>
    12f8:	c8 01       	movw	r24, r16
    12fa:	f8 dd       	rcall	.-1040   	; 0xeec <prvUnlockQueue>
    12fc:	1d d3       	rcall	.+1594   	; 0x1938 <xTaskResumeAll>
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	25 96       	adiw	r28, 0x05	; 5
    1302:	cd bf       	out	0x3d, r28	; 61
    1304:	de bf       	out	0x3e, r29	; 62
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	1f 91       	pop	r17
    130c:	0f 91       	pop	r16
    130e:	ff 90       	pop	r15
    1310:	ef 90       	pop	r14
    1312:	df 90       	pop	r13
    1314:	cf 90       	pop	r12
    1316:	bf 90       	pop	r11
    1318:	af 90       	pop	r10
    131a:	08 95       	ret

0000131c <xQueueReceiveFromISR>:
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    1324:	ec 01       	movw	r28, r24
    1326:	8a 01       	movw	r16, r20
    1328:	8a 8d       	ldd	r24, Y+26	; 0x1a
    132a:	88 23       	and	r24, r24
    132c:	c1 f0       	breq	.+48     	; 0x135e <xQueueReceiveFromISR+0x42>
    132e:	ce 01       	movw	r24, r28
    1330:	c3 dd       	rcall	.-1146   	; 0xeb8 <prvCopyDataFromQueue>
    1332:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1334:	81 50       	subi	r24, 0x01	; 1
    1336:	8a 8f       	std	Y+26, r24	; 0x1a
    1338:	8d 8d       	ldd	r24, Y+29	; 0x1d
    133a:	8f 3f       	cpi	r24, 0xFF	; 255
    133c:	61 f4       	brne	.+24     	; 0x1356 <xQueueReceiveFromISR+0x3a>
    133e:	88 85       	ldd	r24, Y+8	; 0x08
    1340:	88 23       	and	r24, r24
    1342:	79 f0       	breq	.+30     	; 0x1362 <xQueueReceiveFromISR+0x46>
    1344:	ce 01       	movw	r24, r28
    1346:	08 96       	adiw	r24, 0x08	; 8
    1348:	df d4       	rcall	.+2494   	; 0x1d08 <xTaskRemoveFromEventList>
    134a:	88 23       	and	r24, r24
    134c:	61 f0       	breq	.+24     	; 0x1366 <xQueueReceiveFromISR+0x4a>
    134e:	81 e0       	ldi	r24, 0x01	; 1
    1350:	f8 01       	movw	r30, r16
    1352:	80 83       	st	Z, r24
    1354:	09 c0       	rjmp	.+18     	; 0x1368 <xQueueReceiveFromISR+0x4c>
    1356:	8f 5f       	subi	r24, 0xFF	; 255
    1358:	8d 8f       	std	Y+29, r24	; 0x1d
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	05 c0       	rjmp	.+10     	; 0x1368 <xQueueReceiveFromISR+0x4c>
    135e:	80 e0       	ldi	r24, 0x00	; 0
    1360:	03 c0       	rjmp	.+6      	; 0x1368 <xQueueReceiveFromISR+0x4c>
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	01 c0       	rjmp	.+2      	; 0x1368 <xQueueReceiveFromISR+0x4c>
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	08 95       	ret

00001372 <uxQueueMessagesWaiting>:
    1372:	0f b6       	in	r0, 0x3f	; 63
    1374:	f8 94       	cli
    1376:	0f 92       	push	r0
    1378:	fc 01       	movw	r30, r24
    137a:	82 8d       	ldd	r24, Z+26	; 0x1a
    137c:	0f 90       	pop	r0
    137e:	0f be       	out	0x3f, r0	; 63
    1380:	08 95       	ret

00001382 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	f8 94       	cli
    138c:	0f 92       	push	r0
    138e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1390:	8f 3f       	cpi	r24, 0xFF	; 255
    1392:	09 f4       	brne	.+2      	; 0x1396 <vQueueWaitForMessageRestricted+0x14>
    1394:	1d 8e       	std	Y+29, r1	; 0x1d
    1396:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1398:	8f 3f       	cpi	r24, 0xFF	; 255
    139a:	09 f4       	brne	.+2      	; 0x139e <vQueueWaitForMessageRestricted+0x1c>
    139c:	1e 8e       	std	Y+30, r1	; 0x1e
    139e:	0f 90       	pop	r0
    13a0:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
    13a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13a4:	81 11       	cpse	r24, r1
    13a6:	03 c0       	rjmp	.+6      	; 0x13ae <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13a8:	ce 01       	movw	r24, r28
    13aa:	41 96       	adiw	r24, 0x11	; 17
    13ac:	93 d4       	rcall	.+2342   	; 0x1cd4 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
    13ae:	ce 01       	movw	r24, r28
    13b0:	9d dd       	rcall	.-1222   	; 0xeec <prvUnlockQueue>
	}
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	08 95       	ret

000013b8 <prvIdleTask>:
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    13b8:	ca ea       	ldi	r28, 0xAA	; 170
    13ba:	dc e3       	ldi	r29, 0x3C	; 60
    13bc:	88 81       	ld	r24, Y
    13be:	82 30       	cpi	r24, 0x02	; 2
    13c0:	e8 f3       	brcs	.-6      	; 0x13bc <prvIdleTask+0x4>
    13c2:	e3 db       	rcall	.-2106   	; 0xb8a <vPortYield>
    13c4:	fb cf       	rjmp	.-10     	; 0x13bc <prvIdleTask+0x4>

000013c6 <prvAddCurrentTaskToDelayedList>:
    13c6:	cf 93       	push	r28
    13c8:	df 93       	push	r29
    13ca:	ec 01       	movw	r28, r24
    13cc:	e0 91 b3 3c 	lds	r30, 0x3CB3
    13d0:	f0 91 b4 3c 	lds	r31, 0x3CB4
    13d4:	82 83       	std	Z+2, r24	; 0x02
    13d6:	93 83       	std	Z+3, r25	; 0x03
    13d8:	80 91 7f 3c 	lds	r24, 0x3C7F
    13dc:	90 91 80 3c 	lds	r25, 0x3C80
    13e0:	c8 17       	cp	r28, r24
    13e2:	d9 07       	cpc	r29, r25
    13e4:	60 f4       	brcc	.+24     	; 0x13fe <prvAddCurrentTaskToDelayedList+0x38>
    13e6:	60 91 b3 3c 	lds	r22, 0x3CB3
    13ea:	70 91 b4 3c 	lds	r23, 0x3CB4
    13ee:	80 91 94 3c 	lds	r24, 0x3C94
    13f2:	90 91 95 3c 	lds	r25, 0x3C95
    13f6:	6e 5f       	subi	r22, 0xFE	; 254
    13f8:	7f 4f       	sbci	r23, 0xFF	; 255
    13fa:	b1 dc       	rcall	.-1694   	; 0xd5e <vListInsert>
    13fc:	16 c0       	rjmp	.+44     	; 0x142a <prvAddCurrentTaskToDelayedList+0x64>
    13fe:	60 91 b3 3c 	lds	r22, 0x3CB3
    1402:	70 91 b4 3c 	lds	r23, 0x3CB4
    1406:	80 91 96 3c 	lds	r24, 0x3C96
    140a:	90 91 97 3c 	lds	r25, 0x3C97
    140e:	6e 5f       	subi	r22, 0xFE	; 254
    1410:	7f 4f       	sbci	r23, 0xFF	; 255
    1412:	a5 dc       	rcall	.-1718   	; 0xd5e <vListInsert>
    1414:	80 91 05 20 	lds	r24, 0x2005
    1418:	90 91 06 20 	lds	r25, 0x2006
    141c:	c8 17       	cp	r28, r24
    141e:	d9 07       	cpc	r29, r25
    1420:	20 f4       	brcc	.+8      	; 0x142a <prvAddCurrentTaskToDelayedList+0x64>
    1422:	c0 93 05 20 	sts	0x2005, r28
    1426:	d0 93 06 20 	sts	0x2006, r29
    142a:	df 91       	pop	r29
    142c:	cf 91       	pop	r28
    142e:	08 95       	ret

00001430 <prvListTaskWithinSingleList>:
    1430:	3f 92       	push	r3
    1432:	4f 92       	push	r4
    1434:	5f 92       	push	r5
    1436:	6f 92       	push	r6
    1438:	7f 92       	push	r7
    143a:	8f 92       	push	r8
    143c:	9f 92       	push	r9
    143e:	af 92       	push	r10
    1440:	bf 92       	push	r11
    1442:	cf 92       	push	r12
    1444:	df 92       	push	r13
    1446:	ef 92       	push	r14
    1448:	ff 92       	push	r15
    144a:	0f 93       	push	r16
    144c:	1f 93       	push	r17
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	5c 01       	movw	r10, r24
    1454:	4b 01       	movw	r8, r22
    1456:	34 2e       	mov	r3, r20
    1458:	db 01       	movw	r26, r22
    145a:	11 96       	adiw	r26, 0x01	; 1
    145c:	ed 91       	ld	r30, X+
    145e:	fc 91       	ld	r31, X
    1460:	12 97       	sbiw	r26, 0x02	; 2
    1462:	02 80       	ldd	r0, Z+2	; 0x02
    1464:	f3 81       	ldd	r31, Z+3	; 0x03
    1466:	e0 2d       	mov	r30, r0
    1468:	11 96       	adiw	r26, 0x01	; 1
    146a:	ed 93       	st	X+, r30
    146c:	fc 93       	st	X, r31
    146e:	12 97       	sbiw	r26, 0x02	; 2
    1470:	7b 01       	movw	r14, r22
    1472:	b3 e0       	ldi	r27, 0x03	; 3
    1474:	eb 0e       	add	r14, r27
    1476:	f1 1c       	adc	r15, r1
    1478:	ee 15       	cp	r30, r14
    147a:	ff 05       	cpc	r31, r15
    147c:	29 f4       	brne	.+10     	; 0x1488 <prvListTaskWithinSingleList+0x58>
    147e:	82 81       	ldd	r24, Z+2	; 0x02
    1480:	93 81       	ldd	r25, Z+3	; 0x03
    1482:	fb 01       	movw	r30, r22
    1484:	81 83       	std	Z+1, r24	; 0x01
    1486:	92 83       	std	Z+2, r25	; 0x02
    1488:	d4 01       	movw	r26, r8
    148a:	11 96       	adiw	r26, 0x01	; 1
    148c:	ed 91       	ld	r30, X+
    148e:	fc 91       	ld	r31, X
    1490:	12 97       	sbiw	r26, 0x02	; 2
    1492:	c6 80       	ldd	r12, Z+6	; 0x06
    1494:	d7 80       	ldd	r13, Z+7	; 0x07
    1496:	43 2c       	mov	r4, r3
    1498:	55 24       	eor	r5, r5
    149a:	47 fc       	sbrc	r4, 7
    149c:	50 94       	com	r5
    149e:	0f 2e       	mov	r0, r31
    14a0:	ff e6       	ldi	r31, 0x6F	; 111
    14a2:	6f 2e       	mov	r6, r31
    14a4:	f0 e2       	ldi	r31, 0x20	; 32
    14a6:	7f 2e       	mov	r7, r31
    14a8:	f0 2d       	mov	r31, r0
    14aa:	00 e4       	ldi	r16, 0x40	; 64
    14ac:	1c e3       	ldi	r17, 0x3C	; 60
    14ae:	d4 01       	movw	r26, r8
    14b0:	11 96       	adiw	r26, 0x01	; 1
    14b2:	ed 91       	ld	r30, X+
    14b4:	fc 91       	ld	r31, X
    14b6:	12 97       	sbiw	r26, 0x02	; 2
    14b8:	82 81       	ldd	r24, Z+2	; 0x02
    14ba:	93 81       	ldd	r25, Z+3	; 0x03
    14bc:	11 96       	adiw	r26, 0x01	; 1
    14be:	8d 93       	st	X+, r24
    14c0:	9c 93       	st	X, r25
    14c2:	12 97       	sbiw	r26, 0x02	; 2
    14c4:	e8 16       	cp	r14, r24
    14c6:	f9 06       	cpc	r15, r25
    14c8:	39 f4       	brne	.+14     	; 0x14d8 <prvListTaskWithinSingleList+0xa8>
    14ca:	f7 01       	movw	r30, r14
    14cc:	82 81       	ldd	r24, Z+2	; 0x02
    14ce:	93 81       	ldd	r25, Z+3	; 0x03
    14d0:	11 96       	adiw	r26, 0x01	; 1
    14d2:	8d 93       	st	X+, r24
    14d4:	9c 93       	st	X, r25
    14d6:	12 97       	sbiw	r26, 0x02	; 2
    14d8:	d4 01       	movw	r26, r8
    14da:	11 96       	adiw	r26, 0x01	; 1
    14dc:	ed 91       	ld	r30, X+
    14de:	fc 91       	ld	r31, X
    14e0:	12 97       	sbiw	r26, 0x02	; 2
    14e2:	c6 81       	ldd	r28, Z+6	; 0x06
    14e4:	d7 81       	ldd	r29, Z+7	; 0x07
    14e6:	ef 89       	ldd	r30, Y+23	; 0x17
    14e8:	f8 8d       	ldd	r31, Y+24	; 0x18
    14ea:	80 81       	ld	r24, Z
    14ec:	85 3a       	cpi	r24, 0xA5	; 165
    14ee:	41 f4       	brne	.+16     	; 0x1500 <prvListTaskWithinSingleList+0xd0>
    14f0:	31 96       	adiw	r30, 0x01	; 1
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	01 96       	adiw	r24, 0x01	; 1
    14f8:	21 91       	ld	r18, Z+
    14fa:	25 3a       	cpi	r18, 0xA5	; 165
    14fc:	e1 f3       	breq	.-8      	; 0x14f6 <prvListTaskWithinSingleList+0xc6>
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <prvListTaskWithinSingleList+0xd4>
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	39 a1       	ldd	r19, Y+33	; 0x21
    1506:	2e 89       	ldd	r18, Y+22	; 0x16
    1508:	1f 92       	push	r1
    150a:	3f 93       	push	r19
    150c:	9f 93       	push	r25
    150e:	8f 93       	push	r24
    1510:	1f 92       	push	r1
    1512:	2f 93       	push	r18
    1514:	5f 92       	push	r5
    1516:	3f 92       	push	r3
    1518:	ce 01       	movw	r24, r28
    151a:	49 96       	adiw	r24, 0x19	; 25
    151c:	9f 93       	push	r25
    151e:	8f 93       	push	r24
    1520:	7f 92       	push	r7
    1522:	6f 92       	push	r6
    1524:	1f 93       	push	r17
    1526:	0f 93       	push	r16
    1528:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <sprintf>
    152c:	b8 01       	movw	r22, r16
    152e:	c5 01       	movw	r24, r10
    1530:	0e 94 4c 2c 	call	0x5898	; 0x5898 <strcat>
    1534:	ed b7       	in	r30, 0x3d	; 61
    1536:	fe b7       	in	r31, 0x3e	; 62
    1538:	3e 96       	adiw	r30, 0x0e	; 14
    153a:	ed bf       	out	0x3d, r30	; 61
    153c:	fe bf       	out	0x3e, r31	; 62
    153e:	cc 15       	cp	r28, r12
    1540:	dd 05       	cpc	r29, r13
    1542:	09 f0       	breq	.+2      	; 0x1546 <prvListTaskWithinSingleList+0x116>
    1544:	b4 cf       	rjmp	.-152    	; 0x14ae <prvListTaskWithinSingleList+0x7e>
    1546:	df 91       	pop	r29
    1548:	cf 91       	pop	r28
    154a:	1f 91       	pop	r17
    154c:	0f 91       	pop	r16
    154e:	ff 90       	pop	r15
    1550:	ef 90       	pop	r14
    1552:	df 90       	pop	r13
    1554:	cf 90       	pop	r12
    1556:	bf 90       	pop	r11
    1558:	af 90       	pop	r10
    155a:	9f 90       	pop	r9
    155c:	8f 90       	pop	r8
    155e:	7f 90       	pop	r7
    1560:	6f 90       	pop	r6
    1562:	5f 90       	pop	r5
    1564:	4f 90       	pop	r4
    1566:	3f 90       	pop	r3
    1568:	08 95       	ret

0000156a <xTaskGenericCreate>:
    156a:	4f 92       	push	r4
    156c:	5f 92       	push	r5
    156e:	6f 92       	push	r6
    1570:	7f 92       	push	r7
    1572:	8f 92       	push	r8
    1574:	9f 92       	push	r9
    1576:	af 92       	push	r10
    1578:	bf 92       	push	r11
    157a:	cf 92       	push	r12
    157c:	df 92       	push	r13
    157e:	ef 92       	push	r14
    1580:	ff 92       	push	r15
    1582:	0f 93       	push	r16
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	4c 01       	movw	r8, r24
    158a:	3b 01       	movw	r6, r22
    158c:	5a 01       	movw	r10, r20
    158e:	29 01       	movw	r4, r18
    1590:	83 e2       	ldi	r24, 0x23	; 35
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	25 da       	rcall	.-2998   	; 0x9e0 <pvPortMalloc>
    1596:	ec 01       	movw	r28, r24
    1598:	00 97       	sbiw	r24, 0x00	; 0
    159a:	09 f4       	brne	.+2      	; 0x159e <xTaskGenericCreate+0x34>
    159c:	9f c0       	rjmp	.+318    	; 0x16dc <xTaskGenericCreate+0x172>
    159e:	c1 14       	cp	r12, r1
    15a0:	d1 04       	cpc	r13, r1
    15a2:	09 f0       	breq	.+2      	; 0x15a6 <xTaskGenericCreate+0x3c>
    15a4:	97 c0       	rjmp	.+302    	; 0x16d4 <xTaskGenericCreate+0x16a>
    15a6:	c5 01       	movw	r24, r10
    15a8:	1b da       	rcall	.-3018   	; 0x9e0 <pvPortMalloc>
    15aa:	8f 8b       	std	Y+23, r24	; 0x17
    15ac:	98 8f       	std	Y+24, r25	; 0x18
    15ae:	00 97       	sbiw	r24, 0x00	; 0
    15b0:	19 f4       	brne	.+6      	; 0x15b8 <xTaskGenericCreate+0x4e>
    15b2:	ce 01       	movw	r24, r28
    15b4:	39 da       	rcall	.-2958   	; 0xa28 <vPortFree>
    15b6:	92 c0       	rjmp	.+292    	; 0x16dc <xTaskGenericCreate+0x172>
    15b8:	a5 01       	movw	r20, r10
    15ba:	65 ea       	ldi	r22, 0xA5	; 165
    15bc:	70 e0       	ldi	r23, 0x00	; 0
    15be:	0e 94 45 2c 	call	0x588a	; 0x588a <memset>
    15c2:	81 e0       	ldi	r24, 0x01	; 1
    15c4:	a8 1a       	sub	r10, r24
    15c6:	b1 08       	sbc	r11, r1
    15c8:	8f 89       	ldd	r24, Y+23	; 0x17
    15ca:	98 8d       	ldd	r25, Y+24	; 0x18
    15cc:	a8 0e       	add	r10, r24
    15ce:	b9 1e       	adc	r11, r25
    15d0:	48 e0       	ldi	r20, 0x08	; 8
    15d2:	50 e0       	ldi	r21, 0x00	; 0
    15d4:	b3 01       	movw	r22, r6
    15d6:	ce 01       	movw	r24, r28
    15d8:	49 96       	adiw	r24, 0x19	; 25
    15da:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncpy>
    15de:	18 a2       	std	Y+32, r1	; 0x20
    15e0:	1e 8a       	std	Y+22, r1	; 0x16
    15e2:	1a a2       	std	Y+34, r1	; 0x22
    15e4:	6e 01       	movw	r12, r28
    15e6:	e2 e0       	ldi	r30, 0x02	; 2
    15e8:	ce 0e       	add	r12, r30
    15ea:	d1 1c       	adc	r13, r1
    15ec:	c6 01       	movw	r24, r12
    15ee:	8c db       	rcall	.-2280   	; 0xd08 <vListInitialiseItem>
    15f0:	ce 01       	movw	r24, r28
    15f2:	0c 96       	adiw	r24, 0x0c	; 12
    15f4:	89 db       	rcall	.-2286   	; 0xd08 <vListInitialiseItem>
    15f6:	c8 87       	std	Y+8, r28	; 0x08
    15f8:	d9 87       	std	Y+9, r29	; 0x09
    15fa:	81 e0       	ldi	r24, 0x01	; 1
    15fc:	90 e0       	ldi	r25, 0x00	; 0
    15fe:	8c 87       	std	Y+12, r24	; 0x0c
    1600:	9d 87       	std	Y+13, r25	; 0x0d
    1602:	ca 8b       	std	Y+18, r28	; 0x12
    1604:	db 8b       	std	Y+19, r29	; 0x13
    1606:	a2 01       	movw	r20, r4
    1608:	b4 01       	movw	r22, r8
    160a:	c5 01       	movw	r24, r10
    160c:	0e da       	rcall	.-3044   	; 0xa2a <pxPortInitialiseStack>
    160e:	88 83       	st	Y, r24
    1610:	99 83       	std	Y+1, r25	; 0x01
    1612:	e1 14       	cp	r14, r1
    1614:	f1 04       	cpc	r15, r1
    1616:	19 f0       	breq	.+6      	; 0x161e <xTaskGenericCreate+0xb4>
    1618:	f7 01       	movw	r30, r14
    161a:	c0 83       	st	Z, r28
    161c:	d1 83       	std	Z+1, r29	; 0x01
    161e:	0f b6       	in	r0, 0x3f	; 63
    1620:	f8 94       	cli
    1622:	0f 92       	push	r0
    1624:	80 91 81 3c 	lds	r24, 0x3C81
    1628:	8f 5f       	subi	r24, 0xFF	; 255
    162a:	80 93 81 3c 	sts	0x3C81, r24
    162e:	80 91 b3 3c 	lds	r24, 0x3CB3
    1632:	90 91 b4 3c 	lds	r25, 0x3CB4
    1636:	89 2b       	or	r24, r25
    1638:	49 f4       	brne	.+18     	; 0x164c <xTaskGenericCreate+0xe2>
    163a:	c0 93 b3 3c 	sts	0x3CB3, r28
    163e:	d0 93 b4 3c 	sts	0x3CB4, r29
    1642:	80 91 81 3c 	lds	r24, 0x3C81
    1646:	81 30       	cpi	r24, 0x01	; 1
    1648:	81 f4       	brne	.+32     	; 0x166a <xTaskGenericCreate+0x100>
    164a:	4a c0       	rjmp	.+148    	; 0x16e0 <xTaskGenericCreate+0x176>
    164c:	80 91 7c 3c 	lds	r24, 0x3C7C
    1650:	81 11       	cpse	r24, r1
    1652:	0b c0       	rjmp	.+22     	; 0x166a <xTaskGenericCreate+0x100>
    1654:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1658:	f0 91 b4 3c 	lds	r31, 0x3CB4
    165c:	86 89       	ldd	r24, Z+22	; 0x16
    165e:	08 17       	cp	r16, r24
    1660:	20 f0       	brcs	.+8      	; 0x166a <xTaskGenericCreate+0x100>
    1662:	c0 93 b3 3c 	sts	0x3CB3, r28
    1666:	d0 93 b4 3c 	sts	0x3CB4, r29
    166a:	8e 89       	ldd	r24, Y+22	; 0x16
    166c:	90 91 7e 3c 	lds	r25, 0x3C7E
    1670:	98 17       	cp	r25, r24
    1672:	10 f4       	brcc	.+4      	; 0x1678 <xTaskGenericCreate+0x10e>
    1674:	80 93 7e 3c 	sts	0x3C7E, r24
    1678:	90 91 77 3c 	lds	r25, 0x3C77
    167c:	99 a3       	std	Y+33, r25	; 0x21
    167e:	9f 5f       	subi	r25, 0xFF	; 255
    1680:	90 93 77 3c 	sts	0x3C77, r25
    1684:	90 91 7d 3c 	lds	r25, 0x3C7D
    1688:	98 17       	cp	r25, r24
    168a:	10 f4       	brcc	.+4      	; 0x1690 <xTaskGenericCreate+0x126>
    168c:	80 93 7d 3c 	sts	0x3C7D, r24
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	9c 01       	movw	r18, r24
    1694:	22 0f       	add	r18, r18
    1696:	33 1f       	adc	r19, r19
    1698:	22 0f       	add	r18, r18
    169a:	33 1f       	adc	r19, r19
    169c:	22 0f       	add	r18, r18
    169e:	33 1f       	adc	r19, r19
    16a0:	82 0f       	add	r24, r18
    16a2:	93 1f       	adc	r25, r19
    16a4:	b6 01       	movw	r22, r12
    16a6:	86 55       	subi	r24, 0x56	; 86
    16a8:	93 4c       	sbci	r25, 0xC3	; 195
    16aa:	32 db       	rcall	.-2460   	; 0xd10 <vListInsertEnd>
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
    16b0:	80 91 7c 3c 	lds	r24, 0x3C7C
    16b4:	88 23       	and	r24, r24
    16b6:	51 f0       	breq	.+20     	; 0x16cc <xTaskGenericCreate+0x162>
    16b8:	e0 91 b3 3c 	lds	r30, 0x3CB3
    16bc:	f0 91 b4 3c 	lds	r31, 0x3CB4
    16c0:	86 89       	ldd	r24, Z+22	; 0x16
    16c2:	80 17       	cp	r24, r16
    16c4:	28 f4       	brcc	.+10     	; 0x16d0 <xTaskGenericCreate+0x166>
    16c6:	61 da       	rcall	.-2878   	; 0xb8a <vPortYield>
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	26 c0       	rjmp	.+76     	; 0x1718 <xTaskGenericCreate+0x1ae>
    16cc:	81 e0       	ldi	r24, 0x01	; 1
    16ce:	24 c0       	rjmp	.+72     	; 0x1718 <xTaskGenericCreate+0x1ae>
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	22 c0       	rjmp	.+68     	; 0x1718 <xTaskGenericCreate+0x1ae>
    16d4:	cf 8a       	std	Y+23, r12	; 0x17
    16d6:	d8 8e       	std	Y+24, r13	; 0x18
    16d8:	c6 01       	movw	r24, r12
    16da:	6e cf       	rjmp	.-292    	; 0x15b8 <xTaskGenericCreate+0x4e>
    16dc:	8f ef       	ldi	r24, 0xFF	; 255
    16de:	1c c0       	rjmp	.+56     	; 0x1718 <xTaskGenericCreate+0x1ae>
    16e0:	8a ea       	ldi	r24, 0xAA	; 170
    16e2:	9c e3       	ldi	r25, 0x3C	; 60
    16e4:	03 db       	rcall	.-2554   	; 0xcec <vListInitialise>
    16e6:	81 ea       	ldi	r24, 0xA1	; 161
    16e8:	9c e3       	ldi	r25, 0x3C	; 60
    16ea:	00 db       	rcall	.-2560   	; 0xcec <vListInitialise>
    16ec:	88 e9       	ldi	r24, 0x98	; 152
    16ee:	9c e3       	ldi	r25, 0x3C	; 60
    16f0:	fd da       	rcall	.-2566   	; 0xcec <vListInitialise>
    16f2:	8b e8       	ldi	r24, 0x8B	; 139
    16f4:	9c e3       	ldi	r25, 0x3C	; 60
    16f6:	fa da       	rcall	.-2572   	; 0xcec <vListInitialise>
    16f8:	82 e8       	ldi	r24, 0x82	; 130
    16fa:	9c e3       	ldi	r25, 0x3C	; 60
    16fc:	f7 da       	rcall	.-2578   	; 0xcec <vListInitialise>
    16fe:	81 ea       	ldi	r24, 0xA1	; 161
    1700:	9c e3       	ldi	r25, 0x3C	; 60
    1702:	80 93 96 3c 	sts	0x3C96, r24
    1706:	90 93 97 3c 	sts	0x3C97, r25
    170a:	88 e9       	ldi	r24, 0x98	; 152
    170c:	9c e3       	ldi	r25, 0x3C	; 60
    170e:	80 93 94 3c 	sts	0x3C94, r24
    1712:	90 93 95 3c 	sts	0x3C95, r25
    1716:	a9 cf       	rjmp	.-174    	; 0x166a <xTaskGenericCreate+0x100>
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	0f 91       	pop	r16
    171e:	ff 90       	pop	r15
    1720:	ef 90       	pop	r14
    1722:	df 90       	pop	r13
    1724:	cf 90       	pop	r12
    1726:	bf 90       	pop	r11
    1728:	af 90       	pop	r10
    172a:	9f 90       	pop	r9
    172c:	8f 90       	pop	r8
    172e:	7f 90       	pop	r7
    1730:	6f 90       	pop	r6
    1732:	5f 90       	pop	r5
    1734:	4f 90       	pop	r4
    1736:	08 95       	ret

00001738 <vTaskStartScheduler>:
    1738:	af 92       	push	r10
    173a:	bf 92       	push	r11
    173c:	cf 92       	push	r12
    173e:	df 92       	push	r13
    1740:	ef 92       	push	r14
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	a1 2c       	mov	r10, r1
    1748:	b1 2c       	mov	r11, r1
    174a:	c1 2c       	mov	r12, r1
    174c:	d1 2c       	mov	r13, r1
    174e:	e1 2c       	mov	r14, r1
    1750:	f1 2c       	mov	r15, r1
    1752:	00 e0       	ldi	r16, 0x00	; 0
    1754:	20 e0       	ldi	r18, 0x00	; 0
    1756:	30 e0       	ldi	r19, 0x00	; 0
    1758:	40 e4       	ldi	r20, 0x40	; 64
    175a:	50 e0       	ldi	r21, 0x00	; 0
    175c:	61 e8       	ldi	r22, 0x81	; 129
    175e:	70 e2       	ldi	r23, 0x20	; 32
    1760:	8c ed       	ldi	r24, 0xDC	; 220
    1762:	99 e0       	ldi	r25, 0x09	; 9
    1764:	02 df       	rcall	.-508    	; 0x156a <xTaskGenericCreate>
    1766:	81 30       	cpi	r24, 0x01	; 1
    1768:	59 f4       	brne	.+22     	; 0x1780 <vTaskStartScheduler+0x48>
    176a:	52 d4       	rcall	.+2212   	; 0x2010 <xTimerCreateTimerTask>
    176c:	81 30       	cpi	r24, 0x01	; 1
    176e:	41 f4       	brne	.+16     	; 0x1780 <vTaskStartScheduler+0x48>
    1770:	f8 94       	cli
    1772:	80 93 7c 3c 	sts	0x3C7C, r24
    1776:	10 92 7f 3c 	sts	0x3C7F, r1
    177a:	10 92 80 3c 	sts	0x3C80, r1
    177e:	c3 d9       	rcall	.-3194   	; 0xb06 <xPortStartScheduler>
    1780:	0f 91       	pop	r16
    1782:	ff 90       	pop	r15
    1784:	ef 90       	pop	r14
    1786:	df 90       	pop	r13
    1788:	cf 90       	pop	r12
    178a:	bf 90       	pop	r11
    178c:	af 90       	pop	r10
    178e:	08 95       	ret

00001790 <vTaskSuspendAll>:
    1790:	80 91 7b 3c 	lds	r24, 0x3C7B
    1794:	8f 5f       	subi	r24, 0xFF	; 255
    1796:	80 93 7b 3c 	sts	0x3C7B, r24
    179a:	08 95       	ret

0000179c <xTaskGetTickCount>:
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
    17a2:	80 91 7f 3c 	lds	r24, 0x3C7F
    17a6:	90 91 80 3c 	lds	r25, 0x3C80
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
    17ae:	08 95       	ret

000017b0 <uxTaskGetNumberOfTasks>:
    17b0:	80 91 81 3c 	lds	r24, 0x3C81
    17b4:	08 95       	ret

000017b6 <vTaskIncrementTick>:
    17b6:	0f 93       	push	r16
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	80 91 7b 3c 	lds	r24, 0x3C7B
    17c2:	81 11       	cpse	r24, r1
    17c4:	af c0       	rjmp	.+350    	; 0x1924 <vTaskIncrementTick+0x16e>
    17c6:	80 91 7f 3c 	lds	r24, 0x3C7F
    17ca:	90 91 80 3c 	lds	r25, 0x3C80
    17ce:	01 96       	adiw	r24, 0x01	; 1
    17d0:	80 93 7f 3c 	sts	0x3C7F, r24
    17d4:	90 93 80 3c 	sts	0x3C80, r25
    17d8:	80 91 7f 3c 	lds	r24, 0x3C7F
    17dc:	90 91 80 3c 	lds	r25, 0x3C80
    17e0:	89 2b       	or	r24, r25
    17e2:	99 f5       	brne	.+102    	; 0x184a <vTaskIncrementTick+0x94>
    17e4:	80 91 96 3c 	lds	r24, 0x3C96
    17e8:	90 91 97 3c 	lds	r25, 0x3C97
    17ec:	20 91 94 3c 	lds	r18, 0x3C94
    17f0:	30 91 95 3c 	lds	r19, 0x3C95
    17f4:	20 93 96 3c 	sts	0x3C96, r18
    17f8:	30 93 97 3c 	sts	0x3C97, r19
    17fc:	80 93 94 3c 	sts	0x3C94, r24
    1800:	90 93 95 3c 	sts	0x3C95, r25
    1804:	80 91 78 3c 	lds	r24, 0x3C78
    1808:	8f 5f       	subi	r24, 0xFF	; 255
    180a:	80 93 78 3c 	sts	0x3C78, r24
    180e:	e0 91 96 3c 	lds	r30, 0x3C96
    1812:	f0 91 97 3c 	lds	r31, 0x3C97
    1816:	80 81       	ld	r24, Z
    1818:	81 11       	cpse	r24, r1
    181a:	07 c0       	rjmp	.+14     	; 0x182a <vTaskIncrementTick+0x74>
    181c:	8f ef       	ldi	r24, 0xFF	; 255
    181e:	9f ef       	ldi	r25, 0xFF	; 255
    1820:	80 93 05 20 	sts	0x2005, r24
    1824:	90 93 06 20 	sts	0x2006, r25
    1828:	10 c0       	rjmp	.+32     	; 0x184a <vTaskIncrementTick+0x94>
    182a:	e0 91 96 3c 	lds	r30, 0x3C96
    182e:	f0 91 97 3c 	lds	r31, 0x3C97
    1832:	05 80       	ldd	r0, Z+5	; 0x05
    1834:	f6 81       	ldd	r31, Z+6	; 0x06
    1836:	e0 2d       	mov	r30, r0
    1838:	06 80       	ldd	r0, Z+6	; 0x06
    183a:	f7 81       	ldd	r31, Z+7	; 0x07
    183c:	e0 2d       	mov	r30, r0
    183e:	82 81       	ldd	r24, Z+2	; 0x02
    1840:	93 81       	ldd	r25, Z+3	; 0x03
    1842:	80 93 05 20 	sts	0x2005, r24
    1846:	90 93 06 20 	sts	0x2006, r25
    184a:	20 91 7f 3c 	lds	r18, 0x3C7F
    184e:	30 91 80 3c 	lds	r19, 0x3C80
    1852:	80 91 05 20 	lds	r24, 0x2005
    1856:	90 91 06 20 	lds	r25, 0x2006
    185a:	28 17       	cp	r18, r24
    185c:	39 07       	cpc	r19, r25
    185e:	08 f4       	brcc	.+2      	; 0x1862 <vTaskIncrementTick+0xac>
    1860:	66 c0       	rjmp	.+204    	; 0x192e <vTaskIncrementTick+0x178>
    1862:	e0 91 96 3c 	lds	r30, 0x3C96
    1866:	f0 91 97 3c 	lds	r31, 0x3C97
    186a:	80 81       	ld	r24, Z
    186c:	88 23       	and	r24, r24
    186e:	99 f0       	breq	.+38     	; 0x1896 <vTaskIncrementTick+0xe0>
    1870:	e0 91 96 3c 	lds	r30, 0x3C96
    1874:	f0 91 97 3c 	lds	r31, 0x3C97
    1878:	05 80       	ldd	r0, Z+5	; 0x05
    187a:	f6 81       	ldd	r31, Z+6	; 0x06
    187c:	e0 2d       	mov	r30, r0
    187e:	c6 81       	ldd	r28, Z+6	; 0x06
    1880:	d7 81       	ldd	r29, Z+7	; 0x07
    1882:	8a 81       	ldd	r24, Y+2	; 0x02
    1884:	9b 81       	ldd	r25, Y+3	; 0x03
    1886:	20 91 7f 3c 	lds	r18, 0x3C7F
    188a:	30 91 80 3c 	lds	r19, 0x3C80
    188e:	28 17       	cp	r18, r24
    1890:	39 07       	cpc	r19, r25
    1892:	f8 f4       	brcc	.+62     	; 0x18d2 <vTaskIncrementTick+0x11c>
    1894:	19 c0       	rjmp	.+50     	; 0x18c8 <vTaskIncrementTick+0x112>
    1896:	8f ef       	ldi	r24, 0xFF	; 255
    1898:	9f ef       	ldi	r25, 0xFF	; 255
    189a:	80 93 05 20 	sts	0x2005, r24
    189e:	90 93 06 20 	sts	0x2006, r25
    18a2:	45 c0       	rjmp	.+138    	; 0x192e <vTaskIncrementTick+0x178>
    18a4:	e0 91 96 3c 	lds	r30, 0x3C96
    18a8:	f0 91 97 3c 	lds	r31, 0x3C97
    18ac:	05 80       	ldd	r0, Z+5	; 0x05
    18ae:	f6 81       	ldd	r31, Z+6	; 0x06
    18b0:	e0 2d       	mov	r30, r0
    18b2:	c6 81       	ldd	r28, Z+6	; 0x06
    18b4:	d7 81       	ldd	r29, Z+7	; 0x07
    18b6:	8a 81       	ldd	r24, Y+2	; 0x02
    18b8:	9b 81       	ldd	r25, Y+3	; 0x03
    18ba:	20 91 7f 3c 	lds	r18, 0x3C7F
    18be:	30 91 80 3c 	lds	r19, 0x3C80
    18c2:	28 17       	cp	r18, r24
    18c4:	39 07       	cpc	r19, r25
    18c6:	28 f4       	brcc	.+10     	; 0x18d2 <vTaskIncrementTick+0x11c>
    18c8:	80 93 05 20 	sts	0x2005, r24
    18cc:	90 93 06 20 	sts	0x2006, r25
    18d0:	2e c0       	rjmp	.+92     	; 0x192e <vTaskIncrementTick+0x178>
    18d2:	8e 01       	movw	r16, r28
    18d4:	0e 5f       	subi	r16, 0xFE	; 254
    18d6:	1f 4f       	sbci	r17, 0xFF	; 255
    18d8:	c8 01       	movw	r24, r16
    18da:	7c da       	rcall	.-2824   	; 0xdd4 <vListRemove>
    18dc:	8c 89       	ldd	r24, Y+20	; 0x14
    18de:	9d 89       	ldd	r25, Y+21	; 0x15
    18e0:	89 2b       	or	r24, r25
    18e2:	19 f0       	breq	.+6      	; 0x18ea <vTaskIncrementTick+0x134>
    18e4:	ce 01       	movw	r24, r28
    18e6:	0c 96       	adiw	r24, 0x0c	; 12
    18e8:	75 da       	rcall	.-2838   	; 0xdd4 <vListRemove>
    18ea:	8e 89       	ldd	r24, Y+22	; 0x16
    18ec:	90 91 7d 3c 	lds	r25, 0x3C7D
    18f0:	98 17       	cp	r25, r24
    18f2:	10 f4       	brcc	.+4      	; 0x18f8 <vTaskIncrementTick+0x142>
    18f4:	80 93 7d 3c 	sts	0x3C7D, r24
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	9c 01       	movw	r18, r24
    18fc:	22 0f       	add	r18, r18
    18fe:	33 1f       	adc	r19, r19
    1900:	22 0f       	add	r18, r18
    1902:	33 1f       	adc	r19, r19
    1904:	22 0f       	add	r18, r18
    1906:	33 1f       	adc	r19, r19
    1908:	82 0f       	add	r24, r18
    190a:	93 1f       	adc	r25, r19
    190c:	b8 01       	movw	r22, r16
    190e:	86 55       	subi	r24, 0x56	; 86
    1910:	93 4c       	sbci	r25, 0xC3	; 195
    1912:	fe d9       	rcall	.-3076   	; 0xd10 <vListInsertEnd>
    1914:	e0 91 96 3c 	lds	r30, 0x3C96
    1918:	f0 91 97 3c 	lds	r31, 0x3C97
    191c:	80 81       	ld	r24, Z
    191e:	81 11       	cpse	r24, r1
    1920:	c1 cf       	rjmp	.-126    	; 0x18a4 <vTaskIncrementTick+0xee>
    1922:	b9 cf       	rjmp	.-142    	; 0x1896 <vTaskIncrementTick+0xe0>
    1924:	80 91 7a 3c 	lds	r24, 0x3C7A
    1928:	8f 5f       	subi	r24, 0xFF	; 255
    192a:	80 93 7a 3c 	sts	0x3C7A, r24
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	1f 91       	pop	r17
    1934:	0f 91       	pop	r16
    1936:	08 95       	ret

00001938 <xTaskResumeAll>:
    1938:	bf 92       	push	r11
    193a:	cf 92       	push	r12
    193c:	df 92       	push	r13
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	0f b6       	in	r0, 0x3f	; 63
    194c:	f8 94       	cli
    194e:	0f 92       	push	r0
    1950:	80 91 7b 3c 	lds	r24, 0x3C7B
    1954:	81 50       	subi	r24, 0x01	; 1
    1956:	80 93 7b 3c 	sts	0x3C7B, r24
    195a:	80 91 7b 3c 	lds	r24, 0x3C7B
    195e:	81 11       	cpse	r24, r1
    1960:	62 c0       	rjmp	.+196    	; 0x1a26 <xTaskResumeAll+0xee>
    1962:	80 91 81 3c 	lds	r24, 0x3C81
    1966:	88 23       	and	r24, r24
    1968:	09 f4       	brne	.+2      	; 0x196c <xTaskResumeAll+0x34>
    196a:	5f c0       	rjmp	.+190    	; 0x1a2a <xTaskResumeAll+0xf2>
    196c:	b1 2c       	mov	r11, r1
    196e:	0f 2e       	mov	r0, r31
    1970:	fb e8       	ldi	r31, 0x8B	; 139
    1972:	ef 2e       	mov	r14, r31
    1974:	fc e3       	ldi	r31, 0x3C	; 60
    1976:	ff 2e       	mov	r15, r31
    1978:	f0 2d       	mov	r31, r0
    197a:	0f 2e       	mov	r0, r31
    197c:	f0 e9       	ldi	r31, 0x90	; 144
    197e:	cf 2e       	mov	r12, r31
    1980:	fc e3       	ldi	r31, 0x3C	; 60
    1982:	df 2e       	mov	r13, r31
    1984:	f0 2d       	mov	r31, r0
    1986:	2c c0       	rjmp	.+88     	; 0x19e0 <xTaskResumeAll+0xa8>
    1988:	d6 01       	movw	r26, r12
    198a:	ed 91       	ld	r30, X+
    198c:	fc 91       	ld	r31, X
    198e:	c6 81       	ldd	r28, Z+6	; 0x06
    1990:	d7 81       	ldd	r29, Z+7	; 0x07
    1992:	ce 01       	movw	r24, r28
    1994:	0c 96       	adiw	r24, 0x0c	; 12
    1996:	1e da       	rcall	.-3012   	; 0xdd4 <vListRemove>
    1998:	8e 01       	movw	r16, r28
    199a:	0e 5f       	subi	r16, 0xFE	; 254
    199c:	1f 4f       	sbci	r17, 0xFF	; 255
    199e:	c8 01       	movw	r24, r16
    19a0:	19 da       	rcall	.-3022   	; 0xdd4 <vListRemove>
    19a2:	8e 89       	ldd	r24, Y+22	; 0x16
    19a4:	90 91 7d 3c 	lds	r25, 0x3C7D
    19a8:	98 17       	cp	r25, r24
    19aa:	10 f4       	brcc	.+4      	; 0x19b0 <xTaskResumeAll+0x78>
    19ac:	80 93 7d 3c 	sts	0x3C7D, r24
    19b0:	90 e0       	ldi	r25, 0x00	; 0
    19b2:	9c 01       	movw	r18, r24
    19b4:	22 0f       	add	r18, r18
    19b6:	33 1f       	adc	r19, r19
    19b8:	22 0f       	add	r18, r18
    19ba:	33 1f       	adc	r19, r19
    19bc:	22 0f       	add	r18, r18
    19be:	33 1f       	adc	r19, r19
    19c0:	82 0f       	add	r24, r18
    19c2:	93 1f       	adc	r25, r19
    19c4:	b8 01       	movw	r22, r16
    19c6:	86 55       	subi	r24, 0x56	; 86
    19c8:	93 4c       	sbci	r25, 0xC3	; 195
    19ca:	a2 d9       	rcall	.-3260   	; 0xd10 <vListInsertEnd>
    19cc:	e0 91 b3 3c 	lds	r30, 0x3CB3
    19d0:	f0 91 b4 3c 	lds	r31, 0x3CB4
    19d4:	9e 89       	ldd	r25, Y+22	; 0x16
    19d6:	86 89       	ldd	r24, Z+22	; 0x16
    19d8:	98 17       	cp	r25, r24
    19da:	10 f0       	brcs	.+4      	; 0x19e0 <xTaskResumeAll+0xa8>
    19dc:	bb 24       	eor	r11, r11
    19de:	b3 94       	inc	r11
    19e0:	f7 01       	movw	r30, r14
    19e2:	80 81       	ld	r24, Z
    19e4:	81 11       	cpse	r24, r1
    19e6:	d0 cf       	rjmp	.-96     	; 0x1988 <xTaskResumeAll+0x50>
    19e8:	80 91 7a 3c 	lds	r24, 0x3C7A
    19ec:	88 23       	and	r24, r24
    19ee:	79 f0       	breq	.+30     	; 0x1a0e <xTaskResumeAll+0xd6>
    19f0:	80 91 7a 3c 	lds	r24, 0x3C7A
    19f4:	88 23       	and	r24, r24
    19f6:	91 f0       	breq	.+36     	; 0x1a1c <xTaskResumeAll+0xe4>
    19f8:	de de       	rcall	.-580    	; 0x17b6 <vTaskIncrementTick>
    19fa:	80 91 7a 3c 	lds	r24, 0x3C7A
    19fe:	81 50       	subi	r24, 0x01	; 1
    1a00:	80 93 7a 3c 	sts	0x3C7A, r24
    1a04:	80 91 7a 3c 	lds	r24, 0x3C7A
    1a08:	81 11       	cpse	r24, r1
    1a0a:	f6 cf       	rjmp	.-20     	; 0x19f8 <xTaskResumeAll+0xc0>
    1a0c:	07 c0       	rjmp	.+14     	; 0x1a1c <xTaskResumeAll+0xe4>
    1a0e:	f1 e0       	ldi	r31, 0x01	; 1
    1a10:	bf 16       	cp	r11, r31
    1a12:	21 f0       	breq	.+8      	; 0x1a1c <xTaskResumeAll+0xe4>
    1a14:	80 91 79 3c 	lds	r24, 0x3C79
    1a18:	81 30       	cpi	r24, 0x01	; 1
    1a1a:	49 f4       	brne	.+18     	; 0x1a2e <xTaskResumeAll+0xf6>
    1a1c:	10 92 79 3c 	sts	0x3C79, r1
    1a20:	b4 d8       	rcall	.-3736   	; 0xb8a <vPortYield>
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	05 c0       	rjmp	.+10     	; 0x1a30 <xTaskResumeAll+0xf8>
    1a26:	80 e0       	ldi	r24, 0x00	; 0
    1a28:	03 c0       	rjmp	.+6      	; 0x1a30 <xTaskResumeAll+0xf8>
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	01 c0       	rjmp	.+2      	; 0x1a30 <xTaskResumeAll+0xf8>
    1a2e:	80 e0       	ldi	r24, 0x00	; 0
    1a30:	0f 90       	pop	r0
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	df 91       	pop	r29
    1a36:	cf 91       	pop	r28
    1a38:	1f 91       	pop	r17
    1a3a:	0f 91       	pop	r16
    1a3c:	ff 90       	pop	r15
    1a3e:	ef 90       	pop	r14
    1a40:	df 90       	pop	r13
    1a42:	cf 90       	pop	r12
    1a44:	bf 90       	pop	r11
    1a46:	08 95       	ret

00001a48 <vTaskDelay>:
    1a48:	cf 93       	push	r28
    1a4a:	df 93       	push	r29
    1a4c:	ec 01       	movw	r28, r24
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	91 f0       	breq	.+36     	; 0x1a76 <vTaskDelay+0x2e>
    1a52:	9e de       	rcall	.-708    	; 0x1790 <vTaskSuspendAll>
    1a54:	80 91 7f 3c 	lds	r24, 0x3C7F
    1a58:	90 91 80 3c 	lds	r25, 0x3C80
    1a5c:	c8 0f       	add	r28, r24
    1a5e:	d9 1f       	adc	r29, r25
    1a60:	80 91 b3 3c 	lds	r24, 0x3CB3
    1a64:	90 91 b4 3c 	lds	r25, 0x3CB4
    1a68:	02 96       	adiw	r24, 0x02	; 2
    1a6a:	b4 d9       	rcall	.-3224   	; 0xdd4 <vListRemove>
    1a6c:	ce 01       	movw	r24, r28
    1a6e:	ab dc       	rcall	.-1706   	; 0x13c6 <prvAddCurrentTaskToDelayedList>
    1a70:	63 df       	rcall	.-314    	; 0x1938 <xTaskResumeAll>
    1a72:	81 11       	cpse	r24, r1
    1a74:	01 c0       	rjmp	.+2      	; 0x1a78 <vTaskDelay+0x30>
    1a76:	89 d8       	rcall	.-3822   	; 0xb8a <vPortYield>
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	08 95       	ret

00001a7e <vTaskList>:
    1a7e:	1f 93       	push	r17
    1a80:	cf 93       	push	r28
    1a82:	df 93       	push	r29
    1a84:	ec 01       	movw	r28, r24
    1a86:	84 de       	rcall	.-760    	; 0x1790 <vTaskSuspendAll>
    1a88:	18 82       	st	Y, r1
    1a8a:	fe 01       	movw	r30, r28
    1a8c:	01 90       	ld	r0, Z+
    1a8e:	00 20       	and	r0, r0
    1a90:	e9 f7       	brne	.-6      	; 0x1a8c <vTaskList+0xe>
    1a92:	31 97       	sbiw	r30, 0x01	; 1
    1a94:	2d e0       	ldi	r18, 0x0D	; 13
    1a96:	3a e0       	ldi	r19, 0x0A	; 10
    1a98:	40 e0       	ldi	r20, 0x00	; 0
    1a9a:	20 83       	st	Z, r18
    1a9c:	31 83       	std	Z+1, r19	; 0x01
    1a9e:	42 83       	std	Z+2, r20	; 0x02
    1aa0:	10 91 7e 3c 	lds	r17, 0x3C7E
    1aa4:	1f 5f       	subi	r17, 0xFF	; 255
    1aa6:	11 50       	subi	r17, 0x01	; 1
    1aa8:	21 2f       	mov	r18, r17
    1aaa:	30 e0       	ldi	r19, 0x00	; 0
    1aac:	f9 01       	movw	r30, r18
    1aae:	ee 0f       	add	r30, r30
    1ab0:	ff 1f       	adc	r31, r31
    1ab2:	ee 0f       	add	r30, r30
    1ab4:	ff 1f       	adc	r31, r31
    1ab6:	ee 0f       	add	r30, r30
    1ab8:	ff 1f       	adc	r31, r31
    1aba:	e2 0f       	add	r30, r18
    1abc:	f3 1f       	adc	r31, r19
    1abe:	e6 55       	subi	r30, 0x56	; 86
    1ac0:	f3 4c       	sbci	r31, 0xC3	; 195
    1ac2:	80 81       	ld	r24, Z
    1ac4:	88 23       	and	r24, r24
    1ac6:	21 f0       	breq	.+8      	; 0x1ad0 <vTaskList+0x52>
    1ac8:	bf 01       	movw	r22, r30
    1aca:	42 e5       	ldi	r20, 0x52	; 82
    1acc:	ce 01       	movw	r24, r28
    1ace:	b0 dc       	rcall	.-1696   	; 0x1430 <prvListTaskWithinSingleList>
    1ad0:	11 11       	cpse	r17, r1
    1ad2:	e9 cf       	rjmp	.-46     	; 0x1aa6 <vTaskList+0x28>
    1ad4:	e0 91 96 3c 	lds	r30, 0x3C96
    1ad8:	f0 91 97 3c 	lds	r31, 0x3C97
    1adc:	80 81       	ld	r24, Z
    1ade:	88 23       	and	r24, r24
    1ae0:	39 f0       	breq	.+14     	; 0x1af0 <vTaskList+0x72>
    1ae2:	60 91 96 3c 	lds	r22, 0x3C96
    1ae6:	70 91 97 3c 	lds	r23, 0x3C97
    1aea:	42 e4       	ldi	r20, 0x42	; 66
    1aec:	ce 01       	movw	r24, r28
    1aee:	a0 dc       	rcall	.-1728   	; 0x1430 <prvListTaskWithinSingleList>
    1af0:	e0 91 94 3c 	lds	r30, 0x3C94
    1af4:	f0 91 95 3c 	lds	r31, 0x3C95
    1af8:	80 81       	ld	r24, Z
    1afa:	88 23       	and	r24, r24
    1afc:	39 f0       	breq	.+14     	; 0x1b0c <vTaskList+0x8e>
    1afe:	60 91 94 3c 	lds	r22, 0x3C94
    1b02:	70 91 95 3c 	lds	r23, 0x3C95
    1b06:	42 e4       	ldi	r20, 0x42	; 66
    1b08:	ce 01       	movw	r24, r28
    1b0a:	92 dc       	rcall	.-1756   	; 0x1430 <prvListTaskWithinSingleList>
    1b0c:	80 91 82 3c 	lds	r24, 0x3C82
    1b10:	88 23       	and	r24, r24
    1b12:	29 f0       	breq	.+10     	; 0x1b1e <vTaskList+0xa0>
    1b14:	43 e5       	ldi	r20, 0x53	; 83
    1b16:	62 e8       	ldi	r22, 0x82	; 130
    1b18:	7c e3       	ldi	r23, 0x3C	; 60
    1b1a:	ce 01       	movw	r24, r28
    1b1c:	89 dc       	rcall	.-1774   	; 0x1430 <prvListTaskWithinSingleList>
    1b1e:	0c df       	rcall	.-488    	; 0x1938 <xTaskResumeAll>
    1b20:	df 91       	pop	r29
    1b22:	cf 91       	pop	r28
    1b24:	1f 91       	pop	r17
    1b26:	08 95       	ret

00001b28 <vTaskSwitchContext>:
    1b28:	80 91 7b 3c 	lds	r24, 0x3C7B
    1b2c:	81 11       	cpse	r24, r1
    1b2e:	13 c0       	rjmp	.+38     	; 0x1b56 <vTaskSwitchContext+0x2e>
    1b30:	80 91 7d 3c 	lds	r24, 0x3C7D
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	fc 01       	movw	r30, r24
    1b38:	ee 0f       	add	r30, r30
    1b3a:	ff 1f       	adc	r31, r31
    1b3c:	ee 0f       	add	r30, r30
    1b3e:	ff 1f       	adc	r31, r31
    1b40:	ee 0f       	add	r30, r30
    1b42:	ff 1f       	adc	r31, r31
    1b44:	8e 0f       	add	r24, r30
    1b46:	9f 1f       	adc	r25, r31
    1b48:	fc 01       	movw	r30, r24
    1b4a:	e6 55       	subi	r30, 0x56	; 86
    1b4c:	f3 4c       	sbci	r31, 0xC3	; 195
    1b4e:	80 81       	ld	r24, Z
    1b50:	88 23       	and	r24, r24
    1b52:	29 f0       	breq	.+10     	; 0x1b5e <vTaskSwitchContext+0x36>
    1b54:	1b c0       	rjmp	.+54     	; 0x1b8c <vTaskSwitchContext+0x64>
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	80 93 79 3c 	sts	0x3C79, r24
    1b5c:	08 95       	ret
    1b5e:	80 91 7d 3c 	lds	r24, 0x3C7D
    1b62:	81 50       	subi	r24, 0x01	; 1
    1b64:	80 93 7d 3c 	sts	0x3C7D, r24
    1b68:	80 91 7d 3c 	lds	r24, 0x3C7D
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	fc 01       	movw	r30, r24
    1b70:	ee 0f       	add	r30, r30
    1b72:	ff 1f       	adc	r31, r31
    1b74:	ee 0f       	add	r30, r30
    1b76:	ff 1f       	adc	r31, r31
    1b78:	ee 0f       	add	r30, r30
    1b7a:	ff 1f       	adc	r31, r31
    1b7c:	8e 0f       	add	r24, r30
    1b7e:	9f 1f       	adc	r25, r31
    1b80:	fc 01       	movw	r30, r24
    1b82:	e6 55       	subi	r30, 0x56	; 86
    1b84:	f3 4c       	sbci	r31, 0xC3	; 195
    1b86:	80 81       	ld	r24, Z
    1b88:	88 23       	and	r24, r24
    1b8a:	49 f3       	breq	.-46     	; 0x1b5e <vTaskSwitchContext+0x36>
    1b8c:	e0 91 7d 3c 	lds	r30, 0x3C7D
    1b90:	f0 e0       	ldi	r31, 0x00	; 0
    1b92:	cf 01       	movw	r24, r30
    1b94:	88 0f       	add	r24, r24
    1b96:	99 1f       	adc	r25, r25
    1b98:	88 0f       	add	r24, r24
    1b9a:	99 1f       	adc	r25, r25
    1b9c:	88 0f       	add	r24, r24
    1b9e:	99 1f       	adc	r25, r25
    1ba0:	e8 0f       	add	r30, r24
    1ba2:	f9 1f       	adc	r31, r25
    1ba4:	e6 55       	subi	r30, 0x56	; 86
    1ba6:	f3 4c       	sbci	r31, 0xC3	; 195
    1ba8:	a1 81       	ldd	r26, Z+1	; 0x01
    1baa:	b2 81       	ldd	r27, Z+2	; 0x02
    1bac:	12 96       	adiw	r26, 0x02	; 2
    1bae:	0d 90       	ld	r0, X+
    1bb0:	bc 91       	ld	r27, X
    1bb2:	a0 2d       	mov	r26, r0
    1bb4:	a1 83       	std	Z+1, r26	; 0x01
    1bb6:	b2 83       	std	Z+2, r27	; 0x02
    1bb8:	cf 01       	movw	r24, r30
    1bba:	03 96       	adiw	r24, 0x03	; 3
    1bbc:	a8 17       	cp	r26, r24
    1bbe:	b9 07       	cpc	r27, r25
    1bc0:	31 f4       	brne	.+12     	; 0x1bce <vTaskSwitchContext+0xa6>
    1bc2:	12 96       	adiw	r26, 0x02	; 2
    1bc4:	8d 91       	ld	r24, X+
    1bc6:	9c 91       	ld	r25, X
    1bc8:	13 97       	sbiw	r26, 0x03	; 3
    1bca:	81 83       	std	Z+1, r24	; 0x01
    1bcc:	92 83       	std	Z+2, r25	; 0x02
    1bce:	01 80       	ldd	r0, Z+1	; 0x01
    1bd0:	f2 81       	ldd	r31, Z+2	; 0x02
    1bd2:	e0 2d       	mov	r30, r0
    1bd4:	86 81       	ldd	r24, Z+6	; 0x06
    1bd6:	97 81       	ldd	r25, Z+7	; 0x07
    1bd8:	80 93 b3 3c 	sts	0x3CB3, r24
    1bdc:	90 93 b4 3c 	sts	0x3CB4, r25
    1be0:	80 91 72 3c 	lds	r24, 0x3C72
    1be4:	88 23       	and	r24, r24
    1be6:	09 f4       	brne	.+2      	; 0x1bea <vTaskSwitchContext+0xc2>
    1be8:	4c c0       	rjmp	.+152    	; 0x1c82 <vTaskSwitchContext+0x15a>
    1bea:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1bee:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1bf2:	91 a1       	ldd	r25, Z+33	; 0x21
    1bf4:	80 91 04 20 	lds	r24, 0x2004
    1bf8:	98 17       	cp	r25, r24
    1bfa:	09 f4       	brne	.+2      	; 0x1bfe <vTaskSwitchContext+0xd6>
    1bfc:	42 c0       	rjmp	.+132    	; 0x1c82 <vTaskSwitchContext+0x15a>
    1bfe:	80 91 75 3c 	lds	r24, 0x3C75
    1c02:	90 91 76 3c 	lds	r25, 0x3C76
    1c06:	08 96       	adiw	r24, 0x08	; 8
    1c08:	20 91 73 3c 	lds	r18, 0x3C73
    1c0c:	30 91 74 3c 	lds	r19, 0x3C74
    1c10:	82 17       	cp	r24, r18
    1c12:	93 07       	cpc	r25, r19
    1c14:	a0 f5       	brcc	.+104    	; 0x1c7e <vTaskSwitchContext+0x156>
    1c16:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1c1a:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1c1e:	81 a1       	ldd	r24, Z+33	; 0x21
    1c20:	80 93 04 20 	sts	0x2004, r24
    1c24:	e0 91 75 3c 	lds	r30, 0x3C75
    1c28:	f0 91 76 3c 	lds	r31, 0x3C76
    1c2c:	40 91 7f 3c 	lds	r20, 0x3C7F
    1c30:	50 91 80 3c 	lds	r21, 0x3C80
    1c34:	60 e0       	ldi	r22, 0x00	; 0
    1c36:	70 e0       	ldi	r23, 0x00	; 0
    1c38:	40 83       	st	Z, r20
    1c3a:	51 83       	std	Z+1, r21	; 0x01
    1c3c:	62 83       	std	Z+2, r22	; 0x02
    1c3e:	73 83       	std	Z+3, r23	; 0x03
    1c40:	20 91 75 3c 	lds	r18, 0x3C75
    1c44:	30 91 76 3c 	lds	r19, 0x3C76
    1c48:	2c 5f       	subi	r18, 0xFC	; 252
    1c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c4c:	20 93 75 3c 	sts	0x3C75, r18
    1c50:	30 93 76 3c 	sts	0x3C76, r19
    1c54:	e0 91 75 3c 	lds	r30, 0x3C75
    1c58:	f0 91 76 3c 	lds	r31, 0x3C76
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	a0 e0       	ldi	r26, 0x00	; 0
    1c60:	b0 e0       	ldi	r27, 0x00	; 0
    1c62:	80 83       	st	Z, r24
    1c64:	91 83       	std	Z+1, r25	; 0x01
    1c66:	a2 83       	std	Z+2, r26	; 0x02
    1c68:	b3 83       	std	Z+3, r27	; 0x03
    1c6a:	80 91 75 3c 	lds	r24, 0x3C75
    1c6e:	90 91 76 3c 	lds	r25, 0x3C76
    1c72:	04 96       	adiw	r24, 0x04	; 4
    1c74:	80 93 75 3c 	sts	0x3C75, r24
    1c78:	90 93 76 3c 	sts	0x3C76, r25
    1c7c:	08 95       	ret
    1c7e:	10 92 72 3c 	sts	0x3C72, r1
    1c82:	08 95       	ret

00001c84 <vTaskPlaceOnEventList>:
    1c84:	cf 93       	push	r28
    1c86:	df 93       	push	r29
    1c88:	eb 01       	movw	r28, r22
    1c8a:	60 91 b3 3c 	lds	r22, 0x3CB3
    1c8e:	70 91 b4 3c 	lds	r23, 0x3CB4
    1c92:	64 5f       	subi	r22, 0xF4	; 244
    1c94:	7f 4f       	sbci	r23, 0xFF	; 255
    1c96:	63 d8       	rcall	.-3898   	; 0xd5e <vListInsert>
    1c98:	80 91 b3 3c 	lds	r24, 0x3CB3
    1c9c:	90 91 b4 3c 	lds	r25, 0x3CB4
    1ca0:	02 96       	adiw	r24, 0x02	; 2
    1ca2:	98 d8       	rcall	.-3792   	; 0xdd4 <vListRemove>
    1ca4:	cf 3f       	cpi	r28, 0xFF	; 255
    1ca6:	8f ef       	ldi	r24, 0xFF	; 255
    1ca8:	d8 07       	cpc	r29, r24
    1caa:	51 f4       	brne	.+20     	; 0x1cc0 <vTaskPlaceOnEventList+0x3c>
    1cac:	60 91 b3 3c 	lds	r22, 0x3CB3
    1cb0:	70 91 b4 3c 	lds	r23, 0x3CB4
    1cb4:	6e 5f       	subi	r22, 0xFE	; 254
    1cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb8:	82 e8       	ldi	r24, 0x82	; 130
    1cba:	9c e3       	ldi	r25, 0x3C	; 60
    1cbc:	29 d8       	rcall	.-4014   	; 0xd10 <vListInsertEnd>
    1cbe:	07 c0       	rjmp	.+14     	; 0x1cce <vTaskPlaceOnEventList+0x4a>
    1cc0:	80 91 7f 3c 	lds	r24, 0x3C7F
    1cc4:	90 91 80 3c 	lds	r25, 0x3C80
    1cc8:	8c 0f       	add	r24, r28
    1cca:	9d 1f       	adc	r25, r29
    1ccc:	7c db       	rcall	.-2312   	; 0x13c6 <prvAddCurrentTaskToDelayedList>
    1cce:	df 91       	pop	r29
    1cd0:	cf 91       	pop	r28
    1cd2:	08 95       	ret

00001cd4 <vTaskPlaceOnEventListRestricted>:
    1cd4:	cf 93       	push	r28
    1cd6:	df 93       	push	r29
    1cd8:	eb 01       	movw	r28, r22
    1cda:	60 91 b3 3c 	lds	r22, 0x3CB3
    1cde:	70 91 b4 3c 	lds	r23, 0x3CB4
    1ce2:	64 5f       	subi	r22, 0xF4	; 244
    1ce4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce6:	14 d8       	rcall	.-4056   	; 0xd10 <vListInsertEnd>
    1ce8:	80 91 b3 3c 	lds	r24, 0x3CB3
    1cec:	90 91 b4 3c 	lds	r25, 0x3CB4
    1cf0:	02 96       	adiw	r24, 0x02	; 2
    1cf2:	70 d8       	rcall	.-3872   	; 0xdd4 <vListRemove>
    1cf4:	80 91 7f 3c 	lds	r24, 0x3C7F
    1cf8:	90 91 80 3c 	lds	r25, 0x3C80
    1cfc:	8c 0f       	add	r24, r28
    1cfe:	9d 1f       	adc	r25, r29
    1d00:	62 db       	rcall	.-2364   	; 0x13c6 <prvAddCurrentTaskToDelayedList>
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	08 95       	ret

00001d08 <xTaskRemoveFromEventList>:
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	dc 01       	movw	r26, r24
    1d12:	15 96       	adiw	r26, 0x05	; 5
    1d14:	ed 91       	ld	r30, X+
    1d16:	fc 91       	ld	r31, X
    1d18:	16 97       	sbiw	r26, 0x06	; 6
    1d1a:	c6 81       	ldd	r28, Z+6	; 0x06
    1d1c:	d7 81       	ldd	r29, Z+7	; 0x07
    1d1e:	8e 01       	movw	r16, r28
    1d20:	04 5f       	subi	r16, 0xF4	; 244
    1d22:	1f 4f       	sbci	r17, 0xFF	; 255
    1d24:	c8 01       	movw	r24, r16
    1d26:	56 d8       	rcall	.-3924   	; 0xdd4 <vListRemove>
    1d28:	80 91 7b 3c 	lds	r24, 0x3C7B
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	1b c0       	rjmp	.+54     	; 0x1d66 <xTaskRemoveFromEventList+0x5e>
    1d30:	0a 50       	subi	r16, 0x0A	; 10
    1d32:	11 09       	sbc	r17, r1
    1d34:	c8 01       	movw	r24, r16
    1d36:	4e d8       	rcall	.-3940   	; 0xdd4 <vListRemove>
    1d38:	8e 89       	ldd	r24, Y+22	; 0x16
    1d3a:	90 91 7d 3c 	lds	r25, 0x3C7D
    1d3e:	98 17       	cp	r25, r24
    1d40:	10 f4       	brcc	.+4      	; 0x1d46 <xTaskRemoveFromEventList+0x3e>
    1d42:	80 93 7d 3c 	sts	0x3C7D, r24
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	9c 01       	movw	r18, r24
    1d4a:	22 0f       	add	r18, r18
    1d4c:	33 1f       	adc	r19, r19
    1d4e:	22 0f       	add	r18, r18
    1d50:	33 1f       	adc	r19, r19
    1d52:	22 0f       	add	r18, r18
    1d54:	33 1f       	adc	r19, r19
    1d56:	82 0f       	add	r24, r18
    1d58:	93 1f       	adc	r25, r19
    1d5a:	b8 01       	movw	r22, r16
    1d5c:	86 55       	subi	r24, 0x56	; 86
    1d5e:	93 4c       	sbci	r25, 0xC3	; 195
    1d60:	0e 94 88 06 	call	0xd10	; 0xd10 <vListInsertEnd>
    1d64:	05 c0       	rjmp	.+10     	; 0x1d70 <xTaskRemoveFromEventList+0x68>
    1d66:	b8 01       	movw	r22, r16
    1d68:	8b e8       	ldi	r24, 0x8B	; 139
    1d6a:	9c e3       	ldi	r25, 0x3C	; 60
    1d6c:	0e 94 88 06 	call	0xd10	; 0xd10 <vListInsertEnd>
    1d70:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1d74:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1d78:	81 e0       	ldi	r24, 0x01	; 1
    1d7a:	2e 89       	ldd	r18, Y+22	; 0x16
    1d7c:	96 89       	ldd	r25, Z+22	; 0x16
    1d7e:	29 17       	cp	r18, r25
    1d80:	08 f4       	brcc	.+2      	; 0x1d84 <xTaskRemoveFromEventList+0x7c>
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	1f 91       	pop	r17
    1d8a:	0f 91       	pop	r16
    1d8c:	08 95       	ret

00001d8e <vTaskSetTimeOutState>:
    1d8e:	20 91 78 3c 	lds	r18, 0x3C78
    1d92:	fc 01       	movw	r30, r24
    1d94:	20 83       	st	Z, r18
    1d96:	20 91 7f 3c 	lds	r18, 0x3C7F
    1d9a:	30 91 80 3c 	lds	r19, 0x3C80
    1d9e:	21 83       	std	Z+1, r18	; 0x01
    1da0:	32 83       	std	Z+2, r19	; 0x02
    1da2:	08 95       	ret

00001da4 <xTaskCheckForTimeOut>:
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	0f 92       	push	r0
    1daa:	db 01       	movw	r26, r22
    1dac:	2d 91       	ld	r18, X+
    1dae:	3c 91       	ld	r19, X
    1db0:	2f 3f       	cpi	r18, 0xFF	; 255
    1db2:	bf ef       	ldi	r27, 0xFF	; 255
    1db4:	3b 07       	cpc	r19, r27
    1db6:	61 f1       	breq	.+88     	; 0x1e10 <xTaskCheckForTimeOut+0x6c>
    1db8:	40 91 78 3c 	lds	r20, 0x3C78
    1dbc:	fc 01       	movw	r30, r24
    1dbe:	50 81       	ld	r21, Z
    1dc0:	54 17       	cp	r21, r20
    1dc2:	51 f0       	breq	.+20     	; 0x1dd8 <xTaskCheckForTimeOut+0x34>
    1dc4:	40 91 7f 3c 	lds	r20, 0x3C7F
    1dc8:	50 91 80 3c 	lds	r21, 0x3C80
    1dcc:	01 80       	ldd	r0, Z+1	; 0x01
    1dce:	f2 81       	ldd	r31, Z+2	; 0x02
    1dd0:	e0 2d       	mov	r30, r0
    1dd2:	4e 17       	cp	r20, r30
    1dd4:	5f 07       	cpc	r21, r31
    1dd6:	f0 f4       	brcc	.+60     	; 0x1e14 <xTaskCheckForTimeOut+0x70>
    1dd8:	e0 91 7f 3c 	lds	r30, 0x3C7F
    1ddc:	f0 91 80 3c 	lds	r31, 0x3C80
    1de0:	dc 01       	movw	r26, r24
    1de2:	11 96       	adiw	r26, 0x01	; 1
    1de4:	4d 91       	ld	r20, X+
    1de6:	5c 91       	ld	r21, X
    1de8:	12 97       	sbiw	r26, 0x02	; 2
    1dea:	e4 1b       	sub	r30, r20
    1dec:	f5 0b       	sbc	r31, r21
    1dee:	e2 17       	cp	r30, r18
    1df0:	f3 07       	cpc	r31, r19
    1df2:	90 f4       	brcc	.+36     	; 0x1e18 <xTaskCheckForTimeOut+0x74>
    1df4:	e0 91 7f 3c 	lds	r30, 0x3C7F
    1df8:	f0 91 80 3c 	lds	r31, 0x3C80
    1dfc:	4e 1b       	sub	r20, r30
    1dfe:	5f 0b       	sbc	r21, r31
    1e00:	24 0f       	add	r18, r20
    1e02:	35 1f       	adc	r19, r21
    1e04:	fb 01       	movw	r30, r22
    1e06:	20 83       	st	Z, r18
    1e08:	31 83       	std	Z+1, r19	; 0x01
    1e0a:	c1 df       	rcall	.-126    	; 0x1d8e <vTaskSetTimeOutState>
    1e0c:	80 e0       	ldi	r24, 0x00	; 0
    1e0e:	05 c0       	rjmp	.+10     	; 0x1e1a <xTaskCheckForTimeOut+0x76>
    1e10:	80 e0       	ldi	r24, 0x00	; 0
    1e12:	03 c0       	rjmp	.+6      	; 0x1e1a <xTaskCheckForTimeOut+0x76>
    1e14:	81 e0       	ldi	r24, 0x01	; 1
    1e16:	01 c0       	rjmp	.+2      	; 0x1e1a <xTaskCheckForTimeOut+0x76>
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	0f 90       	pop	r0
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	08 95       	ret

00001e20 <vTaskMissedYield>:
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	80 93 79 3c 	sts	0x3C79, r24
    1e26:	08 95       	ret

00001e28 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1e28:	80 91 b3 3c 	lds	r24, 0x3CB3
    1e2c:	90 91 b4 3c 	lds	r25, 0x3CB4

		return xReturn;
	}
    1e30:	08 95       	ret

00001e32 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e32:	80 91 7c 3c 	lds	r24, 0x3C7C
    1e36:	88 23       	and	r24, r24
    1e38:	31 f0       	breq	.+12     	; 0x1e46 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e3a:	80 91 7b 3c 	lds	r24, 0x3C7B
    1e3e:	81 11       	cpse	r24, r1
    1e40:	04 c0       	rjmp	.+8      	; 0x1e4a <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	08 95       	ret
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e46:	80 e0       	ldi	r24, 0x00	; 0
    1e48:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e4a:	82 e0       	ldi	r24, 0x02	; 2
			}
		}

		return xReturn;
	}
    1e4c:	08 95       	ret

00001e4e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1e4e:	0f 93       	push	r16
    1e50:	1f 93       	push	r17
    1e52:	cf 93       	push	r28
    1e54:	df 93       	push	r29
    1e56:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1e58:	8e 89       	ldd	r24, Y+22	; 0x16
    1e5a:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1e5e:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1e62:	96 89       	ldd	r25, Z+22	; 0x16
    1e64:	89 17       	cp	r24, r25
    1e66:	08 f0       	brcs	.+2      	; 0x1e6a <vTaskPriorityInherit+0x1c>
    1e68:	44 c0       	rjmp	.+136    	; 0x1ef2 <vTaskPriorityInherit+0xa4>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1e6a:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1e6e:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1e72:	96 89       	ldd	r25, Z+22	; 0x16
    1e74:	21 e0       	ldi	r18, 0x01	; 1
    1e76:	30 e0       	ldi	r19, 0x00	; 0
    1e78:	29 1b       	sub	r18, r25
    1e7a:	31 09       	sbc	r19, r1
    1e7c:	2c 87       	std	Y+12, r18	; 0x0c
    1e7e:	3d 87       	std	Y+13, r19	; 0x0d

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	9c 01       	movw	r18, r24
    1e84:	22 0f       	add	r18, r18
    1e86:	33 1f       	adc	r19, r19
    1e88:	22 0f       	add	r18, r18
    1e8a:	33 1f       	adc	r19, r19
    1e8c:	22 0f       	add	r18, r18
    1e8e:	33 1f       	adc	r19, r19
    1e90:	82 0f       	add	r24, r18
    1e92:	93 1f       	adc	r25, r19
    1e94:	86 55       	subi	r24, 0x56	; 86
    1e96:	93 4c       	sbci	r25, 0xC3	; 195
    1e98:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e9a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e9c:	28 17       	cp	r18, r24
    1e9e:	39 07       	cpc	r19, r25
    1ea0:	11 f5       	brne	.+68     	; 0x1ee6 <vTaskPriorityInherit+0x98>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    1ea2:	8e 01       	movw	r16, r28
    1ea4:	0e 5f       	subi	r16, 0xFE	; 254
    1ea6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ea8:	c8 01       	movw	r24, r16
    1eaa:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1eae:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1eb2:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1eb6:	86 89       	ldd	r24, Z+22	; 0x16
    1eb8:	8e 8b       	std	Y+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    1eba:	90 91 7d 3c 	lds	r25, 0x3C7D
    1ebe:	98 17       	cp	r25, r24
    1ec0:	10 f4       	brcc	.+4      	; 0x1ec6 <vTaskPriorityInherit+0x78>
    1ec2:	80 93 7d 3c 	sts	0x3C7D, r24
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	9c 01       	movw	r18, r24
    1eca:	22 0f       	add	r18, r18
    1ecc:	33 1f       	adc	r19, r19
    1ece:	22 0f       	add	r18, r18
    1ed0:	33 1f       	adc	r19, r19
    1ed2:	22 0f       	add	r18, r18
    1ed4:	33 1f       	adc	r19, r19
    1ed6:	82 0f       	add	r24, r18
    1ed8:	93 1f       	adc	r25, r19
    1eda:	b8 01       	movw	r22, r16
    1edc:	86 55       	subi	r24, 0x56	; 86
    1ede:	93 4c       	sbci	r25, 0xC3	; 195
    1ee0:	0e 94 88 06 	call	0xd10	; 0xd10 <vListInsertEnd>
    1ee4:	06 c0       	rjmp	.+12     	; 0x1ef2 <vTaskPriorityInherit+0xa4>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1ee6:	e0 91 b3 3c 	lds	r30, 0x3CB3
    1eea:	f0 91 b4 3c 	lds	r31, 0x3CB4
    1eee:	86 89       	ldd	r24, Z+22	; 0x16
    1ef0:	8e 8b       	std	Y+22, r24	; 0x16
			}
		}
	}
    1ef2:	df 91       	pop	r29
    1ef4:	cf 91       	pop	r28
    1ef6:	1f 91       	pop	r17
    1ef8:	0f 91       	pop	r16
    1efa:	08 95       	ret

00001efc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1efc:	0f 93       	push	r16
    1efe:	1f 93       	push	r17
    1f00:	cf 93       	push	r28
    1f02:	df 93       	push	r29
    1f04:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1f06:	00 97       	sbiw	r24, 0x00	; 0
    1f08:	39 f1       	breq	.+78     	; 0x1f58 <vTaskPriorityDisinherit+0x5c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1f0a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f0c:	8a a1       	ldd	r24, Y+34	; 0x22
    1f0e:	98 17       	cp	r25, r24
    1f10:	19 f1       	breq	.+70     	; 0x1f58 <vTaskPriorityDisinherit+0x5c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    1f12:	8e 01       	movw	r16, r28
    1f14:	0e 5f       	subi	r16, 0xFE	; 254
    1f16:	1f 4f       	sbci	r17, 0xFF	; 255
    1f18:	c8 01       	movw	r24, r16
    1f1a:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f1e:	8a a1       	ldd	r24, Y+34	; 0x22
    1f20:	8e 8b       	std	Y+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1f22:	21 e0       	ldi	r18, 0x01	; 1
    1f24:	30 e0       	ldi	r19, 0x00	; 0
    1f26:	28 1b       	sub	r18, r24
    1f28:	31 09       	sbc	r19, r1
    1f2a:	2c 87       	std	Y+12, r18	; 0x0c
    1f2c:	3d 87       	std	Y+13, r19	; 0x0d
				prvAddTaskToReadyQueue( pxTCB );
    1f2e:	90 91 7d 3c 	lds	r25, 0x3C7D
    1f32:	98 17       	cp	r25, r24
    1f34:	10 f4       	brcc	.+4      	; 0x1f3a <vTaskPriorityDisinherit+0x3e>
    1f36:	80 93 7d 3c 	sts	0x3C7D, r24
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	9c 01       	movw	r18, r24
    1f3e:	22 0f       	add	r18, r18
    1f40:	33 1f       	adc	r19, r19
    1f42:	22 0f       	add	r18, r18
    1f44:	33 1f       	adc	r19, r19
    1f46:	22 0f       	add	r18, r18
    1f48:	33 1f       	adc	r19, r19
    1f4a:	82 0f       	add	r24, r18
    1f4c:	93 1f       	adc	r25, r19
    1f4e:	b8 01       	movw	r22, r16
    1f50:	86 55       	subi	r24, 0x56	; 86
    1f52:	93 4c       	sbci	r25, 0xC3	; 195
    1f54:	0e 94 88 06 	call	0xd10	; 0xd10 <vListInsertEnd>
			}
		}
	}
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	1f 91       	pop	r17
    1f5e:	0f 91       	pop	r16
    1f60:	08 95       	ret

00001f62 <prvInsertTimerInActiveList>:
			traceTIMER_CREATE_FAILED();
		}
	}
	
	return ( xTimerHandle ) pxNewTimer;
}
    1f62:	fc 01       	movw	r30, r24
    1f64:	62 83       	std	Z+2, r22	; 0x02
    1f66:	73 83       	std	Z+3, r23	; 0x03
    1f68:	80 87       	std	Z+8, r24	; 0x08
    1f6a:	91 87       	std	Z+9, r25	; 0x09
    1f6c:	46 17       	cp	r20, r22
    1f6e:	57 07       	cpc	r21, r23
    1f70:	90 f0       	brcs	.+36     	; 0x1f96 <prvInsertTimerInActiveList+0x34>
    1f72:	42 1b       	sub	r20, r18
    1f74:	53 0b       	sbc	r21, r19
    1f76:	84 85       	ldd	r24, Z+12	; 0x0c
    1f78:	95 85       	ldd	r25, Z+13	; 0x0d
    1f7a:	48 17       	cp	r20, r24
    1f7c:	59 07       	cpc	r21, r25
    1f7e:	e0 f4       	brcc	.+56     	; 0x1fb8 <prvInsertTimerInActiveList+0x56>
    1f80:	bf 01       	movw	r22, r30
    1f82:	6e 5f       	subi	r22, 0xFE	; 254
    1f84:	7f 4f       	sbci	r23, 0xFF	; 255
    1f86:	80 91 b9 3c 	lds	r24, 0x3CB9
    1f8a:	90 91 ba 3c 	lds	r25, 0x3CBA
    1f8e:	0e 94 af 06 	call	0xd5e	; 0xd5e <vListInsert>
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	08 95       	ret
    1f96:	42 17       	cp	r20, r18
    1f98:	53 07       	cpc	r21, r19
    1f9a:	18 f4       	brcc	.+6      	; 0x1fa2 <prvInsertTimerInActiveList+0x40>
    1f9c:	62 17       	cp	r22, r18
    1f9e:	73 07       	cpc	r23, r19
    1fa0:	68 f4       	brcc	.+26     	; 0x1fbc <prvInsertTimerInActiveList+0x5a>
    1fa2:	bf 01       	movw	r22, r30
    1fa4:	6e 5f       	subi	r22, 0xFE	; 254
    1fa6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fa8:	80 91 bb 3c 	lds	r24, 0x3CBB
    1fac:	90 91 bc 3c 	lds	r25, 0x3CBC
    1fb0:	0e 94 af 06 	call	0xd5e	; 0xd5e <vListInsert>
    1fb4:	80 e0       	ldi	r24, 0x00	; 0
    1fb6:	08 95       	ret
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	08 95       	ret
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	08 95       	ret

00001fc0 <prvCheckForValidListAndQueue>:
    1fc0:	0f b6       	in	r0, 0x3f	; 63
    1fc2:	f8 94       	cli
    1fc4:	0f 92       	push	r0
    1fc6:	80 91 b7 3c 	lds	r24, 0x3CB7
    1fca:	90 91 b8 3c 	lds	r25, 0x3CB8
    1fce:	89 2b       	or	r24, r25
    1fd0:	e1 f4       	brne	.+56     	; 0x200a <prvCheckForValidListAndQueue+0x4a>
    1fd2:	86 ec       	ldi	r24, 0xC6	; 198
    1fd4:	9c e3       	ldi	r25, 0x3C	; 60
    1fd6:	0e 94 76 06 	call	0xcec	; 0xcec <vListInitialise>
    1fda:	8d eb       	ldi	r24, 0xBD	; 189
    1fdc:	9c e3       	ldi	r25, 0x3C	; 60
    1fde:	0e 94 76 06 	call	0xcec	; 0xcec <vListInitialise>
    1fe2:	86 ec       	ldi	r24, 0xC6	; 198
    1fe4:	9c e3       	ldi	r25, 0x3C	; 60
    1fe6:	80 93 bb 3c 	sts	0x3CBB, r24
    1fea:	90 93 bc 3c 	sts	0x3CBC, r25
    1fee:	8d eb       	ldi	r24, 0xBD	; 189
    1ff0:	9c e3       	ldi	r25, 0x3C	; 60
    1ff2:	80 93 b9 3c 	sts	0x3CB9, r24
    1ff6:	90 93 ba 3c 	sts	0x3CBA, r25
    1ffa:	65 e0       	ldi	r22, 0x05	; 5
    1ffc:	80 e1       	ldi	r24, 0x10	; 16
    1ffe:	0e 94 ba 07 	call	0xf74	; 0xf74 <xQueueCreate>
    2002:	80 93 b7 3c 	sts	0x3CB7, r24
    2006:	90 93 b8 3c 	sts	0x3CB8, r25
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	08 95       	ret

00002010 <xTimerCreateTimerTask>:
    2010:	af 92       	push	r10
    2012:	bf 92       	push	r11
    2014:	cf 92       	push	r12
    2016:	df 92       	push	r13
    2018:	ef 92       	push	r14
    201a:	ff 92       	push	r15
    201c:	0f 93       	push	r16
    201e:	d0 df       	rcall	.-96     	; 0x1fc0 <prvCheckForValidListAndQueue>
    2020:	80 91 b7 3c 	lds	r24, 0x3CB7
    2024:	90 91 b8 3c 	lds	r25, 0x3CB8
    2028:	89 2b       	or	r24, r25
    202a:	89 f0       	breq	.+34     	; 0x204e <xTimerCreateTimerTask+0x3e>
    202c:	a1 2c       	mov	r10, r1
    202e:	b1 2c       	mov	r11, r1
    2030:	c1 2c       	mov	r12, r1
    2032:	d1 2c       	mov	r13, r1
    2034:	e1 2c       	mov	r14, r1
    2036:	f1 2c       	mov	r15, r1
    2038:	00 e0       	ldi	r16, 0x00	; 0
    203a:	20 e0       	ldi	r18, 0x00	; 0
    203c:	30 e0       	ldi	r19, 0x00	; 0
    203e:	40 e4       	ldi	r20, 0x40	; 64
    2040:	50 e0       	ldi	r21, 0x00	; 0
    2042:	66 e8       	ldi	r22, 0x86	; 134
    2044:	70 e2       	ldi	r23, 0x20	; 32
    2046:	84 ee       	ldi	r24, 0xE4	; 228
    2048:	90 e1       	ldi	r25, 0x10	; 16
    204a:	8f da       	rcall	.-2786   	; 0x156a <xTaskGenericCreate>
    204c:	01 c0       	rjmp	.+2      	; 0x2050 <xTimerCreateTimerTask+0x40>
    204e:	80 e0       	ldi	r24, 0x00	; 0
    2050:	0f 91       	pop	r16
    2052:	ff 90       	pop	r15
    2054:	ef 90       	pop	r14
    2056:	df 90       	pop	r13
    2058:	cf 90       	pop	r12
    205a:	bf 90       	pop	r11
    205c:	af 90       	pop	r10
    205e:	08 95       	ret

00002060 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    2060:	0f 93       	push	r16
    2062:	1f 93       	push	r17
    2064:	cf 93       	push	r28
    2066:	df 93       	push	r29
    2068:	cd b7       	in	r28, 0x3d	; 61
    206a:	de b7       	in	r29, 0x3e	; 62
    206c:	25 97       	sbiw	r28, 0x05	; 5
    206e:	cd bf       	out	0x3d, r28	; 61
    2070:	de bf       	out	0x3e, r29	; 62
    2072:	d9 01       	movw	r26, r18
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2074:	e0 91 b7 3c 	lds	r30, 0x3CB7
    2078:	f0 91 b8 3c 	lds	r31, 0x3CB8
    207c:	30 97       	sbiw	r30, 0x00	; 0
    207e:	59 f1       	breq	.+86     	; 0x20d6 <xTimerGenericCommand+0x76>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2080:	69 83       	std	Y+1, r22	; 0x01
		xMessage.xMessageValue = xOptionalValue;
    2082:	4a 83       	std	Y+2, r20	; 0x02
    2084:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    2086:	8c 83       	std	Y+4, r24	; 0x04
    2088:	9d 83       	std	Y+5, r25	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    208a:	10 97       	sbiw	r26, 0x00	; 0
    208c:	e1 f4       	brne	.+56     	; 0x20c6 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    208e:	d1 de       	rcall	.-606    	; 0x1e32 <xTaskGetSchedulerState>
    2090:	81 30       	cpi	r24, 0x01	; 1
    2092:	61 f4       	brne	.+24     	; 0x20ac <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    2094:	20 e0       	ldi	r18, 0x00	; 0
    2096:	a8 01       	movw	r20, r16
    2098:	be 01       	movw	r22, r28
    209a:	6f 5f       	subi	r22, 0xFF	; 255
    209c:	7f 4f       	sbci	r23, 0xFF	; 255
    209e:	80 91 b7 3c 	lds	r24, 0x3CB7
    20a2:	90 91 b8 3c 	lds	r25, 0x3CB8
    20a6:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    20aa:	16 c0       	rjmp	.+44     	; 0x20d8 <xTimerGenericCommand+0x78>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    20ac:	20 e0       	ldi	r18, 0x00	; 0
    20ae:	40 e0       	ldi	r20, 0x00	; 0
    20b0:	50 e0       	ldi	r21, 0x00	; 0
    20b2:	be 01       	movw	r22, r28
    20b4:	6f 5f       	subi	r22, 0xFF	; 255
    20b6:	7f 4f       	sbci	r23, 0xFF	; 255
    20b8:	80 91 b7 3c 	lds	r24, 0x3CB7
    20bc:	90 91 b8 3c 	lds	r25, 0x3CB8
    20c0:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    20c4:	09 c0       	rjmp	.+18     	; 0x20d8 <xTimerGenericCommand+0x78>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    20c6:	20 e0       	ldi	r18, 0x00	; 0
    20c8:	ad 01       	movw	r20, r26
    20ca:	be 01       	movw	r22, r28
    20cc:	6f 5f       	subi	r22, 0xFF	; 255
    20ce:	7f 4f       	sbci	r23, 0xFF	; 255
    20d0:	cf 01       	movw	r24, r30
    20d2:	4c d8       	rcall	.-3944   	; 0x116c <xQueueGenericSendFromISR>
    20d4:	01 c0       	rjmp	.+2      	; 0x20d8 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
    20d6:	80 e0       	ldi	r24, 0x00	; 0
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
}
    20d8:	25 96       	adiw	r28, 0x05	; 5
    20da:	cd bf       	out	0x3d, r28	; 61
    20dc:	de bf       	out	0x3e, r29	; 62
    20de:	df 91       	pop	r29
    20e0:	cf 91       	pop	r28
    20e2:	1f 91       	pop	r17
    20e4:	0f 91       	pop	r16
    20e6:	08 95       	ret

000020e8 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    20e8:	af 92       	push	r10
    20ea:	bf 92       	push	r11
    20ec:	cf 92       	push	r12
    20ee:	df 92       	push	r13
    20f0:	ef 92       	push	r14
    20f2:	ff 92       	push	r15
    20f4:	0f 93       	push	r16
    20f6:	1f 93       	push	r17
    20f8:	cf 93       	push	r28
    20fa:	df 93       	push	r29
    20fc:	5c 01       	movw	r10, r24
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    20fe:	4e db       	rcall	.-2404   	; 0x179c <xTaskGetTickCount>
    2100:	6c 01       	movw	r12, r24
	
	if( xTimeNow < xLastTime )
    2102:	80 91 b5 3c 	lds	r24, 0x3CB5
    2106:	90 91 b6 3c 	lds	r25, 0x3CB6
    210a:	c8 16       	cp	r12, r24
    210c:	d9 06       	cpc	r13, r25
    210e:	08 f0       	brcs	.+2      	; 0x2112 <prvSampleTimeNow+0x2a>
    2110:	49 c0       	rjmp	.+146    	; 0x21a4 <prvSampleTimeNow+0xbc>
    2112:	31 c0       	rjmp	.+98     	; 0x2176 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2114:	a5 81       	ldd	r26, Z+5	; 0x05
    2116:	b6 81       	ldd	r27, Z+6	; 0x06
    2118:	ed 90       	ld	r14, X+
    211a:	fc 90       	ld	r15, X

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    211c:	05 80       	ldd	r0, Z+5	; 0x05
    211e:	f6 81       	ldd	r31, Z+6	; 0x06
    2120:	e0 2d       	mov	r30, r0
    2122:	c6 81       	ldd	r28, Z+6	; 0x06
    2124:	d7 81       	ldd	r29, Z+7	; 0x07
		vListRemove( &( pxTimer->xTimerListItem ) );
    2126:	8e 01       	movw	r16, r28
    2128:	0e 5f       	subi	r16, 0xFE	; 254
    212a:	1f 4f       	sbci	r17, 0xFF	; 255
    212c:	c8 01       	movw	r24, r16
    212e:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    2132:	e9 89       	ldd	r30, Y+17	; 0x11
    2134:	fa 89       	ldd	r31, Y+18	; 0x12
    2136:	ce 01       	movw	r24, r28
    2138:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    213a:	8e 85       	ldd	r24, Y+14	; 0x0e
    213c:	81 30       	cpi	r24, 0x01	; 1
    213e:	d9 f4       	brne	.+54     	; 0x2176 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2140:	8c 85       	ldd	r24, Y+12	; 0x0c
    2142:	9d 85       	ldd	r25, Y+13	; 0x0d
    2144:	8e 0d       	add	r24, r14
    2146:	9f 1d       	adc	r25, r15
			if( xReloadTime > xNextExpireTime )
    2148:	e8 16       	cp	r14, r24
    214a:	f9 06       	cpc	r15, r25
    214c:	60 f4       	brcc	.+24     	; 0x2166 <prvSampleTimeNow+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    214e:	8a 83       	std	Y+2, r24	; 0x02
    2150:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2152:	c8 87       	std	Y+8, r28	; 0x08
    2154:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2156:	b8 01       	movw	r22, r16
    2158:	80 91 bb 3c 	lds	r24, 0x3CBB
    215c:	90 91 bc 3c 	lds	r25, 0x3CBC
    2160:	0e 94 af 06 	call	0xd5e	; 0xd5e <vListInsert>
    2164:	08 c0       	rjmp	.+16     	; 0x2176 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    2166:	00 e0       	ldi	r16, 0x00	; 0
    2168:	10 e0       	ldi	r17, 0x00	; 0
    216a:	20 e0       	ldi	r18, 0x00	; 0
    216c:	30 e0       	ldi	r19, 0x00	; 0
    216e:	a7 01       	movw	r20, r14
    2170:	60 e0       	ldi	r22, 0x00	; 0
    2172:	ce 01       	movw	r24, r28
    2174:	75 df       	rcall	.-278    	; 0x2060 <xTimerGenericCommand>
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2176:	e0 91 bb 3c 	lds	r30, 0x3CBB
    217a:	f0 91 bc 3c 	lds	r31, 0x3CBC
    217e:	80 81       	ld	r24, Z
    2180:	81 11       	cpse	r24, r1
    2182:	c8 cf       	rjmp	.-112    	; 0x2114 <prvSampleTimeNow+0x2c>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2184:	80 91 b9 3c 	lds	r24, 0x3CB9
    2188:	90 91 ba 3c 	lds	r25, 0x3CBA
    218c:	80 93 bb 3c 	sts	0x3CBB, r24
    2190:	90 93 bc 3c 	sts	0x3CBC, r25
	pxOverflowTimerList = pxTemp;
    2194:	e0 93 b9 3c 	sts	0x3CB9, r30
    2198:	f0 93 ba 3c 	sts	0x3CBA, r31
	xTimeNow = xTaskGetTickCount();
	
	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
    219c:	81 e0       	ldi	r24, 0x01	; 1
    219e:	f5 01       	movw	r30, r10
    21a0:	80 83       	st	Z, r24
    21a2:	02 c0       	rjmp	.+4      	; 0x21a8 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    21a4:	f5 01       	movw	r30, r10
    21a6:	10 82       	st	Z, r1
	}
	
	xLastTime = xTimeNow;
    21a8:	c0 92 b5 3c 	sts	0x3CB5, r12
    21ac:	d0 92 b6 3c 	sts	0x3CB6, r13
	
	return xTimeNow;
}
    21b0:	c6 01       	movw	r24, r12
    21b2:	df 91       	pop	r29
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	ff 90       	pop	r15
    21bc:	ef 90       	pop	r14
    21be:	df 90       	pop	r13
    21c0:	cf 90       	pop	r12
    21c2:	bf 90       	pop	r11
    21c4:	af 90       	pop	r10
    21c6:	08 95       	ret

000021c8 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    21c8:	cf 93       	push	r28
    21ca:	df 93       	push	r29
    21cc:	00 d0       	rcall	.+0      	; 0x21ce <prvTimerTask+0x6>
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <prvTimerTask+0x8>
    21d0:	cd b7       	in	r28, 0x3d	; 61
    21d2:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    21d4:	ce 01       	movw	r24, r28
    21d6:	01 96       	adiw	r24, 0x01	; 1
    21d8:	5c 01       	movw	r10, r24

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    21da:	88 2e       	mov	r8, r24
    21dc:	9b 2c       	mov	r9, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    21de:	e0 91 bb 3c 	lds	r30, 0x3CBB
    21e2:	f0 91 bc 3c 	lds	r31, 0x3CBC
    21e6:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    21e8:	88 23       	and	r24, r24
    21ea:	09 f4       	brne	.+2      	; 0x21ee <prvTimerTask+0x26>
    21ec:	b1 c0       	rjmp	.+354    	; 0x2350 <prvTimerTask+0x188>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    21ee:	05 80       	ldd	r0, Z+5	; 0x05
    21f0:	f6 81       	ldd	r31, Z+6	; 0x06
    21f2:	e0 2d       	mov	r30, r0
    21f4:	e0 80       	ld	r14, Z
    21f6:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    21f8:	cb da       	rcall	.-2666   	; 0x1790 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    21fa:	c5 01       	movw	r24, r10
    21fc:	75 df       	rcall	.-278    	; 0x20e8 <prvSampleTimeNow>
    21fe:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	81 11       	cpse	r24, r1
    2204:	43 c0       	rjmp	.+134    	; 0x228c <prvTimerTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2206:	0e 15       	cp	r16, r14
    2208:	1f 05       	cpc	r17, r15
    220a:	90 f1       	brcs	.+100    	; 0x2270 <prvTimerTask+0xa8>
			{
				xTaskResumeAll();
    220c:	95 db       	rcall	.-2262   	; 0x1938 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    220e:	e0 91 bb 3c 	lds	r30, 0x3CBB
    2212:	f0 91 bc 3c 	lds	r31, 0x3CBC
    2216:	05 80       	ldd	r0, Z+5	; 0x05
    2218:	f6 81       	ldd	r31, Z+6	; 0x06
    221a:	e0 2d       	mov	r30, r0
    221c:	c6 80       	ldd	r12, Z+6	; 0x06
    221e:	d7 80       	ldd	r13, Z+7	; 0x07
	vListRemove( &( pxTimer->xTimerListItem ) );
    2220:	c6 01       	movw	r24, r12
    2222:	02 96       	adiw	r24, 0x02	; 2
    2224:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    2228:	d6 01       	movw	r26, r12
    222a:	1e 96       	adiw	r26, 0x0e	; 14
    222c:	8c 91       	ld	r24, X
    222e:	1e 97       	sbiw	r26, 0x0e	; 14
    2230:	81 30       	cpi	r24, 0x01	; 1
    2232:	a1 f4       	brne	.+40     	; 0x225c <prvTimerTask+0x94>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2234:	1c 96       	adiw	r26, 0x0c	; 12
    2236:	6d 91       	ld	r22, X+
    2238:	7c 91       	ld	r23, X
    223a:	1d 97       	sbiw	r26, 0x0d	; 13
    223c:	6e 0d       	add	r22, r14
    223e:	7f 1d       	adc	r23, r15
    2240:	97 01       	movw	r18, r14
    2242:	a8 01       	movw	r20, r16
    2244:	c6 01       	movw	r24, r12
    2246:	8d de       	rcall	.-742    	; 0x1f62 <prvInsertTimerInActiveList>
    2248:	81 30       	cpi	r24, 0x01	; 1
    224a:	41 f4       	brne	.+16     	; 0x225c <prvTimerTask+0x94>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    224c:	00 e0       	ldi	r16, 0x00	; 0
    224e:	10 e0       	ldi	r17, 0x00	; 0
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	a7 01       	movw	r20, r14
    2256:	60 e0       	ldi	r22, 0x00	; 0
    2258:	c6 01       	movw	r24, r12
    225a:	02 df       	rcall	.-508    	; 0x2060 <xTimerGenericCommand>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    225c:	d6 01       	movw	r26, r12
    225e:	51 96       	adiw	r26, 0x11	; 17
    2260:	ed 91       	ld	r30, X+
    2262:	fc 91       	ld	r31, X
    2264:	52 97       	sbiw	r26, 0x12	; 18
    2266:	c6 01       	movw	r24, r12
    2268:	19 95       	eicall
    226a:	11 c0       	rjmp	.+34     	; 0x228e <prvTimerTask+0xc6>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    226c:	e1 2c       	mov	r14, r1
    226e:	f1 2c       	mov	r15, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    2270:	b7 01       	movw	r22, r14
    2272:	60 1b       	sub	r22, r16
    2274:	71 0b       	sbc	r23, r17
    2276:	80 91 b7 3c 	lds	r24, 0x3CB7
    227a:	90 91 b8 3c 	lds	r25, 0x3CB8
    227e:	81 d8       	rcall	.-3838   	; 0x1382 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    2280:	5b db       	rcall	.-2378   	; 0x1938 <xTaskResumeAll>
    2282:	81 11       	cpse	r24, r1
    2284:	04 c0       	rjmp	.+8      	; 0x228e <prvTimerTask+0xc6>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    2286:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vPortYield>
    228a:	01 c0       	rjmp	.+2      	; 0x228e <prvTimerTask+0xc6>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    228c:	55 db       	rcall	.-2390   	; 0x1938 <xTaskResumeAll>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    228e:	ce 01       	movw	r24, r28
    2290:	06 96       	adiw	r24, 0x06	; 6
    2292:	2a df       	rcall	.-428    	; 0x20e8 <prvSampleTimeNow>
    2294:	6c 01       	movw	r12, r24
    2296:	4e c0       	rjmp	.+156    	; 0x2334 <prvTimerTask+0x16c>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    2298:	ec 80       	ldd	r14, Y+4	; 0x04
    229a:	fd 80       	ldd	r15, Y+5	; 0x05

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    229c:	e1 14       	cp	r14, r1
    229e:	f1 04       	cpc	r15, r1
    22a0:	59 f0       	breq	.+22     	; 0x22b8 <prvTimerTask+0xf0>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    22a2:	d7 01       	movw	r26, r14
    22a4:	1a 96       	adiw	r26, 0x0a	; 10
    22a6:	ed 91       	ld	r30, X+
    22a8:	fc 91       	ld	r31, X
    22aa:	1b 97       	sbiw	r26, 0x0b	; 11
    22ac:	ef 2b       	or	r30, r31
    22ae:	21 f0       	breq	.+8      	; 0x22b8 <prvTimerTask+0xf0>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    22b0:	c7 01       	movw	r24, r14
    22b2:	02 96       	adiw	r24, 0x02	; 2
    22b4:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	82 30       	cpi	r24, 0x02	; 2
    22bc:	49 f1       	breq	.+82     	; 0x2310 <prvTimerTask+0x148>
    22be:	83 30       	cpi	r24, 0x03	; 3
    22c0:	b1 f1       	breq	.+108    	; 0x232e <prvTimerTask+0x166>
    22c2:	81 11       	cpse	r24, r1
    22c4:	37 c0       	rjmp	.+110    	; 0x2334 <prvTimerTask+0x16c>
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    22c6:	2a 81       	ldd	r18, Y+2	; 0x02
    22c8:	3b 81       	ldd	r19, Y+3	; 0x03
    22ca:	f7 01       	movw	r30, r14
    22cc:	64 85       	ldd	r22, Z+12	; 0x0c
    22ce:	75 85       	ldd	r23, Z+13	; 0x0d
    22d0:	62 0f       	add	r22, r18
    22d2:	73 1f       	adc	r23, r19
    22d4:	a6 01       	movw	r20, r12
    22d6:	c7 01       	movw	r24, r14
    22d8:	44 de       	rcall	.-888    	; 0x1f62 <prvInsertTimerInActiveList>
    22da:	81 30       	cpi	r24, 0x01	; 1
    22dc:	59 f5       	brne	.+86     	; 0x2334 <prvTimerTask+0x16c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    22de:	d7 01       	movw	r26, r14
    22e0:	51 96       	adiw	r26, 0x11	; 17
    22e2:	ed 91       	ld	r30, X+
    22e4:	fc 91       	ld	r31, X
    22e6:	52 97       	sbiw	r26, 0x12	; 18
    22e8:	c7 01       	movw	r24, r14
    22ea:	19 95       	eicall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    22ec:	f7 01       	movw	r30, r14
    22ee:	86 85       	ldd	r24, Z+14	; 0x0e
    22f0:	81 30       	cpi	r24, 0x01	; 1
    22f2:	01 f5       	brne	.+64     	; 0x2334 <prvTimerTask+0x16c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    22f4:	44 85       	ldd	r20, Z+12	; 0x0c
    22f6:	55 85       	ldd	r21, Z+13	; 0x0d
    22f8:	8a 81       	ldd	r24, Y+2	; 0x02
    22fa:	9b 81       	ldd	r25, Y+3	; 0x03
    22fc:	48 0f       	add	r20, r24
    22fe:	59 1f       	adc	r21, r25
    2300:	00 e0       	ldi	r16, 0x00	; 0
    2302:	10 e0       	ldi	r17, 0x00	; 0
    2304:	20 e0       	ldi	r18, 0x00	; 0
    2306:	30 e0       	ldi	r19, 0x00	; 0
    2308:	60 e0       	ldi	r22, 0x00	; 0
    230a:	c7 01       	movw	r24, r14
    230c:	a9 de       	rcall	.-686    	; 0x2060 <xTimerGenericCommand>
    230e:	12 c0       	rjmp	.+36     	; 0x2334 <prvTimerTask+0x16c>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    2310:	2a 81       	ldd	r18, Y+2	; 0x02
    2312:	3b 81       	ldd	r19, Y+3	; 0x03
    2314:	d7 01       	movw	r26, r14
    2316:	1c 96       	adiw	r26, 0x0c	; 12
    2318:	2d 93       	st	X+, r18
    231a:	3c 93       	st	X, r19
    231c:	1d 97       	sbiw	r26, 0x0d	; 13
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    231e:	b6 01       	movw	r22, r12
    2320:	62 0f       	add	r22, r18
    2322:	73 1f       	adc	r23, r19
    2324:	96 01       	movw	r18, r12
    2326:	a6 01       	movw	r20, r12
    2328:	c7 01       	movw	r24, r14
    232a:	1b de       	rcall	.-970    	; 0x1f62 <prvInsertTimerInActiveList>
    232c:	03 c0       	rjmp	.+6      	; 0x2334 <prvTimerTask+0x16c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    232e:	c7 01       	movw	r24, r14
    2330:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    2334:	20 e0       	ldi	r18, 0x00	; 0
    2336:	40 e0       	ldi	r20, 0x00	; 0
    2338:	50 e0       	ldi	r21, 0x00	; 0
    233a:	68 2d       	mov	r22, r8
    233c:	79 2d       	mov	r23, r9
    233e:	80 91 b7 3c 	lds	r24, 0x3CB7
    2342:	90 91 b8 3c 	lds	r25, 0x3CB8
    2346:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <xQueueGenericReceive>
    234a:	81 11       	cpse	r24, r1
    234c:	a5 cf       	rjmp	.-182    	; 0x2298 <prvTimerTask+0xd0>
    234e:	47 cf       	rjmp	.-370    	; 0x21de <prvTimerTask+0x16>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    2350:	1f da       	rcall	.-3010   	; 0x1790 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2352:	c5 01       	movw	r24, r10
    2354:	c9 de       	rcall	.-622    	; 0x20e8 <prvSampleTimeNow>
    2356:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2358:	89 81       	ldd	r24, Y+1	; 0x01
    235a:	88 23       	and	r24, r24
    235c:	09 f4       	brne	.+2      	; 0x2360 <prvTimerTask+0x198>
    235e:	86 cf       	rjmp	.-244    	; 0x226c <prvTimerTask+0xa4>
    2360:	95 cf       	rjmp	.-214    	; 0x228c <prvTimerTask+0xc4>

00002362 <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    2362:	0c 94 f0 04 	jmp	0x9e0	; 0x9e0 <pvPortMalloc>
}
    2366:	08 95       	ret

00002368 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    2368:	0c 94 14 05 	jmp	0xa28	; 0xa28 <vPortFree>
    236c:	08 95       	ret

0000236e <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    236e:	0c 94 ba 07 	jmp	0xf74	; 0xf74 <xQueueCreate>
    2372:	08 95       	ret

00002374 <csp_queue_enqueue>:
    2374:	fb 01       	movw	r30, r22
    2376:	ba 01       	movw	r22, r20
    2378:	a9 01       	movw	r20, r18
    237a:	20 e0       	ldi	r18, 0x00	; 0
    237c:	bf 01       	movw	r22, r30
    237e:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    2382:	99 27       	eor	r25, r25
    2384:	87 fd       	sbrc	r24, 7
    2386:	90 95       	com	r25
    2388:	08 95       	ret

0000238a <csp_queue_enqueue_isr>:
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	0e 94 b6 08 	call	0x116c	; 0x116c <xQueueGenericSendFromISR>
    2390:	99 27       	eor	r25, r25
    2392:	87 fd       	sbrc	r24, 7
    2394:	90 95       	com	r25
    2396:	08 95       	ret

00002398 <csp_queue_dequeue>:
    2398:	fb 01       	movw	r30, r22
    239a:	ba 01       	movw	r22, r20
    239c:	a9 01       	movw	r20, r18
    239e:	20 e0       	ldi	r18, 0x00	; 0
    23a0:	bf 01       	movw	r22, r30
    23a2:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <xQueueGenericReceive>
    23a6:	99 27       	eor	r25, r25
    23a8:	87 fd       	sbrc	r24, 7
    23aa:	90 95       	com	r25
    23ac:	08 95       	ret

000023ae <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    23ae:	0e 94 b9 09 	call	0x1372	; 0x1372 <uxQueueMessagesWaiting>
}
    23b2:	90 e0       	ldi	r25, 0x00	; 0
    23b4:	08 95       	ret

000023b6 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    23b6:	cf 93       	push	r28
    23b8:	df 93       	push	r29
    23ba:	ec 01       	movw	r28, r24
    23bc:	0e 94 8e 08 	call	0x111c	; 0x111c <xQueueCreateMutex>
    23c0:	9c 01       	movw	r18, r24
    23c2:	88 83       	st	Y, r24
    23c4:	99 83       	std	Y+1, r25	; 0x01
    23c6:	81 e0       	ldi	r24, 0x01	; 1
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	23 2b       	or	r18, r19
    23cc:	11 f4       	brne	.+4      	; 0x23d2 <csp_mutex_create+0x1c>
    23ce:	80 e0       	ldi	r24, 0x00	; 0
    23d0:	90 e0       	ldi	r25, 0x00	; 0
    23d2:	df 91       	pop	r29
    23d4:	cf 91       	pop	r28
    23d6:	08 95       	ret

000023d8 <csp_bin_sem_create>:
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
    23dc:	ec 01       	movw	r28, r24
    23de:	60 e0       	ldi	r22, 0x00	; 0
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	0e 94 ba 07 	call	0xf74	; 0xf74 <xQueueCreate>
    23e6:	88 83       	st	Y, r24
    23e8:	99 83       	std	Y+1, r25	; 0x01
    23ea:	00 97       	sbiw	r24, 0x00	; 0
    23ec:	39 f0       	breq	.+14     	; 0x23fc <csp_bin_sem_create+0x24>
    23ee:	20 e0       	ldi	r18, 0x00	; 0
    23f0:	40 e0       	ldi	r20, 0x00	; 0
    23f2:	50 e0       	ldi	r21, 0x00	; 0
    23f4:	60 e0       	ldi	r22, 0x00	; 0
    23f6:	70 e0       	ldi	r23, 0x00	; 0
    23f8:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	df 91       	pop	r29
    2402:	cf 91       	pop	r28
    2404:	08 95       	ret

00002406 <csp_bin_sem_wait>:
    2406:	20 e0       	ldi	r18, 0x00	; 0
    2408:	60 e0       	ldi	r22, 0x00	; 0
    240a:	70 e0       	ldi	r23, 0x00	; 0
    240c:	fc 01       	movw	r30, r24
    240e:	80 81       	ld	r24, Z
    2410:	91 81       	ldd	r25, Z+1	; 0x01
    2412:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <xQueueGenericReceive>
    2416:	21 e0       	ldi	r18, 0x01	; 1
    2418:	30 e0       	ldi	r19, 0x00	; 0
    241a:	81 30       	cpi	r24, 0x01	; 1
    241c:	11 f0       	breq	.+4      	; 0x2422 <csp_bin_sem_wait+0x1c>
    241e:	20 e0       	ldi	r18, 0x00	; 0
    2420:	30 e0       	ldi	r19, 0x00	; 0
    2422:	c9 01       	movw	r24, r18
    2424:	08 95       	ret

00002426 <csp_bin_sem_post>:
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
	csp_log_lock("Post: %p\r\n", sem);
	if (xSemaphoreGive(*sem) == pdPASS) {
    2426:	20 e0       	ldi	r18, 0x00	; 0
    2428:	40 e0       	ldi	r20, 0x00	; 0
    242a:	50 e0       	ldi	r21, 0x00	; 0
    242c:	60 e0       	ldi	r22, 0x00	; 0
    242e:	70 e0       	ldi	r23, 0x00	; 0
    2430:	fc 01       	movw	r30, r24
    2432:	80 81       	ld	r24, Z
    2434:	91 81       	ldd	r25, Z+1	; 0x01
    2436:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    243a:	21 e0       	ldi	r18, 0x01	; 1
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	81 30       	cpi	r24, 0x01	; 1
    2440:	11 f0       	breq	.+4      	; 0x2446 <csp_bin_sem_post+0x20>
    2442:	20 e0       	ldi	r18, 0x00	; 0
    2444:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    2446:	c9 01       	movw	r24, r18
    2448:	08 95       	ret

0000244a <csp_sys_tasklist>:

#include <csp/arch/csp_system.h>

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed char *) out);
    244a:	19 db       	rcall	.-2510   	; 0x1a7e <vTaskList>
#else
	vTaskList(out);
#endif
	return CSP_ERR_NONE;
}
    244c:	80 e0       	ldi	r24, 0x00	; 0
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	08 95       	ret

00002452 <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    2452:	ae d9       	rcall	.-3236   	; 0x17b0 <uxTaskGetNumberOfTasks>
}
    2454:	28 e2       	ldi	r18, 0x28	; 40
    2456:	82 9f       	mul	r24, r18
    2458:	c0 01       	movw	r24, r0
    245a:	11 24       	eor	r1, r1
    245c:	08 95       	ret

0000245e <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    245e:	4f 92       	push	r4
    2460:	5f 92       	push	r5
    2462:	6f 92       	push	r6
    2464:	7f 92       	push	r7
    2466:	8f 92       	push	r8
    2468:	9f 92       	push	r9
    246a:	af 92       	push	r10
    246c:	bf 92       	push	r11
    246e:	cf 92       	push	r12
    2470:	df 92       	push	r13
    2472:	ef 92       	push	r14
    2474:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    2476:	0f 2e       	mov	r0, r31
    2478:	f0 e1       	ldi	r31, 0x10	; 16
    247a:	cf 2e       	mov	r12, r31
    247c:	f7 e2       	ldi	r31, 0x27	; 39
    247e:	df 2e       	mov	r13, r31
    2480:	e1 2c       	mov	r14, r1
    2482:	f1 2c       	mov	r15, r1
    2484:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    2486:	44 24       	eor	r4, r4
    2488:	4a 94       	dec	r4
    248a:	54 2c       	mov	r5, r4
    248c:	32 01       	movw	r6, r4
    248e:	81 2c       	mov	r8, r1
    2490:	91 2c       	mov	r9, r1
    2492:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    2494:	c4 01       	movw	r24, r8
    2496:	8c 0d       	add	r24, r12
    2498:	9d 1d       	adc	r25, r13
    249a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <pvPortMalloc>
		if (pmem == NULL) {
    249e:	00 97       	sbiw	r24, 0x00	; 0
    24a0:	59 f4       	brne	.+22     	; 0x24b8 <csp_sys_memfree+0x5a>
			max = size + total;
    24a2:	26 01       	movw	r4, r12
    24a4:	37 01       	movw	r6, r14
    24a6:	48 0c       	add	r4, r8
    24a8:	59 1c       	adc	r5, r9
    24aa:	6a 1c       	adc	r6, r10
    24ac:	7b 1c       	adc	r7, r11
			size = size / 2;
    24ae:	f6 94       	lsr	r15
    24b0:	e7 94       	ror	r14
    24b2:	d7 94       	ror	r13
    24b4:	c7 94       	ror	r12
    24b6:	15 c0       	rjmp	.+42     	; 0x24e2 <csp_sys_memfree+0x84>
		} else {
			total += size;
    24b8:	8c 0c       	add	r8, r12
    24ba:	9d 1c       	adc	r9, r13
    24bc:	ae 1c       	adc	r10, r14
    24be:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    24c0:	b5 01       	movw	r22, r10
    24c2:	a4 01       	movw	r20, r8
    24c4:	4c 0d       	add	r20, r12
    24c6:	5d 1d       	adc	r21, r13
    24c8:	6e 1d       	adc	r22, r14
    24ca:	7f 1d       	adc	r23, r15
    24cc:	44 15       	cp	r20, r4
    24ce:	55 05       	cpc	r21, r5
    24d0:	66 05       	cpc	r22, r6
    24d2:	77 05       	cpc	r23, r7
    24d4:	20 f0       	brcs	.+8      	; 0x24de <csp_sys_memfree+0x80>
				size = size / 2;
    24d6:	f6 94       	lsr	r15
    24d8:	e7 94       	ror	r14
    24da:	d7 94       	ror	r13
    24dc:	c7 94       	ror	r12
			vPortFree(pmem);
    24de:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortFree>
		}
		if (size < 32) break;
    24e2:	80 e2       	ldi	r24, 0x20	; 32
    24e4:	c8 16       	cp	r12, r24
    24e6:	d1 04       	cpc	r13, r1
    24e8:	e1 04       	cpc	r14, r1
    24ea:	f1 04       	cpc	r15, r1
    24ec:	98 f6       	brcc	.-90     	; 0x2494 <csp_sys_memfree+0x36>
	}

	return total;
}
    24ee:	c5 01       	movw	r24, r10
    24f0:	b4 01       	movw	r22, r8
    24f2:	ff 90       	pop	r15
    24f4:	ef 90       	pop	r14
    24f6:	df 90       	pop	r13
    24f8:	cf 90       	pop	r12
    24fa:	bf 90       	pop	r11
    24fc:	af 90       	pop	r10
    24fe:	9f 90       	pop	r9
    2500:	8f 90       	pop	r8
    2502:	7f 90       	pop	r7
    2504:	6f 90       	pop	r6
    2506:	5f 90       	pop	r5
    2508:	4f 90       	pop	r4
    250a:	08 95       	ret

0000250c <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    250c:	80 e0       	ldi	r24, 0x00	; 0
    250e:	90 e0       	ldi	r25, 0x00	; 0
    2510:	89 2b       	or	r24, r25
    2512:	21 f0       	breq	.+8      	; 0x251c <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	90 e0       	ldi	r25, 0x00	; 0
    2518:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    251c:	80 e0       	ldi	r24, 0x00	; 0
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	89 2b       	or	r24, r25
    2522:	19 f0       	breq	.+6      	; 0x252a <csp_sys_reboot+0x1e>
		cpu_reset();
    2524:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    2528:	ff cf       	rjmp	.-2      	; 0x2528 <csp_sys_reboot+0x1c>
	}
	
	csp_log_error("Failed to reboot\r\n");

	return CSP_ERR_INVAL;
}
    252a:	8e ef       	ldi	r24, 0xFE	; 254
    252c:	9f ef       	ldi	r25, 0xFF	; 255
    252e:	08 95       	ret

00002530 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const signed char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    2530:	af 92       	push	r10
    2532:	bf 92       	push	r11
    2534:	cf 92       	push	r12
    2536:	df 92       	push	r13
    2538:	ef 92       	push	r14
    253a:	ff 92       	push	r15
    253c:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, (char *) thread_name, stack_depth, parameters, priority, handle);
#else
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
    253e:	a1 2c       	mov	r10, r1
    2540:	b1 2c       	mov	r11, r1
    2542:	c1 2c       	mov	r12, r1
    2544:	d1 2c       	mov	r13, r1
    2546:	11 d8       	rcall	.-4062   	; 0x156a <xTaskGenericCreate>
#endif
	if (ret != pdTRUE)
    2548:	21 e0       	ldi	r18, 0x01	; 1
    254a:	30 e0       	ldi	r19, 0x00	; 0
    254c:	81 30       	cpi	r24, 0x01	; 1
    254e:	11 f4       	brne	.+4      	; 0x2554 <csp_thread_create+0x24>
    2550:	20 e0       	ldi	r18, 0x00	; 0
    2552:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    2554:	88 27       	eor	r24, r24
    2556:	99 27       	eor	r25, r25
    2558:	82 1b       	sub	r24, r18
    255a:	93 0b       	sbc	r25, r19
    255c:	0f 91       	pop	r16
    255e:	ff 90       	pop	r15
    2560:	ef 90       	pop	r14
    2562:	df 90       	pop	r13
    2564:	cf 90       	pop	r12
    2566:	bf 90       	pop	r11
    2568:	af 90       	pop	r10
    256a:	08 95       	ret

0000256c <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    256c:	17 d9       	rcall	.-3538   	; 0x179c <xTaskGetTickCount>
    256e:	bc 01       	movw	r22, r24
    2570:	80 e0       	ldi	r24, 0x00	; 0
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	08 95       	ret

00002576 <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    2576:	12 d9       	rcall	.-3548   	; 0x179c <xTaskGetTickCount>
    2578:	9c 01       	movw	r18, r24
    257a:	36 95       	lsr	r19
    257c:	27 95       	ror	r18
    257e:	36 95       	lsr	r19
    2580:	27 95       	ror	r18
    2582:	36 95       	lsr	r19
    2584:	27 95       	ror	r18
    2586:	a5 ec       	ldi	r26, 0xC5	; 197
    2588:	b0 e2       	ldi	r27, 0x20	; 32
    258a:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <__umulhisi3>
    258e:	92 95       	swap	r25
    2590:	82 95       	swap	r24
    2592:	8f 70       	andi	r24, 0x0F	; 15
    2594:	89 27       	eor	r24, r25
    2596:	9f 70       	andi	r25, 0x0F	; 15
    2598:	89 27       	eor	r24, r25
    259a:	bc 01       	movw	r22, r24
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	90 e0       	ldi	r25, 0x00	; 0
}
    25a0:	08 95       	ret

000025a2 <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    25a2:	cf 92       	push	r12
    25a4:	df 92       	push	r13
    25a6:	ef 92       	push	r14
    25a8:	ff 92       	push	r15
    25aa:	0f 93       	push	r16
    25ac:	1f 93       	push	r17
    25ae:	cf 93       	push	r28
    25b0:	df 93       	push	r29
    25b2:	1f 92       	push	r1
    25b4:	1f 92       	push	r1
    25b6:	cd b7       	in	r28, 0x3d	; 61
    25b8:	de b7       	in	r29, 0x3e	; 62
    25ba:	80 93 d1 3c 	sts	0x3CD1, r24
    25be:	90 93 d2 3c 	sts	0x3CD2, r25
    25c2:	60 93 cf 3c 	sts	0x3CCF, r22
    25c6:	70 93 d0 3c 	sts	0x3CD0, r23
    25ca:	6b 01       	movw	r12, r22
    25cc:	25 e0       	ldi	r18, 0x05	; 5
    25ce:	c2 0e       	add	r12, r18
    25d0:	d1 1c       	adc	r13, r1
    25d2:	e8 94       	clt
    25d4:	c0 f8       	bld	r12, 0
    25d6:	c8 9e       	mul	r12, r24
    25d8:	80 01       	movw	r16, r0
    25da:	c9 9e       	mul	r12, r25
    25dc:	10 0d       	add	r17, r0
    25de:	d8 9e       	mul	r13, r24
    25e0:	10 0d       	add	r17, r0
    25e2:	11 24       	eor	r1, r1
    25e4:	c8 01       	movw	r24, r16
    25e6:	bd de       	rcall	.-646    	; 0x2362 <csp_malloc>
    25e8:	80 93 d3 3c 	sts	0x3CD3, r24
    25ec:	90 93 d4 3c 	sts	0x3CD4, r25
    25f0:	89 2b       	or	r24, r25
    25f2:	09 f4       	brne	.+2      	; 0x25f6 <csp_buffer_init+0x54>
    25f4:	4d c0       	rjmp	.+154    	; 0x2690 <csp_buffer_init+0xee>
    25f6:	62 e0       	ldi	r22, 0x02	; 2
    25f8:	70 e0       	ldi	r23, 0x00	; 0
    25fa:	80 91 d1 3c 	lds	r24, 0x3CD1
    25fe:	90 91 d2 3c 	lds	r25, 0x3CD2
    2602:	b5 de       	rcall	.-662    	; 0x236e <csp_queue_create>
    2604:	80 93 d5 3c 	sts	0x3CD5, r24
    2608:	90 93 d6 3c 	sts	0x3CD6, r25
    260c:	89 2b       	or	r24, r25
    260e:	c1 f1       	breq	.+112    	; 0x2680 <csp_buffer_init+0xde>
    2610:	a8 01       	movw	r20, r16
    2612:	60 e0       	ldi	r22, 0x00	; 0
    2614:	70 e0       	ldi	r23, 0x00	; 0
    2616:	80 91 d3 3c 	lds	r24, 0x3CD3
    261a:	90 91 d4 3c 	lds	r25, 0x3CD4
    261e:	0e 94 45 2c 	call	0x588a	; 0x588a <memset>
    2622:	80 91 d1 3c 	lds	r24, 0x3CD1
    2626:	90 91 d2 3c 	lds	r25, 0x3CD2
    262a:	89 2b       	or	r24, r25
    262c:	a1 f1       	breq	.+104    	; 0x2696 <csp_buffer_init+0xf4>
    262e:	e1 2c       	mov	r14, r1
    2630:	f1 2c       	mov	r15, r1
    2632:	00 e0       	ldi	r16, 0x00	; 0
    2634:	10 e0       	ldi	r17, 0x00	; 0
    2636:	e0 91 d3 3c 	lds	r30, 0x3CD3
    263a:	f0 91 d4 3c 	lds	r31, 0x3CD4
    263e:	ee 0d       	add	r30, r14
    2640:	ff 1d       	adc	r31, r15
    2642:	e9 83       	std	Y+1, r30	; 0x01
    2644:	fa 83       	std	Y+2, r31	; 0x02
    2646:	10 82       	st	Z, r1
    2648:	11 82       	std	Z+1, r1	; 0x01
    264a:	e9 81       	ldd	r30, Y+1	; 0x01
    264c:	fa 81       	ldd	r31, Y+2	; 0x02
    264e:	e2 83       	std	Z+2, r30	; 0x02
    2650:	f3 83       	std	Z+3, r31	; 0x03
    2652:	20 e0       	ldi	r18, 0x00	; 0
    2654:	30 e0       	ldi	r19, 0x00	; 0
    2656:	a9 01       	movw	r20, r18
    2658:	be 01       	movw	r22, r28
    265a:	6f 5f       	subi	r22, 0xFF	; 255
    265c:	7f 4f       	sbci	r23, 0xFF	; 255
    265e:	80 91 d5 3c 	lds	r24, 0x3CD5
    2662:	90 91 d6 3c 	lds	r25, 0x3CD6
    2666:	86 de       	rcall	.-756    	; 0x2374 <csp_queue_enqueue>
    2668:	0f 5f       	subi	r16, 0xFF	; 255
    266a:	1f 4f       	sbci	r17, 0xFF	; 255
    266c:	ec 0c       	add	r14, r12
    266e:	fd 1c       	adc	r15, r13
    2670:	80 91 d1 3c 	lds	r24, 0x3CD1
    2674:	90 91 d2 3c 	lds	r25, 0x3CD2
    2678:	08 17       	cp	r16, r24
    267a:	19 07       	cpc	r17, r25
    267c:	e0 f2       	brcs	.-72     	; 0x2636 <csp_buffer_init+0x94>
    267e:	0e c0       	rjmp	.+28     	; 0x269c <csp_buffer_init+0xfa>
    2680:	80 91 d3 3c 	lds	r24, 0x3CD3
    2684:	90 91 d4 3c 	lds	r25, 0x3CD4
    2688:	6f de       	rcall	.-802    	; 0x2368 <csp_free>
    268a:	8f ef       	ldi	r24, 0xFF	; 255
    268c:	9f ef       	ldi	r25, 0xFF	; 255
    268e:	08 c0       	rjmp	.+16     	; 0x26a0 <csp_buffer_init+0xfe>
    2690:	8f ef       	ldi	r24, 0xFF	; 255
    2692:	9f ef       	ldi	r25, 0xFF	; 255
    2694:	05 c0       	rjmp	.+10     	; 0x26a0 <csp_buffer_init+0xfe>
    2696:	80 e0       	ldi	r24, 0x00	; 0
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	02 c0       	rjmp	.+4      	; 0x26a0 <csp_buffer_init+0xfe>
    269c:	80 e0       	ldi	r24, 0x00	; 0
    269e:	90 e0       	ldi	r25, 0x00	; 0
    26a0:	0f 90       	pop	r0
    26a2:	0f 90       	pop	r0
    26a4:	df 91       	pop	r29
    26a6:	cf 91       	pop	r28
    26a8:	1f 91       	pop	r17
    26aa:	0f 91       	pop	r16
    26ac:	ff 90       	pop	r15
    26ae:	ef 90       	pop	r14
    26b0:	df 90       	pop	r13
    26b2:	cf 90       	pop	r12
    26b4:	08 95       	ret

000026b6 <csp_buffer_get>:
    26b6:	cf 93       	push	r28
    26b8:	df 93       	push	r29
    26ba:	1f 92       	push	r1
    26bc:	1f 92       	push	r1
    26be:	cd b7       	in	r28, 0x3d	; 61
    26c0:	de b7       	in	r29, 0x3e	; 62
    26c2:	19 82       	std	Y+1, r1	; 0x01
    26c4:	1a 82       	std	Y+2, r1	; 0x02
    26c6:	0e 96       	adiw	r24, 0x0e	; 14
    26c8:	20 91 cf 3c 	lds	r18, 0x3CCF
    26cc:	30 91 d0 3c 	lds	r19, 0x3CD0
    26d0:	28 17       	cp	r18, r24
    26d2:	39 07       	cpc	r19, r25
    26d4:	e8 f0       	brcs	.+58     	; 0x2710 <csp_buffer_get+0x5a>
    26d6:	20 e0       	ldi	r18, 0x00	; 0
    26d8:	30 e0       	ldi	r19, 0x00	; 0
    26da:	a9 01       	movw	r20, r18
    26dc:	be 01       	movw	r22, r28
    26de:	6f 5f       	subi	r22, 0xFF	; 255
    26e0:	7f 4f       	sbci	r23, 0xFF	; 255
    26e2:	80 91 d5 3c 	lds	r24, 0x3CD5
    26e6:	90 91 d6 3c 	lds	r25, 0x3CD6
    26ea:	56 de       	rcall	.-852    	; 0x2398 <csp_queue_dequeue>
    26ec:	e9 81       	ldd	r30, Y+1	; 0x01
    26ee:	fa 81       	ldd	r31, Y+2	; 0x02
    26f0:	30 97       	sbiw	r30, 0x00	; 0
    26f2:	89 f0       	breq	.+34     	; 0x2716 <csp_buffer_get+0x60>
    26f4:	82 81       	ldd	r24, Z+2	; 0x02
    26f6:	93 81       	ldd	r25, Z+3	; 0x03
    26f8:	e8 17       	cp	r30, r24
    26fa:	f9 07       	cpc	r31, r25
    26fc:	79 f4       	brne	.+30     	; 0x271c <csp_buffer_get+0x66>
    26fe:	80 81       	ld	r24, Z
    2700:	91 81       	ldd	r25, Z+1	; 0x01
    2702:	01 96       	adiw	r24, 0x01	; 1
    2704:	80 83       	st	Z, r24
    2706:	91 83       	std	Z+1, r25	; 0x01
    2708:	89 81       	ldd	r24, Y+1	; 0x01
    270a:	9a 81       	ldd	r25, Y+2	; 0x02
    270c:	04 96       	adiw	r24, 0x04	; 4
    270e:	08 c0       	rjmp	.+16     	; 0x2720 <csp_buffer_get+0x6a>
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	90 e0       	ldi	r25, 0x00	; 0
    2714:	05 c0       	rjmp	.+10     	; 0x2720 <csp_buffer_get+0x6a>
    2716:	80 e0       	ldi	r24, 0x00	; 0
    2718:	90 e0       	ldi	r25, 0x00	; 0
    271a:	02 c0       	rjmp	.+4      	; 0x2720 <csp_buffer_get+0x6a>
    271c:	80 e0       	ldi	r24, 0x00	; 0
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	0f 90       	pop	r0
    2722:	0f 90       	pop	r0
    2724:	df 91       	pop	r29
    2726:	cf 91       	pop	r28
    2728:	08 95       	ret

0000272a <csp_buffer_free_isr>:
    272a:	cf 93       	push	r28
    272c:	df 93       	push	r29
    272e:	00 d0       	rcall	.+0      	; 0x2730 <csp_buffer_free_isr+0x6>
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
    2734:	19 82       	std	Y+1, r1	; 0x01
    2736:	00 97       	sbiw	r24, 0x00	; 0
    2738:	51 f1       	breq	.+84     	; 0x278e <csp_buffer_free_isr+0x64>
    273a:	9c 01       	movw	r18, r24
    273c:	24 50       	subi	r18, 0x04	; 4
    273e:	31 09       	sbc	r19, r1
    2740:	2a 83       	std	Y+2, r18	; 0x02
    2742:	3b 83       	std	Y+3, r19	; 0x03
    2744:	20 fd       	sbrc	r18, 0
    2746:	23 c0       	rjmp	.+70     	; 0x278e <csp_buffer_free_isr+0x64>
    2748:	f9 01       	movw	r30, r18
    274a:	42 81       	ldd	r20, Z+2	; 0x02
    274c:	53 81       	ldd	r21, Z+3	; 0x03
    274e:	24 17       	cp	r18, r20
    2750:	35 07       	cpc	r19, r21
    2752:	e9 f4       	brne	.+58     	; 0x278e <csp_buffer_free_isr+0x64>
    2754:	f9 01       	movw	r30, r18
    2756:	20 81       	ld	r18, Z
    2758:	31 81       	ldd	r19, Z+1	; 0x01
    275a:	21 15       	cp	r18, r1
    275c:	31 05       	cpc	r19, r1
    275e:	b9 f0       	breq	.+46     	; 0x278e <csp_buffer_free_isr+0x64>
    2760:	22 30       	cpi	r18, 0x02	; 2
    2762:	31 05       	cpc	r19, r1
    2764:	28 f0       	brcs	.+10     	; 0x2770 <csp_buffer_free_isr+0x46>
    2766:	21 50       	subi	r18, 0x01	; 1
    2768:	31 09       	sbc	r19, r1
    276a:	20 83       	st	Z, r18
    276c:	31 83       	std	Z+1, r19	; 0x01
    276e:	0f c0       	rjmp	.+30     	; 0x278e <csp_buffer_free_isr+0x64>
    2770:	fc 01       	movw	r30, r24
    2772:	34 97       	sbiw	r30, 0x04	; 4
    2774:	10 82       	st	Z, r1
    2776:	11 82       	std	Z+1, r1	; 0x01
    2778:	ae 01       	movw	r20, r28
    277a:	4f 5f       	subi	r20, 0xFF	; 255
    277c:	5f 4f       	sbci	r21, 0xFF	; 255
    277e:	be 01       	movw	r22, r28
    2780:	6e 5f       	subi	r22, 0xFE	; 254
    2782:	7f 4f       	sbci	r23, 0xFF	; 255
    2784:	80 91 d5 3c 	lds	r24, 0x3CD5
    2788:	90 91 d6 3c 	lds	r25, 0x3CD6
    278c:	fe dd       	rcall	.-1028   	; 0x238a <csp_queue_enqueue_isr>
    278e:	23 96       	adiw	r28, 0x03	; 3
    2790:	cd bf       	out	0x3d, r28	; 61
    2792:	de bf       	out	0x3e, r29	; 62
    2794:	df 91       	pop	r29
    2796:	cf 91       	pop	r28
    2798:	08 95       	ret

0000279a <csp_buffer_free>:
    279a:	cf 93       	push	r28
    279c:	df 93       	push	r29
    279e:	1f 92       	push	r1
    27a0:	1f 92       	push	r1
    27a2:	cd b7       	in	r28, 0x3d	; 61
    27a4:	de b7       	in	r29, 0x3e	; 62
    27a6:	00 97       	sbiw	r24, 0x00	; 0
    27a8:	51 f1       	breq	.+84     	; 0x27fe <csp_buffer_free+0x64>
    27aa:	9c 01       	movw	r18, r24
    27ac:	24 50       	subi	r18, 0x04	; 4
    27ae:	31 09       	sbc	r19, r1
    27b0:	29 83       	std	Y+1, r18	; 0x01
    27b2:	3a 83       	std	Y+2, r19	; 0x02
    27b4:	20 fd       	sbrc	r18, 0
    27b6:	23 c0       	rjmp	.+70     	; 0x27fe <csp_buffer_free+0x64>
    27b8:	f9 01       	movw	r30, r18
    27ba:	42 81       	ldd	r20, Z+2	; 0x02
    27bc:	53 81       	ldd	r21, Z+3	; 0x03
    27be:	24 17       	cp	r18, r20
    27c0:	35 07       	cpc	r19, r21
    27c2:	e9 f4       	brne	.+58     	; 0x27fe <csp_buffer_free+0x64>
    27c4:	f9 01       	movw	r30, r18
    27c6:	20 81       	ld	r18, Z
    27c8:	31 81       	ldd	r19, Z+1	; 0x01
    27ca:	21 15       	cp	r18, r1
    27cc:	31 05       	cpc	r19, r1
    27ce:	b9 f0       	breq	.+46     	; 0x27fe <csp_buffer_free+0x64>
    27d0:	22 30       	cpi	r18, 0x02	; 2
    27d2:	31 05       	cpc	r19, r1
    27d4:	28 f0       	brcs	.+10     	; 0x27e0 <csp_buffer_free+0x46>
    27d6:	21 50       	subi	r18, 0x01	; 1
    27d8:	31 09       	sbc	r19, r1
    27da:	20 83       	st	Z, r18
    27dc:	31 83       	std	Z+1, r19	; 0x01
    27de:	0f c0       	rjmp	.+30     	; 0x27fe <csp_buffer_free+0x64>
    27e0:	fc 01       	movw	r30, r24
    27e2:	34 97       	sbiw	r30, 0x04	; 4
    27e4:	10 82       	st	Z, r1
    27e6:	11 82       	std	Z+1, r1	; 0x01
    27e8:	20 e0       	ldi	r18, 0x00	; 0
    27ea:	30 e0       	ldi	r19, 0x00	; 0
    27ec:	a9 01       	movw	r20, r18
    27ee:	be 01       	movw	r22, r28
    27f0:	6f 5f       	subi	r22, 0xFF	; 255
    27f2:	7f 4f       	sbci	r23, 0xFF	; 255
    27f4:	80 91 d5 3c 	lds	r24, 0x3CD5
    27f8:	90 91 d6 3c 	lds	r25, 0x3CD6
    27fc:	bb dd       	rcall	.-1162   	; 0x2374 <csp_queue_enqueue>
    27fe:	0f 90       	pop	r0
    2800:	0f 90       	pop	r0
    2802:	df 91       	pop	r29
    2804:	cf 91       	pop	r28
    2806:	08 95       	ret

00002808 <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    2808:	80 91 d5 3c 	lds	r24, 0x3CD5
    280c:	90 91 d6 3c 	lds	r25, 0x3CD6
    2810:	ce cd       	rjmp	.-1124   	; 0x23ae <csp_queue_size>
}
    2812:	08 95       	ret

00002814 <csp_conn_enqueue_packet>:
#endif

	/* We have a successful connection */
	return conn;

}
    2814:	cf 93       	push	r28
    2816:	df 93       	push	r29
    2818:	1f 92       	push	r1
    281a:	1f 92       	push	r1
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	69 83       	std	Y+1, r22	; 0x01
    2822:	7a 83       	std	Y+2, r23	; 0x02
    2824:	00 97       	sbiw	r24, 0x00	; 0
    2826:	a9 f0       	breq	.+42     	; 0x2852 <csp_conn_enqueue_packet+0x3e>
    2828:	20 e0       	ldi	r18, 0x00	; 0
    282a:	30 e0       	ldi	r19, 0x00	; 0
    282c:	a9 01       	movw	r20, r18
    282e:	be 01       	movw	r22, r28
    2830:	6f 5f       	subi	r22, 0xFF	; 255
    2832:	7f 4f       	sbci	r23, 0xFF	; 255
    2834:	fc 01       	movw	r30, r24
    2836:	84 85       	ldd	r24, Z+12	; 0x0c
    2838:	95 85       	ldd	r25, Z+13	; 0x0d
    283a:	9c dd       	rcall	.-1224   	; 0x2374 <csp_queue_enqueue>
    283c:	21 e0       	ldi	r18, 0x01	; 1
    283e:	30 e0       	ldi	r19, 0x00	; 0
    2840:	01 97       	sbiw	r24, 0x01	; 1
    2842:	11 f4       	brne	.+4      	; 0x2848 <csp_conn_enqueue_packet+0x34>
    2844:	20 e0       	ldi	r18, 0x00	; 0
    2846:	30 e0       	ldi	r19, 0x00	; 0
    2848:	88 27       	eor	r24, r24
    284a:	99 27       	eor	r25, r25
    284c:	82 1b       	sub	r24, r18
    284e:	93 0b       	sbc	r25, r19
    2850:	02 c0       	rjmp	.+4      	; 0x2856 <csp_conn_enqueue_packet+0x42>
    2852:	8e ef       	ldi	r24, 0xFE	; 254
    2854:	9f ef       	ldi	r25, 0xFF	; 255
    2856:	0f 90       	pop	r0
    2858:	0f 90       	pop	r0
    285a:	df 91       	pop	r29
    285c:	cf 91       	pop	r28
    285e:	08 95       	ret

00002860 <csp_conn_init>:
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	cf 93       	push	r28
    2866:	df 93       	push	r29
    2868:	81 de       	rcall	.-766    	; 0x256c <csp_get_ms>
    286a:	cb 01       	movw	r24, r22
    286c:	0e 94 41 2b 	call	0x5682	; 0x5682 <srand>
    2870:	0e 94 3e 2b 	call	0x567c	; 0x567c <rand>
    2874:	8f 71       	andi	r24, 0x1F	; 31
    2876:	90 78       	andi	r25, 0x80	; 128
    2878:	99 23       	and	r25, r25
    287a:	24 f4       	brge	.+8      	; 0x2884 <csp_conn_init+0x24>
    287c:	01 97       	sbiw	r24, 0x01	; 1
    287e:	80 6e       	ori	r24, 0xE0	; 224
    2880:	9f 6f       	ori	r25, 0xFF	; 255
    2882:	01 96       	adiw	r24, 0x01	; 1
    2884:	80 5e       	subi	r24, 0xE0	; 224
    2886:	80 93 da 3c 	sts	0x3CDA, r24
    288a:	88 ed       	ldi	r24, 0xD8	; 216
    288c:	9c e3       	ldi	r25, 0x3C	; 60
    288e:	a4 dd       	rcall	.-1208   	; 0x23d8 <csp_bin_sem_create>
    2890:	01 97       	sbiw	r24, 0x01	; 1
    2892:	31 f5       	brne	.+76     	; 0x28e0 <csp_conn_init+0x80>
    2894:	cf ed       	ldi	r28, 0xDF	; 223
    2896:	dc e3       	ldi	r29, 0x3C	; 60
    2898:	0f ec       	ldi	r16, 0xCF	; 207
    289a:	1d e3       	ldi	r17, 0x3D	; 61
    289c:	04 c0       	rjmp	.+8      	; 0x28a6 <csp_conn_init+0x46>
    289e:	68 96       	adiw	r28, 0x18	; 24
    28a0:	c0 17       	cp	r28, r16
    28a2:	d1 07       	cpc	r29, r17
    28a4:	79 f0       	breq	.+30     	; 0x28c4 <csp_conn_init+0x64>
    28a6:	62 e0       	ldi	r22, 0x02	; 2
    28a8:	70 e0       	ldi	r23, 0x00	; 0
    28aa:	8a e0       	ldi	r24, 0x0A	; 10
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	5f dd       	rcall	.-1346   	; 0x236e <csp_queue_create>
    28b0:	8a 87       	std	Y+10, r24	; 0x0a
    28b2:	9b 87       	std	Y+11, r25	; 0x0b
    28b4:	fe 01       	movw	r30, r28
    28b6:	31 97       	sbiw	r30, 0x01	; 1
    28b8:	10 82       	st	Z, r1
    28ba:	ce 01       	movw	r24, r28
    28bc:	7c dd       	rcall	.-1288   	; 0x23b6 <csp_mutex_create>
    28be:	01 97       	sbiw	r24, 0x01	; 1
    28c0:	71 f3       	breq	.-36     	; 0x289e <csp_conn_init+0x3e>
    28c2:	11 c0       	rjmp	.+34     	; 0x28e6 <csp_conn_init+0x86>
    28c4:	8b ed       	ldi	r24, 0xDB	; 219
    28c6:	9c e3       	ldi	r25, 0x3C	; 60
    28c8:	87 dd       	rcall	.-1266   	; 0x23d8 <csp_bin_sem_create>
    28ca:	21 e0       	ldi	r18, 0x01	; 1
    28cc:	30 e0       	ldi	r19, 0x00	; 0
    28ce:	01 97       	sbiw	r24, 0x01	; 1
    28d0:	11 f4       	brne	.+4      	; 0x28d6 <csp_conn_init+0x76>
    28d2:	20 e0       	ldi	r18, 0x00	; 0
    28d4:	30 e0       	ldi	r19, 0x00	; 0
    28d6:	88 27       	eor	r24, r24
    28d8:	99 27       	eor	r25, r25
    28da:	82 1b       	sub	r24, r18
    28dc:	93 0b       	sbc	r25, r19
    28de:	05 c0       	rjmp	.+10     	; 0x28ea <csp_conn_init+0x8a>
    28e0:	8f ef       	ldi	r24, 0xFF	; 255
    28e2:	9f ef       	ldi	r25, 0xFF	; 255
    28e4:	02 c0       	rjmp	.+4      	; 0x28ea <csp_conn_init+0x8a>
    28e6:	8f ef       	ldi	r24, 0xFF	; 255
    28e8:	9f ef       	ldi	r25, 0xFF	; 255
    28ea:	df 91       	pop	r29
    28ec:	cf 91       	pop	r28
    28ee:	1f 91       	pop	r17
    28f0:	0f 91       	pop	r16
    28f2:	08 95       	ret

000028f4 <csp_conn_find>:
    28f4:	cf 92       	push	r12
    28f6:	df 92       	push	r13
    28f8:	ef 92       	push	r14
    28fa:	ff 92       	push	r15
    28fc:	0f 93       	push	r16
    28fe:	1f 93       	push	r17
    2900:	cf 93       	push	r28
    2902:	df 93       	push	r29
    2904:	ed ed       	ldi	r30, 0xDD	; 221
    2906:	fc e3       	ldi	r31, 0x3C	; 60
    2908:	0d ec       	ldi	r16, 0xCD	; 205
    290a:	1d e3       	ldi	r17, 0x3D	; 61
    290c:	ef 01       	movw	r28, r30
    290e:	a1 81       	ldd	r26, Z+1	; 0x01
    2910:	aa 23       	and	r26, r26
    2912:	99 f0       	breq	.+38     	; 0x293a <csp_conn_find+0x46>
    2914:	a0 81       	ld	r26, Z
    2916:	a1 11       	cpse	r26, r1
    2918:	10 c0       	rjmp	.+32     	; 0x293a <csp_conn_find+0x46>
    291a:	c4 80       	ldd	r12, Z+4	; 0x04
    291c:	d5 80       	ldd	r13, Z+5	; 0x05
    291e:	e6 80       	ldd	r14, Z+6	; 0x06
    2920:	f7 80       	ldd	r15, Z+7	; 0x07
    2922:	c6 26       	eor	r12, r22
    2924:	d7 26       	eor	r13, r23
    2926:	e8 26       	eor	r14, r24
    2928:	f9 26       	eor	r15, r25
    292a:	c2 22       	and	r12, r18
    292c:	d3 22       	and	r13, r19
    292e:	e4 22       	and	r14, r20
    2930:	f5 22       	and	r15, r21
    2932:	cd 28       	or	r12, r13
    2934:	ce 28       	or	r12, r14
    2936:	cf 28       	or	r12, r15
    2938:	29 f0       	breq	.+10     	; 0x2944 <csp_conn_find+0x50>
    293a:	78 96       	adiw	r30, 0x18	; 24
    293c:	e0 17       	cp	r30, r16
    293e:	f1 07       	cpc	r31, r17
    2940:	29 f7       	brne	.-54     	; 0x290c <csp_conn_find+0x18>
    2942:	03 c0       	rjmp	.+6      	; 0x294a <csp_conn_find+0x56>
    2944:	8e 2f       	mov	r24, r30
    2946:	9d 2f       	mov	r25, r29
    2948:	02 c0       	rjmp	.+4      	; 0x294e <csp_conn_find+0x5a>
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	df 91       	pop	r29
    2950:	cf 91       	pop	r28
    2952:	1f 91       	pop	r17
    2954:	0f 91       	pop	r16
    2956:	ff 90       	pop	r15
    2958:	ef 90       	pop	r14
    295a:	df 90       	pop	r13
    295c:	cf 90       	pop	r12
    295e:	08 95       	ret

00002960 <csp_conn_flush_rx_queue>:
    2960:	0f 93       	push	r16
    2962:	1f 93       	push	r17
    2964:	cf 93       	push	r28
    2966:	df 93       	push	r29
    2968:	1f 92       	push	r1
    296a:	1f 92       	push	r1
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
    2970:	8c 01       	movw	r16, r24
    2972:	05 c0       	rjmp	.+10     	; 0x297e <csp_conn_flush_rx_queue+0x1e>
    2974:	89 81       	ldd	r24, Y+1	; 0x01
    2976:	9a 81       	ldd	r25, Y+2	; 0x02
    2978:	00 97       	sbiw	r24, 0x00	; 0
    297a:	09 f0       	breq	.+2      	; 0x297e <csp_conn_flush_rx_queue+0x1e>
    297c:	0e df       	rcall	.-484    	; 0x279a <csp_buffer_free>
    297e:	20 e0       	ldi	r18, 0x00	; 0
    2980:	30 e0       	ldi	r19, 0x00	; 0
    2982:	a9 01       	movw	r20, r18
    2984:	be 01       	movw	r22, r28
    2986:	6f 5f       	subi	r22, 0xFF	; 255
    2988:	7f 4f       	sbci	r23, 0xFF	; 255
    298a:	f8 01       	movw	r30, r16
    298c:	84 85       	ldd	r24, Z+12	; 0x0c
    298e:	95 85       	ldd	r25, Z+13	; 0x0d
    2990:	03 dd       	rcall	.-1530   	; 0x2398 <csp_queue_dequeue>
    2992:	01 97       	sbiw	r24, 0x01	; 1
    2994:	79 f3       	breq	.-34     	; 0x2974 <csp_conn_flush_rx_queue+0x14>
    2996:	80 e0       	ldi	r24, 0x00	; 0
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	0f 90       	pop	r0
    299c:	0f 90       	pop	r0
    299e:	df 91       	pop	r29
    29a0:	cf 91       	pop	r28
    29a2:	1f 91       	pop	r17
    29a4:	0f 91       	pop	r16
    29a6:	08 95       	ret

000029a8 <csp_conn_allocate>:
    29a8:	1f 93       	push	r17
    29aa:	cf 93       	push	r28
    29ac:	df 93       	push	r29
    29ae:	18 2f       	mov	r17, r24
    29b0:	44 e6       	ldi	r20, 0x64	; 100
    29b2:	50 e0       	ldi	r21, 0x00	; 0
    29b4:	60 e0       	ldi	r22, 0x00	; 0
    29b6:	70 e0       	ldi	r23, 0x00	; 0
    29b8:	8b ed       	ldi	r24, 0xDB	; 219
    29ba:	9c e3       	ldi	r25, 0x3C	; 60
    29bc:	24 dd       	rcall	.-1464   	; 0x2406 <csp_bin_sem_wait>
    29be:	01 97       	sbiw	r24, 0x01	; 1
    29c0:	09 f0       	breq	.+2      	; 0x29c4 <csp_conn_allocate+0x1c>
    29c2:	47 c0       	rjmp	.+142    	; 0x2a52 <csp_conn_allocate+0xaa>
    29c4:	80 91 d7 3c 	lds	r24, 0x3CD7
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	01 96       	adiw	r24, 0x01	; 1
    29cc:	6a e0       	ldi	r22, 0x0A	; 10
    29ce:	70 e0       	ldi	r23, 0x00	; 0
    29d0:	0e 94 b9 2a 	call	0x5572	; 0x5572 <__divmodhi4>
    29d4:	ec 01       	movw	r28, r24
    29d6:	cc 0f       	add	r28, r28
    29d8:	dd 1f       	adc	r29, r29
    29da:	c8 0f       	add	r28, r24
    29dc:	d9 1f       	adc	r29, r25
    29de:	cc 0f       	add	r28, r28
    29e0:	dd 1f       	adc	r29, r29
    29e2:	cc 0f       	add	r28, r28
    29e4:	dd 1f       	adc	r29, r29
    29e6:	cc 0f       	add	r28, r28
    29e8:	dd 1f       	adc	r29, r29
    29ea:	c3 52       	subi	r28, 0x23	; 35
    29ec:	d3 4c       	sbci	r29, 0xC3	; 195
    29ee:	49 81       	ldd	r20, Y+1	; 0x01
    29f0:	41 11       	cpse	r20, r1
    29f2:	32 c0       	rjmp	.+100    	; 0x2a58 <csp_conn_allocate+0xb0>
    29f4:	21 c0       	rjmp	.+66     	; 0x2a38 <csp_conn_allocate+0x90>
    29f6:	ec 01       	movw	r28, r24
    29f8:	cc 0f       	add	r28, r28
    29fa:	dd 1f       	adc	r29, r29
    29fc:	c8 0f       	add	r28, r24
    29fe:	d9 1f       	adc	r29, r25
    2a00:	cc 0f       	add	r28, r28
    2a02:	dd 1f       	adc	r29, r29
    2a04:	cc 0f       	add	r28, r28
    2a06:	dd 1f       	adc	r29, r29
    2a08:	cc 0f       	add	r28, r28
    2a0a:	dd 1f       	adc	r29, r29
    2a0c:	c3 52       	subi	r28, 0x23	; 35
    2a0e:	d3 4c       	sbci	r29, 0xC3	; 195
    2a10:	49 81       	ldd	r20, Y+1	; 0x01
    2a12:	44 23       	and	r20, r20
    2a14:	89 f0       	breq	.+34     	; 0x2a38 <csp_conn_allocate+0x90>
    2a16:	01 96       	adiw	r24, 0x01	; 1
    2a18:	bf 01       	movw	r22, r30
    2a1a:	0e 94 b9 2a 	call	0x5572	; 0x5572 <__divmodhi4>
    2a1e:	21 50       	subi	r18, 0x01	; 1
    2a20:	31 09       	sbc	r19, r1
    2a22:	21 15       	cp	r18, r1
    2a24:	31 05       	cpc	r19, r1
    2a26:	39 f7       	brne	.-50     	; 0x29f6 <csp_conn_allocate+0x4e>
    2a28:	41 30       	cpi	r20, 0x01	; 1
    2a2a:	31 f4       	brne	.+12     	; 0x2a38 <csp_conn_allocate+0x90>
    2a2c:	8b ed       	ldi	r24, 0xDB	; 219
    2a2e:	9c e3       	ldi	r25, 0x3C	; 60
    2a30:	fa dc       	rcall	.-1548   	; 0x2426 <csp_bin_sem_post>
    2a32:	80 e0       	ldi	r24, 0x00	; 0
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	1a c0       	rjmp	.+52     	; 0x2a6c <csp_conn_allocate+0xc4>
    2a38:	91 e0       	ldi	r25, 0x01	; 1
    2a3a:	99 83       	std	Y+1, r25	; 0x01
    2a3c:	1e 86       	std	Y+14, r1	; 0x0e
    2a3e:	1f 86       	std	Y+15, r1	; 0x0f
    2a40:	18 83       	st	Y, r17
    2a42:	80 93 d7 3c 	sts	0x3CD7, r24
    2a46:	8b ed       	ldi	r24, 0xDB	; 219
    2a48:	9c e3       	ldi	r25, 0x3C	; 60
    2a4a:	ed dc       	rcall	.-1574   	; 0x2426 <csp_bin_sem_post>
    2a4c:	8c 2f       	mov	r24, r28
    2a4e:	9d 2f       	mov	r25, r29
    2a50:	0d c0       	rjmp	.+26     	; 0x2a6c <csp_conn_allocate+0xc4>
    2a52:	80 e0       	ldi	r24, 0x00	; 0
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	0a c0       	rjmp	.+20     	; 0x2a6c <csp_conn_allocate+0xc4>
    2a58:	01 96       	adiw	r24, 0x01	; 1
    2a5a:	6a e0       	ldi	r22, 0x0A	; 10
    2a5c:	70 e0       	ldi	r23, 0x00	; 0
    2a5e:	0e 94 b9 2a 	call	0x5572	; 0x5572 <__divmodhi4>
    2a62:	29 e0       	ldi	r18, 0x09	; 9
    2a64:	30 e0       	ldi	r19, 0x00	; 0
    2a66:	ea e0       	ldi	r30, 0x0A	; 10
    2a68:	f0 e0       	ldi	r31, 0x00	; 0
    2a6a:	c5 cf       	rjmp	.-118    	; 0x29f6 <csp_conn_allocate+0x4e>
    2a6c:	df 91       	pop	r29
    2a6e:	cf 91       	pop	r28
    2a70:	1f 91       	pop	r17
    2a72:	08 95       	ret

00002a74 <csp_conn_new>:
    2a74:	8f 92       	push	r8
    2a76:	9f 92       	push	r9
    2a78:	af 92       	push	r10
    2a7a:	bf 92       	push	r11
    2a7c:	cf 92       	push	r12
    2a7e:	df 92       	push	r13
    2a80:	ef 92       	push	r14
    2a82:	ff 92       	push	r15
    2a84:	cf 93       	push	r28
    2a86:	df 93       	push	r29
    2a88:	4b 01       	movw	r8, r22
    2a8a:	5c 01       	movw	r10, r24
    2a8c:	69 01       	movw	r12, r18
    2a8e:	7a 01       	movw	r14, r20
    2a90:	80 e0       	ldi	r24, 0x00	; 0
    2a92:	8a df       	rcall	.-236    	; 0x29a8 <csp_conn_allocate>
    2a94:	ec 01       	movw	r28, r24
    2a96:	00 97       	sbiw	r24, 0x00	; 0
    2a98:	79 f0       	breq	.+30     	; 0x2ab8 <csp_conn_new+0x44>
    2a9a:	8c 82       	std	Y+4, r8	; 0x04
    2a9c:	9d 82       	std	Y+5, r9	; 0x05
    2a9e:	ae 82       	std	Y+6, r10	; 0x06
    2aa0:	bf 82       	std	Y+7, r11	; 0x07
    2aa2:	c8 86       	std	Y+8, r12	; 0x08
    2aa4:	d9 86       	std	Y+9, r13	; 0x09
    2aa6:	ea 86       	std	Y+10, r14	; 0x0a
    2aa8:	fb 86       	std	Y+11, r15	; 0x0b
    2aaa:	60 dd       	rcall	.-1344   	; 0x256c <csp_get_ms>
    2aac:	68 8b       	std	Y+16, r22	; 0x10
    2aae:	79 8b       	std	Y+17, r23	; 0x11
    2ab0:	8a 8b       	std	Y+18, r24	; 0x12
    2ab2:	9b 8b       	std	Y+19, r25	; 0x13
    2ab4:	ce 01       	movw	r24, r28
    2ab6:	54 df       	rcall	.-344    	; 0x2960 <csp_conn_flush_rx_queue>
    2ab8:	ce 01       	movw	r24, r28
    2aba:	df 91       	pop	r29
    2abc:	cf 91       	pop	r28
    2abe:	ff 90       	pop	r15
    2ac0:	ef 90       	pop	r14
    2ac2:	df 90       	pop	r13
    2ac4:	cf 90       	pop	r12
    2ac6:	bf 90       	pop	r11
    2ac8:	af 90       	pop	r10
    2aca:	9f 90       	pop	r9
    2acc:	8f 90       	pop	r8
    2ace:	08 95       	ret

00002ad0 <csp_close>:
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	ec 01       	movw	r28, r24
    2ad6:	00 97       	sbiw	r24, 0x00	; 0
    2ad8:	a9 f0       	breq	.+42     	; 0x2b04 <csp_close+0x34>
    2ada:	89 81       	ldd	r24, Y+1	; 0x01
    2adc:	88 23       	and	r24, r24
    2ade:	a9 f0       	breq	.+42     	; 0x2b0a <csp_close+0x3a>
    2ae0:	44 e6       	ldi	r20, 0x64	; 100
    2ae2:	50 e0       	ldi	r21, 0x00	; 0
    2ae4:	60 e0       	ldi	r22, 0x00	; 0
    2ae6:	70 e0       	ldi	r23, 0x00	; 0
    2ae8:	8b ed       	ldi	r24, 0xDB	; 219
    2aea:	9c e3       	ldi	r25, 0x3C	; 60
    2aec:	8c dc       	rcall	.-1768   	; 0x2406 <csp_bin_sem_wait>
    2aee:	01 97       	sbiw	r24, 0x01	; 1
    2af0:	79 f4       	brne	.+30     	; 0x2b10 <csp_close+0x40>
    2af2:	19 82       	std	Y+1, r1	; 0x01
    2af4:	ce 01       	movw	r24, r28
    2af6:	34 df       	rcall	.-408    	; 0x2960 <csp_conn_flush_rx_queue>
    2af8:	8b ed       	ldi	r24, 0xDB	; 219
    2afa:	9c e3       	ldi	r25, 0x3C	; 60
    2afc:	94 dc       	rcall	.-1752   	; 0x2426 <csp_bin_sem_post>
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	90 e0       	ldi	r25, 0x00	; 0
    2b02:	08 c0       	rjmp	.+16     	; 0x2b14 <csp_close+0x44>
    2b04:	8e ef       	ldi	r24, 0xFE	; 254
    2b06:	9f ef       	ldi	r25, 0xFF	; 255
    2b08:	05 c0       	rjmp	.+10     	; 0x2b14 <csp_close+0x44>
    2b0a:	80 e0       	ldi	r24, 0x00	; 0
    2b0c:	90 e0       	ldi	r25, 0x00	; 0
    2b0e:	02 c0       	rjmp	.+4      	; 0x2b14 <csp_close+0x44>
    2b10:	8d ef       	ldi	r24, 0xFD	; 253
    2b12:	9f ef       	ldi	r25, 0xFF	; 255
    2b14:	df 91       	pop	r29
    2b16:	cf 91       	pop	r28
    2b18:	08 95       	ret

00002b1a <csp_conn_dport>:

inline int csp_conn_dport(csp_conn_t * conn) {
    2b1a:	fc 01       	movw	r30, r24

	return conn->idin.dport;
    2b1c:	95 81       	ldd	r25, Z+5	; 0x05
    2b1e:	92 95       	swap	r25
    2b20:	96 95       	lsr	r25
    2b22:	96 95       	lsr	r25
    2b24:	93 70       	andi	r25, 0x03	; 3
    2b26:	86 81       	ldd	r24, Z+6	; 0x06
    2b28:	8f 70       	andi	r24, 0x0F	; 15
    2b2a:	88 0f       	add	r24, r24
    2b2c:	88 0f       	add	r24, r24
    2b2e:	89 2b       	or	r24, r25

}
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	08 95       	ret

00002b34 <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    2b34:	8f 92       	push	r8
    2b36:	9f 92       	push	r9
    2b38:	af 92       	push	r10
    2b3a:	bf 92       	push	r11
    2b3c:	cf 92       	push	r12
    2b3e:	df 92       	push	r13
    2b40:	ef 92       	push	r14
    2b42:	ff 92       	push	r15
    2b44:	0f 93       	push	r16
    2b46:	1f 93       	push	r17
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    2b48:	8a 01       	movw	r16, r20
    2b4a:	9b 01       	movw	r18, r22
    2b4c:	01 50       	subi	r16, 0x01	; 1
    2b4e:	11 09       	sbc	r17, r1
    2b50:	21 09       	sbc	r18, r1
    2b52:	31 09       	sbc	r19, r1
    2b54:	45 2b       	or	r20, r21
    2b56:	46 2b       	or	r20, r22
    2b58:	47 2b       	or	r20, r23
    2b5a:	49 f1       	breq	.+82     	; 0x2bae <csp_crc32_memory+0x7a>
    2b5c:	a8 2f       	mov	r26, r24
    2b5e:	b9 2f       	mov	r27, r25
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    2b60:	88 24       	eor	r8, r8
    2b62:	8a 94       	dec	r8
    2b64:	98 2c       	mov	r9, r8
    2b66:	54 01       	movw	r10, r8
   while (length--)
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    2b68:	4d 91       	ld	r20, X+
    2b6a:	75 01       	movw	r14, r10
    2b6c:	64 01       	movw	r12, r8
    2b6e:	c4 26       	eor	r12, r20
    2b70:	dd 24       	eor	r13, r13
    2b72:	ee 24       	eor	r14, r14
    2b74:	ff 24       	eor	r15, r15
    2b76:	c6 01       	movw	r24, r12
    2b78:	88 0f       	add	r24, r24
    2b7a:	99 1f       	adc	r25, r25
    2b7c:	88 0f       	add	r24, r24
    2b7e:	99 1f       	adc	r25, r25
    2b80:	fc 01       	movw	r30, r24
    2b82:	e6 5f       	subi	r30, 0xF6	; 246
    2b84:	fd 4f       	sbci	r31, 0xFD	; 253
    2b86:	c5 90       	lpm	r12, Z+
    2b88:	d5 90       	lpm	r13, Z+
    2b8a:	e5 90       	lpm	r14, Z+
    2b8c:	f4 90       	lpm	r15, Z
    2b8e:	77 27       	eor	r23, r23
    2b90:	6b 2d       	mov	r22, r11
    2b92:	5a 2d       	mov	r21, r10
    2b94:	49 2d       	mov	r20, r9
    2b96:	4a 01       	movw	r8, r20
    2b98:	5b 01       	movw	r10, r22
    2b9a:	8c 24       	eor	r8, r12
    2b9c:	9d 24       	eor	r9, r13
    2b9e:	ae 24       	eor	r10, r14
    2ba0:	bf 24       	eor	r11, r15

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    2ba2:	01 50       	subi	r16, 0x01	; 1
    2ba4:	11 09       	sbc	r17, r1
    2ba6:	21 09       	sbc	r18, r1
    2ba8:	31 09       	sbc	r19, r1
    2baa:	f0 f6       	brcc	.-68     	; 0x2b68 <csp_crc32_memory+0x34>
    2bac:	04 c0       	rjmp	.+8      	; 0x2bb6 <csp_crc32_memory+0x82>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    2bae:	88 24       	eor	r8, r8
    2bb0:	8a 94       	dec	r8
    2bb2:	98 2c       	mov	r9, r8
    2bb4:	54 01       	movw	r10, r8
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    2bb6:	c5 01       	movw	r24, r10
    2bb8:	b4 01       	movw	r22, r8
    2bba:	60 95       	com	r22
    2bbc:	70 95       	com	r23
    2bbe:	80 95       	com	r24
    2bc0:	90 95       	com	r25
}
    2bc2:	1f 91       	pop	r17
    2bc4:	0f 91       	pop	r16
    2bc6:	ff 90       	pop	r15
    2bc8:	ef 90       	pop	r14
    2bca:	df 90       	pop	r13
    2bcc:	cf 90       	pop	r12
    2bce:	bf 90       	pop	r11
    2bd0:	af 90       	pop	r10
    2bd2:	9f 90       	pop	r9
    2bd4:	8f 90       	pop	r8
    2bd6:	08 95       	ret

00002bd8 <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet) {
    2bd8:	cf 93       	push	r28
    2bda:	df 93       	push	r29
    2bdc:	ec 01       	movw	r28, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    2bde:	00 97       	sbiw	r24, 0x00	; 0
    2be0:	b9 f0       	breq	.+46     	; 0x2c10 <csp_crc32_append+0x38>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length);
    2be2:	48 85       	ldd	r20, Y+8	; 0x08
    2be4:	59 85       	ldd	r21, Y+9	; 0x09
    2be6:	60 e0       	ldi	r22, 0x00	; 0
    2be8:	70 e0       	ldi	r23, 0x00	; 0
    2bea:	0e 96       	adiw	r24, 0x0e	; 14
    2bec:	a3 df       	rcall	.-186    	; 0x2b34 <csp_crc32_memory>
	crc = csp_hton32(crc);
    2bee:	5e d0       	rcall	.+188    	; 0x2cac <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    2bf0:	e8 85       	ldd	r30, Y+8	; 0x08
    2bf2:	f9 85       	ldd	r31, Y+9	; 0x09
    2bf4:	ec 0f       	add	r30, r28
    2bf6:	fd 1f       	adc	r31, r29
    2bf8:	66 87       	std	Z+14, r22	; 0x0e
    2bfa:	77 87       	std	Z+15, r23	; 0x0f
    2bfc:	80 8b       	std	Z+16, r24	; 0x10
    2bfe:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    2c00:	88 85       	ldd	r24, Y+8	; 0x08
    2c02:	99 85       	ldd	r25, Y+9	; 0x09
    2c04:	04 96       	adiw	r24, 0x04	; 4
    2c06:	88 87       	std	Y+8, r24	; 0x08
    2c08:	99 87       	std	Y+9, r25	; 0x09

	return CSP_ERR_NONE;
    2c0a:	80 e0       	ldi	r24, 0x00	; 0
    2c0c:	90 e0       	ldi	r25, 0x00	; 0
    2c0e:	02 c0       	rjmp	.+4      	; 0x2c14 <csp_crc32_append+0x3c>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    2c10:	8e ef       	ldi	r24, 0xFE	; 254
    2c12:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    2c14:	df 91       	pop	r29
    2c16:	cf 91       	pop	r28
    2c18:	08 95       	ret

00002c1a <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet) {
    2c1a:	ef 92       	push	r14
    2c1c:	ff 92       	push	r15
    2c1e:	0f 93       	push	r16
    2c20:	1f 93       	push	r17
    2c22:	cf 93       	push	r28
    2c24:	df 93       	push	r29
    2c26:	00 d0       	rcall	.+0      	; 0x2c28 <csp_crc32_verify+0xe>
    2c28:	1f 92       	push	r1
    2c2a:	cd b7       	in	r28, 0x3d	; 61
    2c2c:	de b7       	in	r29, 0x3e	; 62
    2c2e:	8c 01       	movw	r16, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    2c30:	00 97       	sbiw	r24, 0x00	; 0
    2c32:	51 f1       	breq	.+84     	; 0x2c88 <csp_crc32_verify+0x6e>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    2c34:	fc 01       	movw	r30, r24
    2c36:	80 85       	ldd	r24, Z+8	; 0x08
    2c38:	91 85       	ldd	r25, Z+9	; 0x09
    2c3a:	84 30       	cpi	r24, 0x04	; 4
    2c3c:	91 05       	cpc	r25, r1
    2c3e:	38 f1       	brcs	.+78     	; 0x2c8e <csp_crc32_verify+0x74>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    2c40:	ac 01       	movw	r20, r24
    2c42:	44 50       	subi	r20, 0x04	; 4
    2c44:	51 09       	sbc	r21, r1
    2c46:	60 e0       	ldi	r22, 0x00	; 0
    2c48:	70 e0       	ldi	r23, 0x00	; 0
    2c4a:	c8 01       	movw	r24, r16
    2c4c:	0e 96       	adiw	r24, 0x0e	; 14
    2c4e:	72 df       	rcall	.-284    	; 0x2b34 <csp_crc32_memory>
	crc = csp_hton32(crc);
    2c50:	2d d0       	rcall	.+90     	; 0x2cac <csp_hton32>
    2c52:	69 83       	std	Y+1, r22	; 0x01
    2c54:	7a 83       	std	Y+2, r23	; 0x02
    2c56:	8b 83       	std	Y+3, r24	; 0x03
    2c58:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    2c5a:	f8 01       	movw	r30, r16
    2c5c:	80 85       	ldd	r24, Z+8	; 0x08
    2c5e:	91 85       	ldd	r25, Z+9	; 0x09
    2c60:	7c 01       	movw	r14, r24
    2c62:	f4 e0       	ldi	r31, 0x04	; 4
    2c64:	ef 1a       	sub	r14, r31
    2c66:	f1 08       	sbc	r15, r1
    2c68:	0a 96       	adiw	r24, 0x0a	; 10
    2c6a:	44 e0       	ldi	r20, 0x04	; 4
    2c6c:	50 e0       	ldi	r21, 0x00	; 0
    2c6e:	be 01       	movw	r22, r28
    2c70:	6f 5f       	subi	r22, 0xFF	; 255
    2c72:	7f 4f       	sbci	r23, 0xFF	; 255
    2c74:	80 0f       	add	r24, r16
    2c76:	91 1f       	adc	r25, r17
    2c78:	0e 94 2f 2c 	call	0x585e	; 0x585e <memcmp>
    2c7c:	00 97       	sbiw	r24, 0x00	; 0
    2c7e:	51 f4       	brne	.+20     	; 0x2c94 <csp_crc32_verify+0x7a>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    2c80:	f8 01       	movw	r30, r16
    2c82:	e0 86       	std	Z+8, r14	; 0x08
    2c84:	f1 86       	std	Z+9, r15	; 0x09
		return CSP_ERR_NONE;
    2c86:	08 c0       	rjmp	.+16     	; 0x2c98 <csp_crc32_verify+0x7e>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    2c88:	8e ef       	ldi	r24, 0xFE	; 254
    2c8a:	9f ef       	ldi	r25, 0xFF	; 255
    2c8c:	05 c0       	rjmp	.+10     	; 0x2c98 <csp_crc32_verify+0x7e>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    2c8e:	8e ef       	ldi	r24, 0xFE	; 254
    2c90:	9f ef       	ldi	r25, 0xFF	; 255
    2c92:	02 c0       	rjmp	.+4      	; 0x2c98 <csp_crc32_verify+0x7e>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    2c94:	8e ef       	ldi	r24, 0xFE	; 254
    2c96:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    2c98:	24 96       	adiw	r28, 0x04	; 4
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	de bf       	out	0x3e, r29	; 62
    2c9e:	df 91       	pop	r29
    2ca0:	cf 91       	pop	r28
    2ca2:	1f 91       	pop	r17
    2ca4:	0f 91       	pop	r16
    2ca6:	ff 90       	pop	r15
    2ca8:	ef 90       	pop	r14
    2caa:	08 95       	ret

00002cac <csp_hton32>:
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    2cac:	cf 92       	push	r12
    2cae:	df 92       	push	r13
    2cb0:	ef 92       	push	r14
    2cb2:	ff 92       	push	r15
    2cb4:	0f 93       	push	r16
    2cb6:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2cb8:	f6 2e       	mov	r15, r22
    2cba:	ee 24       	eor	r14, r14
    2cbc:	dd 24       	eor	r13, r13
    2cbe:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2cc0:	09 2f       	mov	r16, r25
    2cc2:	11 27       	eor	r17, r17
    2cc4:	22 27       	eor	r18, r18
    2cc6:	33 27       	eor	r19, r19
    2cc8:	0c 29       	or	r16, r12
    2cca:	1d 29       	or	r17, r13
    2ccc:	2e 29       	or	r18, r14
    2cce:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    2cd0:	6b 01       	movw	r12, r22
    2cd2:	7c 01       	movw	r14, r24
    2cd4:	cc 24       	eor	r12, r12
    2cd6:	ee 24       	eor	r14, r14
    2cd8:	ff 24       	eor	r15, r15
    2cda:	fe 2c       	mov	r15, r14
    2cdc:	ed 2c       	mov	r14, r13
    2cde:	dc 2c       	mov	r13, r12
    2ce0:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2ce2:	0c 29       	or	r16, r12
    2ce4:	1d 29       	or	r17, r13
    2ce6:	2e 29       	or	r18, r14
    2ce8:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    2cea:	dc 01       	movw	r26, r24
    2cec:	cb 01       	movw	r24, r22
    2cee:	88 27       	eor	r24, r24
    2cf0:	99 27       	eor	r25, r25
    2cf2:	bb 27       	eor	r27, r27
    2cf4:	89 2f       	mov	r24, r25
    2cf6:	9a 2f       	mov	r25, r26
    2cf8:	ab 2f       	mov	r26, r27
    2cfa:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2cfc:	bc 01       	movw	r22, r24
    2cfe:	cd 01       	movw	r24, r26
    2d00:	60 2b       	or	r22, r16
    2d02:	71 2b       	or	r23, r17
    2d04:	82 2b       	or	r24, r18
    2d06:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    2d08:	1f 91       	pop	r17
    2d0a:	0f 91       	pop	r16
    2d0c:	ff 90       	pop	r15
    2d0e:	ef 90       	pop	r14
    2d10:	df 90       	pop	r13
    2d12:	cf 90       	pop	r12
    2d14:	08 95       	ret

00002d16 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    2d16:	cf 92       	push	r12
    2d18:	df 92       	push	r13
    2d1a:	ef 92       	push	r14
    2d1c:	ff 92       	push	r15
    2d1e:	0f 93       	push	r16
    2d20:	1f 93       	push	r17
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2d22:	f6 2e       	mov	r15, r22
    2d24:	ee 24       	eor	r14, r14
    2d26:	dd 24       	eor	r13, r13
    2d28:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2d2a:	09 2f       	mov	r16, r25
    2d2c:	11 27       	eor	r17, r17
    2d2e:	22 27       	eor	r18, r18
    2d30:	33 27       	eor	r19, r19
    2d32:	0c 29       	or	r16, r12
    2d34:	1d 29       	or	r17, r13
    2d36:	2e 29       	or	r18, r14
    2d38:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    2d3a:	6b 01       	movw	r12, r22
    2d3c:	7c 01       	movw	r14, r24
    2d3e:	cc 24       	eor	r12, r12
    2d40:	ee 24       	eor	r14, r14
    2d42:	ff 24       	eor	r15, r15
    2d44:	fe 2c       	mov	r15, r14
    2d46:	ed 2c       	mov	r14, r13
    2d48:	dc 2c       	mov	r13, r12
    2d4a:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2d4c:	0c 29       	or	r16, r12
    2d4e:	1d 29       	or	r17, r13
    2d50:	2e 29       	or	r18, r14
    2d52:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    2d54:	dc 01       	movw	r26, r24
    2d56:	cb 01       	movw	r24, r22
    2d58:	88 27       	eor	r24, r24
    2d5a:	99 27       	eor	r25, r25
    2d5c:	bb 27       	eor	r27, r27
    2d5e:	89 2f       	mov	r24, r25
    2d60:	9a 2f       	mov	r25, r26
    2d62:	ab 2f       	mov	r26, r27
    2d64:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2d66:	bc 01       	movw	r22, r24
    2d68:	cd 01       	movw	r24, r26
    2d6a:	60 2b       	or	r22, r16
    2d6c:	71 2b       	or	r23, r17
    2d6e:	82 2b       	or	r24, r18
    2d70:	93 2b       	or	r25, r19
}

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
	return csp_hton32(n32);
}
    2d72:	1f 91       	pop	r17
    2d74:	0f 91       	pop	r16
    2d76:	ff 90       	pop	r15
    2d78:	ef 90       	pop	r14
    2d7a:	df 90       	pop	r13
    2d7c:	cf 90       	pop	r12
    2d7e:	08 95       	ret

00002d80 <csp_get_hostname>:
	csp_packet_t * packet = NULL;
	csp_queue_dequeue(socket->socket, &packet, timeout);

	return packet;

}
    2d80:	80 91 cf 3d 	lds	r24, 0x3DCF
    2d84:	90 91 d0 3d 	lds	r25, 0x3DD0
    2d88:	08 95       	ret

00002d8a <csp_get_model>:
    2d8a:	80 91 cd 3d 	lds	r24, 0x3DCD
    2d8e:	90 91 ce 3d 	lds	r25, 0x3DCE
    2d92:	08 95       	ret

00002d94 <csp_init>:
    2d94:	80 93 47 3f 	sts	0x3F47, r24
    2d98:	63 dd       	rcall	.-1338   	; 0x2860 <csp_conn_init>
    2d9a:	9c 01       	movw	r18, r24
    2d9c:	00 97       	sbiw	r24, 0x00	; 0
    2d9e:	31 f4       	brne	.+12     	; 0x2dac <csp_init+0x18>
    2da0:	08 d2       	rcall	.+1040   	; 0x31b2 <csp_port_init>
    2da2:	9c 01       	movw	r18, r24
    2da4:	00 97       	sbiw	r24, 0x00	; 0
    2da6:	21 f4       	brne	.+8      	; 0x2db0 <csp_init+0x1c>
    2da8:	37 c3       	rjmp	.+1646   	; 0x3418 <csp_route_table_init>
    2daa:	08 95       	ret
    2dac:	93 2f       	mov	r25, r19
    2dae:	08 95       	ret
    2db0:	93 2f       	mov	r25, r19
    2db2:	08 95       	ret

00002db4 <csp_socket>:
    2db4:	cf 92       	push	r12
    2db6:	df 92       	push	r13
    2db8:	ef 92       	push	r14
    2dba:	ff 92       	push	r15
    2dbc:	cf 93       	push	r28
    2dbe:	df 93       	push	r29
    2dc0:	6b 01       	movw	r12, r22
    2dc2:	7c 01       	movw	r14, r24
    2dc4:	dc 01       	movw	r26, r24
    2dc6:	cb 01       	movw	r24, r22
    2dc8:	81 71       	andi	r24, 0x11	; 17
    2dca:	99 27       	eor	r25, r25
    2dcc:	aa 27       	eor	r26, r26
    2dce:	bb 27       	eor	r27, r27
    2dd0:	89 2b       	or	r24, r25
    2dd2:	8a 2b       	or	r24, r26
    2dd4:	8b 2b       	or	r24, r27
    2dd6:	11 f5       	brne	.+68     	; 0x2e1c <csp_socket+0x68>
    2dd8:	d7 01       	movw	r26, r14
    2dda:	c6 01       	movw	r24, r12
    2ddc:	8e 7a       	andi	r24, 0xAE	; 174
    2dde:	9e 7f       	andi	r25, 0xFE	; 254
    2de0:	89 2b       	or	r24, r25
    2de2:	8a 2b       	or	r24, r26
    2de4:	8b 2b       	or	r24, r27
    2de6:	e9 f4       	brne	.+58     	; 0x2e22 <csp_socket+0x6e>
    2de8:	81 e0       	ldi	r24, 0x01	; 1
    2dea:	de dd       	rcall	.-1092   	; 0x29a8 <csp_conn_allocate>
    2dec:	ec 01       	movw	r28, r24
    2dee:	00 97       	sbiw	r24, 0x00	; 0
    2df0:	d9 f0       	breq	.+54     	; 0x2e28 <csp_socket+0x74>
    2df2:	d0 fe       	sbrs	r13, 0
    2df4:	0a c0       	rjmp	.+20     	; 0x2e0a <csp_socket+0x56>
    2df6:	62 e0       	ldi	r22, 0x02	; 2
    2df8:	70 e0       	ldi	r23, 0x00	; 0
    2dfa:	8a e0       	ldi	r24, 0x0A	; 10
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	b7 da       	rcall	.-2706   	; 0x236e <csp_queue_create>
    2e00:	8e 87       	std	Y+14, r24	; 0x0e
    2e02:	9f 87       	std	Y+15, r25	; 0x0f
    2e04:	89 2b       	or	r24, r25
    2e06:	19 f4       	brne	.+6      	; 0x2e0e <csp_socket+0x5a>
    2e08:	12 c0       	rjmp	.+36     	; 0x2e2e <csp_socket+0x7a>
    2e0a:	1e 86       	std	Y+14, r1	; 0x0e
    2e0c:	1f 86       	std	Y+15, r1	; 0x0f
    2e0e:	cc 8a       	std	Y+20, r12	; 0x14
    2e10:	dd 8a       	std	Y+21, r13	; 0x15
    2e12:	ee 8a       	std	Y+22, r14	; 0x16
    2e14:	ff 8a       	std	Y+23, r15	; 0x17
    2e16:	8c 2f       	mov	r24, r28
    2e18:	9d 2f       	mov	r25, r29
    2e1a:	0b c0       	rjmp	.+22     	; 0x2e32 <csp_socket+0x7e>
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	08 c0       	rjmp	.+16     	; 0x2e32 <csp_socket+0x7e>
    2e22:	80 e0       	ldi	r24, 0x00	; 0
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	05 c0       	rjmp	.+10     	; 0x2e32 <csp_socket+0x7e>
    2e28:	80 e0       	ldi	r24, 0x00	; 0
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	02 c0       	rjmp	.+4      	; 0x2e32 <csp_socket+0x7e>
    2e2e:	80 e0       	ldi	r24, 0x00	; 0
    2e30:	90 e0       	ldi	r25, 0x00	; 0
    2e32:	df 91       	pop	r29
    2e34:	cf 91       	pop	r28
    2e36:	ff 90       	pop	r15
    2e38:	ef 90       	pop	r14
    2e3a:	df 90       	pop	r13
    2e3c:	cf 90       	pop	r12
    2e3e:	08 95       	ret

00002e40 <csp_accept>:
    2e40:	cf 93       	push	r28
    2e42:	df 93       	push	r29
    2e44:	1f 92       	push	r1
    2e46:	1f 92       	push	r1
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	00 97       	sbiw	r24, 0x00	; 0
    2e4e:	81 f0       	breq	.+32     	; 0x2e70 <csp_accept+0x30>
    2e50:	fc 01       	movw	r30, r24
    2e52:	86 85       	ldd	r24, Z+14	; 0x0e
    2e54:	97 85       	ldd	r25, Z+15	; 0x0f
    2e56:	00 97       	sbiw	r24, 0x00	; 0
    2e58:	71 f0       	breq	.+28     	; 0x2e76 <csp_accept+0x36>
    2e5a:	9a 01       	movw	r18, r20
    2e5c:	ab 01       	movw	r20, r22
    2e5e:	be 01       	movw	r22, r28
    2e60:	6f 5f       	subi	r22, 0xFF	; 255
    2e62:	7f 4f       	sbci	r23, 0xFF	; 255
    2e64:	99 da       	rcall	.-2766   	; 0x2398 <csp_queue_dequeue>
    2e66:	01 97       	sbiw	r24, 0x01	; 1
    2e68:	49 f4       	brne	.+18     	; 0x2e7c <csp_accept+0x3c>
    2e6a:	89 81       	ldd	r24, Y+1	; 0x01
    2e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e6e:	08 c0       	rjmp	.+16     	; 0x2e80 <csp_accept+0x40>
    2e70:	80 e0       	ldi	r24, 0x00	; 0
    2e72:	90 e0       	ldi	r25, 0x00	; 0
    2e74:	05 c0       	rjmp	.+10     	; 0x2e80 <csp_accept+0x40>
    2e76:	80 e0       	ldi	r24, 0x00	; 0
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	02 c0       	rjmp	.+4      	; 0x2e80 <csp_accept+0x40>
    2e7c:	80 e0       	ldi	r24, 0x00	; 0
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	0f 90       	pop	r0
    2e82:	0f 90       	pop	r0
    2e84:	df 91       	pop	r29
    2e86:	cf 91       	pop	r28
    2e88:	08 95       	ret

00002e8a <csp_read>:
    2e8a:	cf 93       	push	r28
    2e8c:	df 93       	push	r29
    2e8e:	1f 92       	push	r1
    2e90:	1f 92       	push	r1
    2e92:	cd b7       	in	r28, 0x3d	; 61
    2e94:	de b7       	in	r29, 0x3e	; 62
    2e96:	19 82       	std	Y+1, r1	; 0x01
    2e98:	1a 82       	std	Y+2, r1	; 0x02
    2e9a:	00 97       	sbiw	r24, 0x00	; 0
    2e9c:	89 f0       	breq	.+34     	; 0x2ec0 <csp_read+0x36>
    2e9e:	fc 01       	movw	r30, r24
    2ea0:	21 81       	ldd	r18, Z+1	; 0x01
    2ea2:	21 30       	cpi	r18, 0x01	; 1
    2ea4:	81 f4       	brne	.+32     	; 0x2ec6 <csp_read+0x3c>
    2ea6:	9a 01       	movw	r18, r20
    2ea8:	ab 01       	movw	r20, r22
    2eaa:	be 01       	movw	r22, r28
    2eac:	6f 5f       	subi	r22, 0xFF	; 255
    2eae:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb0:	84 85       	ldd	r24, Z+12	; 0x0c
    2eb2:	95 85       	ldd	r25, Z+13	; 0x0d
    2eb4:	71 da       	rcall	.-2846   	; 0x2398 <csp_queue_dequeue>
    2eb6:	01 97       	sbiw	r24, 0x01	; 1
    2eb8:	49 f4       	brne	.+18     	; 0x2ecc <csp_read+0x42>
    2eba:	89 81       	ldd	r24, Y+1	; 0x01
    2ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ebe:	08 c0       	rjmp	.+16     	; 0x2ed0 <csp_read+0x46>
    2ec0:	80 e0       	ldi	r24, 0x00	; 0
    2ec2:	90 e0       	ldi	r25, 0x00	; 0
    2ec4:	05 c0       	rjmp	.+10     	; 0x2ed0 <csp_read+0x46>
    2ec6:	80 e0       	ldi	r24, 0x00	; 0
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	02 c0       	rjmp	.+4      	; 0x2ed0 <csp_read+0x46>
    2ecc:	80 e0       	ldi	r24, 0x00	; 0
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	08 95       	ret

00002eda <csp_send_direct>:
    2eda:	8f 92       	push	r8
    2edc:	9f 92       	push	r9
    2ede:	af 92       	push	r10
    2ee0:	bf 92       	push	r11
    2ee2:	cf 92       	push	r12
    2ee4:	df 92       	push	r13
    2ee6:	ef 92       	push	r14
    2ee8:	ff 92       	push	r15
    2eea:	0f 93       	push	r16
    2eec:	1f 93       	push	r17
    2eee:	cf 93       	push	r28
    2ef0:	df 93       	push	r29
    2ef2:	96 2e       	mov	r9, r22
    2ef4:	87 2e       	mov	r8, r23
    2ef6:	d8 2f       	mov	r29, r24
    2ef8:	c9 2f       	mov	r28, r25
    2efa:	5a 01       	movw	r10, r20
    2efc:	68 01       	movw	r12, r16
    2efe:	79 01       	movw	r14, r18
    2f00:	41 15       	cp	r20, r1
    2f02:	51 05       	cpc	r21, r1
    2f04:	09 f4       	brne	.+2      	; 0x2f08 <csp_send_direct+0x2e>
    2f06:	7b c0       	rjmp	.+246    	; 0x2ffe <csp_send_direct+0x124>
    2f08:	89 2f       	mov	r24, r25
    2f0a:	81 70       	andi	r24, 0x01	; 1
    2f0c:	82 95       	swap	r24
    2f0e:	80 7f       	andi	r24, 0xF0	; 240
    2f10:	9d 2f       	mov	r25, r29
    2f12:	92 95       	swap	r25
    2f14:	9f 70       	andi	r25, 0x0F	; 15
    2f16:	89 2b       	or	r24, r25
    2f18:	a9 d2       	rcall	.+1362   	; 0x346c <csp_route_if>
    2f1a:	8c 01       	movw	r16, r24
    2f1c:	00 97       	sbiw	r24, 0x00	; 0
    2f1e:	09 f4       	brne	.+2      	; 0x2f22 <csp_send_direct+0x48>
    2f20:	71 c0       	rjmp	.+226    	; 0x3004 <csp_send_direct+0x12a>
    2f22:	dc 01       	movw	r26, r24
    2f24:	ed 91       	ld	r30, X+
    2f26:	fc 91       	ld	r31, X
    2f28:	30 97       	sbiw	r30, 0x00	; 0
    2f2a:	09 f4       	brne	.+2      	; 0x2f2e <csp_send_direct+0x54>
    2f2c:	6e c0       	rjmp	.+220    	; 0x300a <csp_send_direct+0x130>
    2f2e:	24 81       	ldd	r18, Z+4	; 0x04
    2f30:	35 81       	ldd	r19, Z+5	; 0x05
    2f32:	23 2b       	or	r18, r19
    2f34:	09 f4       	brne	.+2      	; 0x2f38 <csp_send_direct+0x5e>
    2f36:	6c c0       	rjmp	.+216    	; 0x3010 <csp_send_direct+0x136>
    2f38:	2c 2f       	mov	r18, r28
    2f3a:	26 95       	lsr	r18
    2f3c:	2f 71       	andi	r18, 0x1F	; 31
    2f3e:	30 e0       	ldi	r19, 0x00	; 0
    2f40:	80 91 47 3f 	lds	r24, 0x3F47
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	28 17       	cp	r18, r24
    2f48:	39 07       	cpc	r19, r25
    2f4a:	59 f4       	brne	.+22     	; 0x2f62 <csp_send_direct+0x88>
    2f4c:	93 fc       	sbrc	r9, 3
    2f4e:	46 c0       	rjmp	.+140    	; 0x2fdc <csp_send_direct+0x102>
    2f50:	90 fe       	sbrs	r9, 0
    2f52:	05 c0       	rjmp	.+10     	; 0x2f5e <csp_send_direct+0x84>
    2f54:	c5 01       	movw	r24, r10
    2f56:	40 de       	rcall	.-896    	; 0x2bd8 <csp_crc32_append>
    2f58:	89 2b       	or	r24, r25
    2f5a:	09 f0       	breq	.+2      	; 0x2f5e <csp_send_direct+0x84>
    2f5c:	3f c0       	rjmp	.+126    	; 0x2fdc <csp_send_direct+0x102>
    2f5e:	92 fc       	sbrc	r9, 2
    2f60:	3d c0       	rjmp	.+122    	; 0x2fdc <csp_send_direct+0x102>
    2f62:	f5 01       	movw	r30, r10
    2f64:	92 86       	std	Z+10, r9	; 0x0a
    2f66:	83 86       	std	Z+11, r8	; 0x0b
    2f68:	d4 87       	std	Z+12, r29	; 0x0c
    2f6a:	c5 87       	std	Z+13, r28	; 0x0d
    2f6c:	c0 85       	ldd	r28, Z+8	; 0x08
    2f6e:	d1 85       	ldd	r29, Z+9	; 0x09
    2f70:	f8 01       	movw	r30, r16
    2f72:	a0 81       	ld	r26, Z
    2f74:	b1 81       	ldd	r27, Z+1	; 0x01
    2f76:	17 96       	adiw	r26, 0x07	; 7
    2f78:	8d 91       	ld	r24, X+
    2f7a:	9c 91       	ld	r25, X
    2f7c:	18 97       	sbiw	r26, 0x08	; 8
    2f7e:	00 97       	sbiw	r24, 0x00	; 0
    2f80:	19 f0       	breq	.+6      	; 0x2f88 <csp_send_direct+0xae>
    2f82:	8c 17       	cp	r24, r28
    2f84:	9d 07       	cpc	r25, r29
    2f86:	50 f1       	brcs	.+84     	; 0x2fdc <csp_send_direct+0x102>
    2f88:	14 96       	adiw	r26, 0x04	; 4
    2f8a:	ed 91       	ld	r30, X+
    2f8c:	fc 91       	ld	r31, X
    2f8e:	15 97       	sbiw	r26, 0x05	; 5
    2f90:	a7 01       	movw	r20, r14
    2f92:	96 01       	movw	r18, r12
    2f94:	b5 01       	movw	r22, r10
    2f96:	cd 01       	movw	r24, r26
    2f98:	19 95       	eicall
    2f9a:	00 97       	sbiw	r24, 0x00	; 0
    2f9c:	f9 f4       	brne	.+62     	; 0x2fdc <csp_send_direct+0x102>
    2f9e:	d8 01       	movw	r26, r16
    2fa0:	ed 91       	ld	r30, X+
    2fa2:	fc 91       	ld	r31, X
    2fa4:	11 97       	sbiw	r26, 0x01	; 1
    2fa6:	42 85       	ldd	r20, Z+10	; 0x0a
    2fa8:	53 85       	ldd	r21, Z+11	; 0x0b
    2faa:	64 85       	ldd	r22, Z+12	; 0x0c
    2fac:	75 85       	ldd	r23, Z+13	; 0x0d
    2fae:	4f 5f       	subi	r20, 0xFF	; 255
    2fb0:	5f 4f       	sbci	r21, 0xFF	; 255
    2fb2:	6f 4f       	sbci	r22, 0xFF	; 255
    2fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb6:	42 87       	std	Z+10, r20	; 0x0a
    2fb8:	53 87       	std	Z+11, r21	; 0x0b
    2fba:	64 87       	std	Z+12, r22	; 0x0c
    2fbc:	75 87       	std	Z+13, r23	; 0x0d
    2fbe:	ed 91       	ld	r30, X+
    2fc0:	fc 91       	ld	r31, X
    2fc2:	46 a1       	ldd	r20, Z+38	; 0x26
    2fc4:	57 a1       	ldd	r21, Z+39	; 0x27
    2fc6:	60 a5       	ldd	r22, Z+40	; 0x28
    2fc8:	71 a5       	ldd	r23, Z+41	; 0x29
    2fca:	4c 0f       	add	r20, r28
    2fcc:	5d 1f       	adc	r21, r29
    2fce:	61 1d       	adc	r22, r1
    2fd0:	71 1d       	adc	r23, r1
    2fd2:	46 a3       	std	Z+38, r20	; 0x26
    2fd4:	57 a3       	std	Z+39, r21	; 0x27
    2fd6:	60 a7       	std	Z+40, r22	; 0x28
    2fd8:	71 a7       	std	Z+41, r23	; 0x29
    2fda:	1c c0       	rjmp	.+56     	; 0x3014 <csp_send_direct+0x13a>
    2fdc:	d8 01       	movw	r26, r16
    2fde:	ed 91       	ld	r30, X+
    2fe0:	fc 91       	ld	r31, X
    2fe2:	82 89       	ldd	r24, Z+18	; 0x12
    2fe4:	93 89       	ldd	r25, Z+19	; 0x13
    2fe6:	a4 89       	ldd	r26, Z+20	; 0x14
    2fe8:	b5 89       	ldd	r27, Z+21	; 0x15
    2fea:	01 96       	adiw	r24, 0x01	; 1
    2fec:	a1 1d       	adc	r26, r1
    2fee:	b1 1d       	adc	r27, r1
    2ff0:	82 8b       	std	Z+18, r24	; 0x12
    2ff2:	93 8b       	std	Z+19, r25	; 0x13
    2ff4:	a4 8b       	std	Z+20, r26	; 0x14
    2ff6:	b5 8b       	std	Z+21, r27	; 0x15
    2ff8:	86 ef       	ldi	r24, 0xF6	; 246
    2ffa:	9f ef       	ldi	r25, 0xFF	; 255
    2ffc:	0b c0       	rjmp	.+22     	; 0x3014 <csp_send_direct+0x13a>
    2ffe:	86 ef       	ldi	r24, 0xF6	; 246
    3000:	9f ef       	ldi	r25, 0xFF	; 255
    3002:	08 c0       	rjmp	.+16     	; 0x3014 <csp_send_direct+0x13a>
    3004:	86 ef       	ldi	r24, 0xF6	; 246
    3006:	9f ef       	ldi	r25, 0xFF	; 255
    3008:	05 c0       	rjmp	.+10     	; 0x3014 <csp_send_direct+0x13a>
    300a:	86 ef       	ldi	r24, 0xF6	; 246
    300c:	9f ef       	ldi	r25, 0xFF	; 255
    300e:	02 c0       	rjmp	.+4      	; 0x3014 <csp_send_direct+0x13a>
    3010:	86 ef       	ldi	r24, 0xF6	; 246
    3012:	9f ef       	ldi	r25, 0xFF	; 255
    3014:	df 91       	pop	r29
    3016:	cf 91       	pop	r28
    3018:	1f 91       	pop	r17
    301a:	0f 91       	pop	r16
    301c:	ff 90       	pop	r15
    301e:	ef 90       	pop	r14
    3020:	df 90       	pop	r13
    3022:	cf 90       	pop	r12
    3024:	bf 90       	pop	r11
    3026:	af 90       	pop	r10
    3028:	9f 90       	pop	r9
    302a:	8f 90       	pop	r8
    302c:	08 95       	ret

0000302e <csp_send>:
    302e:	0f 93       	push	r16
    3030:	1f 93       	push	r17
    3032:	fb 01       	movw	r30, r22
    3034:	00 97       	sbiw	r24, 0x00	; 0
    3036:	d1 f0       	breq	.+52     	; 0x306c <csp_send+0x3e>
    3038:	30 97       	sbiw	r30, 0x00	; 0
    303a:	d9 f0       	breq	.+54     	; 0x3072 <csp_send+0x44>
    303c:	dc 01       	movw	r26, r24
    303e:	11 96       	adiw	r26, 0x01	; 1
    3040:	6c 91       	ld	r22, X
    3042:	11 97       	sbiw	r26, 0x01	; 1
    3044:	61 30       	cpi	r22, 0x01	; 1
    3046:	c1 f4       	brne	.+48     	; 0x3078 <csp_send+0x4a>
    3048:	18 96       	adiw	r26, 0x08	; 8
    304a:	6d 91       	ld	r22, X+
    304c:	7d 91       	ld	r23, X+
    304e:	8d 91       	ld	r24, X+
    3050:	9c 91       	ld	r25, X
    3052:	1b 97       	sbiw	r26, 0x0b	; 11
    3054:	89 01       	movw	r16, r18
    3056:	9a 01       	movw	r18, r20
    3058:	af 01       	movw	r20, r30
    305a:	3f df       	rcall	.-386    	; 0x2eda <csp_send_direct>
    305c:	31 e0       	ldi	r19, 0x01	; 1
    305e:	20 e0       	ldi	r18, 0x00	; 0
    3060:	89 2b       	or	r24, r25
    3062:	09 f0       	breq	.+2      	; 0x3066 <csp_send+0x38>
    3064:	30 e0       	ldi	r19, 0x00	; 0
    3066:	83 2f       	mov	r24, r19
    3068:	92 2f       	mov	r25, r18
    306a:	08 c0       	rjmp	.+16     	; 0x307c <csp_send+0x4e>
    306c:	80 e0       	ldi	r24, 0x00	; 0
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	05 c0       	rjmp	.+10     	; 0x307c <csp_send+0x4e>
    3072:	80 e0       	ldi	r24, 0x00	; 0
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	02 c0       	rjmp	.+4      	; 0x307c <csp_send+0x4e>
    3078:	80 e0       	ldi	r24, 0x00	; 0
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	1f 91       	pop	r17
    307e:	0f 91       	pop	r16
    3080:	08 95       	ret

00003082 <csp_sendto>:

int csp_sendto(uint8_t prio, uint8_t dest, uint8_t dport, uint8_t src_port, uint32_t opts, csp_packet_t * packet, uint32_t timeout) {
    3082:	4f 92       	push	r4
    3084:	5f 92       	push	r5
    3086:	6f 92       	push	r6
    3088:	7f 92       	push	r7
    308a:	8f 92       	push	r8
    308c:	9f 92       	push	r9
    308e:	af 92       	push	r10
    3090:	bf 92       	push	r11
    3092:	cf 92       	push	r12
    3094:	df 92       	push	r13
    3096:	ef 92       	push	r14
    3098:	ff 92       	push	r15
    309a:	0f 93       	push	r16
    309c:	1f 93       	push	r17
    309e:	cf 93       	push	r28
    30a0:	df 93       	push	r29
    30a2:	cd b7       	in	r28, 0x3d	; 61
    30a4:	de b7       	in	r29, 0x3e	; 62
    30a6:	f6 01       	movw	r30, r12

	packet->id.flags = 0;
    30a8:	12 86       	std	Z+10, r1	; 0x0a

	if (opts & CSP_O_RDP) {
    30aa:	e0 fc       	sbrc	r14, 0
    30ac:	45 c0       	rjmp	.+138    	; 0x3138 <csp_sendto+0xb6>
    30ae:	27 01       	movw	r4, r14
    30b0:	38 01       	movw	r6, r16
    30b2:	94 e1       	ldi	r25, 0x14	; 20
    30b4:	49 22       	and	r4, r25
    30b6:	55 24       	eor	r5, r5
    30b8:	66 24       	eor	r6, r6
    30ba:	77 24       	eor	r7, r7
		csp_log_error("Attempt to create HMAC authenticated packet, but CSP was compiled without HMAC support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_XTEA) {
    30bc:	45 28       	or	r4, r5
    30be:	46 28       	or	r4, r6
    30c0:	47 28       	or	r4, r7
    30c2:	e9 f5       	brne	.+122    	; 0x313e <csp_sendto+0xbc>
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_CRC32) {
    30c4:	e6 fe       	sbrs	r14, 6
    30c6:	02 c0       	rjmp	.+4      	; 0x30cc <csp_sendto+0x4a>
#ifdef CSP_USE_CRC32
		packet->id.flags |= CSP_FCRC32;
    30c8:	91 e0       	ldi	r25, 0x01	; 1
    30ca:	92 87       	std	Z+10, r25	; 0x0a
		csp_log_error("Attempt to create CRC32 validated packet, but CSP was compiled without CRC32 support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	packet->id.dst = dest;
    30cc:	64 fb       	bst	r22, 4
    30ce:	99 27       	eor	r25, r25
    30d0:	90 f9       	bld	r25, 0
    30d2:	35 85       	ldd	r19, Z+13	; 0x0d
    30d4:	3e 7f       	andi	r19, 0xFE	; 254
    30d6:	39 2b       	or	r19, r25
    30d8:	35 87       	std	Z+13, r19	; 0x0d
	packet->id.dport = dport;
    30da:	54 2f       	mov	r21, r20
    30dc:	52 95       	swap	r21
    30de:	55 0f       	add	r21, r21
    30e0:	55 0f       	add	r21, r21
    30e2:	50 7c       	andi	r21, 0xC0	; 192
    30e4:	93 85       	ldd	r25, Z+11	; 0x0b
    30e6:	9f 73       	andi	r25, 0x3F	; 63
    30e8:	95 2b       	or	r25, r21
    30ea:	93 87       	std	Z+11, r25	; 0x0b
    30ec:	46 95       	lsr	r20
    30ee:	46 95       	lsr	r20
    30f0:	4f 70       	andi	r20, 0x0F	; 15
    30f2:	62 95       	swap	r22
    30f4:	60 7f       	andi	r22, 0xF0	; 240
    30f6:	64 2b       	or	r22, r20
    30f8:	64 87       	std	Z+12, r22	; 0x0c
	packet->id.src = my_address;
    30fa:	40 91 47 3f 	lds	r20, 0x3F47
    30fe:	4f 71       	andi	r20, 0x1F	; 31
    3100:	44 0f       	add	r20, r20
    3102:	31 70       	andi	r19, 0x01	; 1
	packet->id.sport = src_port;
    3104:	2f 73       	andi	r18, 0x3F	; 63
    3106:	90 7c       	andi	r25, 0xC0	; 192
    3108:	29 2b       	or	r18, r25
    310a:	23 87       	std	Z+11, r18	; 0x0b
	packet->id.pri = prio;
    310c:	98 2f       	mov	r25, r24
    310e:	92 95       	swap	r25
    3110:	99 0f       	add	r25, r25
    3112:	99 0f       	add	r25, r25
    3114:	90 7c       	andi	r25, 0xC0	; 192
    3116:	83 2f       	mov	r24, r19
    3118:	84 2b       	or	r24, r20
    311a:	89 2b       	or	r24, r25
    311c:	85 87       	std	Z+13, r24	; 0x0d

	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
    311e:	62 85       	ldd	r22, Z+10	; 0x0a
    3120:	73 85       	ldd	r23, Z+11	; 0x0b
    3122:	84 85       	ldd	r24, Z+12	; 0x0c
    3124:	95 85       	ldd	r25, Z+13	; 0x0d
    3126:	95 01       	movw	r18, r10
    3128:	84 01       	movw	r16, r8
    312a:	af 01       	movw	r20, r30
    312c:	d6 de       	rcall	.-596    	; 0x2eda <csp_send_direct>
    312e:	00 97       	sbiw	r24, 0x00	; 0
    3130:	41 f0       	breq	.+16     	; 0x3142 <csp_sendto+0xc0>
		return CSP_ERR_NOTSUP;
    3132:	8b ef       	ldi	r24, 0xFB	; 251
    3134:	9f ef       	ldi	r25, 0xFF	; 255
    3136:	05 c0       	rjmp	.+10     	; 0x3142 <csp_sendto+0xc0>

	packet->id.flags = 0;

	if (opts & CSP_O_RDP) {
		csp_log_error("Attempt to create RDP packet on connection-less socket\r\n");
		return CSP_ERR_INVAL;
    3138:	8e ef       	ldi	r24, 0xFE	; 254
    313a:	9f ef       	ldi	r25, 0xFF	; 255
    313c:	02 c0       	rjmp	.+4      	; 0x3142 <csp_sendto+0xc0>
	if (opts & CSP_O_XTEA) {
#ifdef CSP_USE_XTEA
		packet->id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
    313e:	8b ef       	ldi	r24, 0xFB	; 251
    3140:	9f ef       	ldi	r25, 0xFF	; 255
	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
		return CSP_ERR_NOTSUP;
	
	return CSP_ERR_NONE;

}
    3142:	df 91       	pop	r29
    3144:	cf 91       	pop	r28
    3146:	1f 91       	pop	r17
    3148:	0f 91       	pop	r16
    314a:	ff 90       	pop	r15
    314c:	ef 90       	pop	r14
    314e:	df 90       	pop	r13
    3150:	cf 90       	pop	r12
    3152:	bf 90       	pop	r11
    3154:	af 90       	pop	r10
    3156:	9f 90       	pop	r9
    3158:	8f 90       	pop	r8
    315a:	7f 90       	pop	r7
    315c:	6f 90       	pop	r6
    315e:	5f 90       	pop	r5
    3160:	4f 90       	pop	r4
    3162:	08 95       	ret

00003164 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
    3164:	81 32       	cpi	r24, 0x21	; 33
    3166:	91 05       	cpc	r25, r1
    3168:	f0 f4       	brcc	.+60     	; 0x31a6 <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    316a:	fc 01       	movw	r30, r24
    316c:	ee 0f       	add	r30, r30
    316e:	ff 1f       	adc	r31, r31
    3170:	e8 0f       	add	r30, r24
    3172:	f9 1f       	adc	r31, r25
    3174:	ef 52       	subi	r30, 0x2F	; 47
    3176:	f2 4c       	sbci	r31, 0xC2	; 194
    3178:	20 81       	ld	r18, Z
    317a:	21 30       	cpi	r18, 0x01	; 1
    317c:	59 f4       	brne	.+22     	; 0x3194 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    317e:	fc 01       	movw	r30, r24
    3180:	ee 0f       	add	r30, r30
    3182:	ff 1f       	adc	r31, r31
    3184:	8e 0f       	add	r24, r30
    3186:	9f 1f       	adc	r25, r31
    3188:	fc 01       	movw	r30, r24
    318a:	ef 52       	subi	r30, 0x2F	; 47
    318c:	f2 4c       	sbci	r31, 0xC2	; 194
    318e:	81 81       	ldd	r24, Z+1	; 0x01
    3190:	92 81       	ldd	r25, Z+2	; 0x02
    3192:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    3194:	80 91 31 3e 	lds	r24, 0x3E31
    3198:	81 30       	cpi	r24, 0x01	; 1
    319a:	41 f4       	brne	.+16     	; 0x31ac <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    319c:	80 91 32 3e 	lds	r24, 0x3E32
    31a0:	90 91 33 3e 	lds	r25, 0x3E33
    31a4:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
		return NULL;
    31a6:	80 e0       	ldi	r24, 0x00	; 0
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    31ac:	80 e0       	ldi	r24, 0x00	; 0
    31ae:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    31b0:	08 95       	ret

000031b2 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    31b2:	83 e6       	ldi	r24, 0x63	; 99
    31b4:	e1 ed       	ldi	r30, 0xD1	; 209
    31b6:	fd e3       	ldi	r31, 0x3D	; 61
    31b8:	df 01       	movw	r26, r30
    31ba:	1d 92       	st	X+, r1
    31bc:	8a 95       	dec	r24
    31be:	e9 f7       	brne	.-6      	; 0x31ba <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    31c0:	80 e0       	ldi	r24, 0x00	; 0
    31c2:	90 e0       	ldi	r25, 0x00	; 0
    31c4:	08 95       	ret

000031c6 <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    31c6:	cf 93       	push	r28
    31c8:	df 93       	push	r29
    31ca:	ec 01       	movw	r28, r24
    31cc:	cb 01       	movw	r24, r22
	
	if (socket == NULL)
    31ce:	20 97       	sbiw	r28, 0x00	; 0
    31d0:	81 f0       	breq	.+32     	; 0x31f2 <csp_listen+0x2c>
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    31d2:	62 e0       	ldi	r22, 0x02	; 2
    31d4:	70 e0       	ldi	r23, 0x00	; 0
    31d6:	cb d8       	rcall	.-3690   	; 0x236e <csp_queue_create>
    31d8:	8e 87       	std	Y+14, r24	; 0x0e
    31da:	9f 87       	std	Y+15, r25	; 0x0f
	if (socket->socket == NULL)
    31dc:	21 e0       	ldi	r18, 0x01	; 1
    31de:	30 e0       	ldi	r19, 0x00	; 0
    31e0:	89 2b       	or	r24, r25
    31e2:	11 f0       	breq	.+4      	; 0x31e8 <csp_listen+0x22>
    31e4:	20 e0       	ldi	r18, 0x00	; 0
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	88 27       	eor	r24, r24
    31ea:	99 27       	eor	r25, r25
    31ec:	82 1b       	sub	r24, r18
    31ee:	93 0b       	sbc	r25, r19
    31f0:	02 c0       	rjmp	.+4      	; 0x31f6 <csp_listen+0x30>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    31f2:	8e ef       	ldi	r24, 0xFE	; 254
    31f4:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    31f6:	df 91       	pop	r29
    31f8:	cf 91       	pop	r28
    31fa:	08 95       	ret

000031fc <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
    31fc:	00 97       	sbiw	r24, 0x00	; 0
    31fe:	e1 f0       	breq	.+56     	; 0x3238 <csp_bind+0x3c>
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    3200:	61 32       	cpi	r22, 0x21	; 33
    3202:	e8 f4       	brcc	.+58     	; 0x323e <csp_bind+0x42>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    3204:	70 e0       	ldi	r23, 0x00	; 0
    3206:	fb 01       	movw	r30, r22
    3208:	ee 0f       	add	r30, r30
    320a:	ff 1f       	adc	r31, r31
    320c:	e6 0f       	add	r30, r22
    320e:	f7 1f       	adc	r31, r23
    3210:	ef 52       	subi	r30, 0x2F	; 47
    3212:	f2 4c       	sbci	r31, 0xC2	; 194
    3214:	20 81       	ld	r18, Z
    3216:	21 11       	cpse	r18, r1
    3218:	15 c0       	rjmp	.+42     	; 0x3244 <csp_bind+0x48>
	}

	csp_log_info("Binding socket %p to port %u\r\n", socket, port);

	/* Save listener */
	ports[port].socket = socket;
    321a:	fb 01       	movw	r30, r22
    321c:	ee 0f       	add	r30, r30
    321e:	ff 1f       	adc	r31, r31
    3220:	6e 0f       	add	r22, r30
    3222:	7f 1f       	adc	r23, r31
    3224:	fb 01       	movw	r30, r22
    3226:	ef 52       	subi	r30, 0x2F	; 47
    3228:	f2 4c       	sbci	r31, 0xC2	; 194
    322a:	81 83       	std	Z+1, r24	; 0x01
    322c:	92 83       	std	Z+2, r25	; 0x02
	ports[port].state = PORT_OPEN;
    322e:	81 e0       	ldi	r24, 0x01	; 1
    3230:	80 83       	st	Z, r24

	return CSP_ERR_NONE;
    3232:	80 e0       	ldi	r24, 0x00	; 0
    3234:	90 e0       	ldi	r25, 0x00	; 0
    3236:	08 95       	ret
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    3238:	8e ef       	ldi	r24, 0xFE	; 254
    323a:	9f ef       	ldi	r25, 0xFF	; 255
    323c:	08 95       	ret

	if (port > CSP_ANY) {
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
    323e:	8e ef       	ldi	r24, 0xFE	; 254
    3240:	9f ef       	ldi	r25, 0xFF	; 255
    3242:	08 95       	ret
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
		csp_log_error("Port %d is already in use\r\n", port);
		return CSP_ERR_USED;
    3244:	8c ef       	ldi	r24, 0xFC	; 252
    3246:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    3248:	08 95       	ret

0000324a <csp_route_security_check>:
	return prio;
#else
	return 0;
#endif

}
    324a:	0f 93       	push	r16
    324c:	1f 93       	push	r17
    324e:	cf 93       	push	r28
    3250:	df 93       	push	r29
    3252:	ea 01       	movw	r28, r20
    3254:	89 01       	movw	r16, r18
    3256:	f9 01       	movw	r30, r18
    3258:	82 85       	ldd	r24, Z+10	; 0x0a
    325a:	82 ff       	sbrs	r24, 2
    325c:	0e c0       	rjmp	.+28     	; 0x327a <csp_route_security_check+0x30>
    325e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3260:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3262:	a8 a1       	ldd	r26, Y+32	; 0x20
    3264:	b9 a1       	ldd	r27, Y+33	; 0x21
    3266:	01 96       	adiw	r24, 0x01	; 1
    3268:	a1 1d       	adc	r26, r1
    326a:	b1 1d       	adc	r27, r1
    326c:	8e 8f       	std	Y+30, r24	; 0x1e
    326e:	9f 8f       	std	Y+31, r25	; 0x1f
    3270:	a8 a3       	std	Y+32, r26	; 0x20
    3272:	b9 a3       	std	Y+33, r27	; 0x21
    3274:	8b ef       	ldi	r24, 0xFB	; 251
    3276:	9f ef       	ldi	r25, 0xFF	; 255
    3278:	28 c0       	rjmp	.+80     	; 0x32ca <csp_route_security_check+0x80>
    327a:	80 ff       	sbrs	r24, 0
    327c:	12 c0       	rjmp	.+36     	; 0x32a2 <csp_route_security_check+0x58>
    327e:	c9 01       	movw	r24, r18
    3280:	cc dc       	rcall	.-1640   	; 0x2c1a <csp_crc32_verify>
    3282:	89 2b       	or	r24, r25
    3284:	71 f0       	breq	.+28     	; 0x32a2 <csp_route_security_check+0x58>
    3286:	8e 89       	ldd	r24, Y+22	; 0x16
    3288:	9f 89       	ldd	r25, Y+23	; 0x17
    328a:	a8 8d       	ldd	r26, Y+24	; 0x18
    328c:	b9 8d       	ldd	r27, Y+25	; 0x19
    328e:	01 96       	adiw	r24, 0x01	; 1
    3290:	a1 1d       	adc	r26, r1
    3292:	b1 1d       	adc	r27, r1
    3294:	8e 8b       	std	Y+22, r24	; 0x16
    3296:	9f 8b       	std	Y+23, r25	; 0x17
    3298:	a8 8f       	std	Y+24, r26	; 0x18
    329a:	b9 8f       	std	Y+25, r27	; 0x19
    329c:	8a e9       	ldi	r24, 0x9A	; 154
    329e:	9f ef       	ldi	r25, 0xFF	; 255
    32a0:	14 c0       	rjmp	.+40     	; 0x32ca <csp_route_security_check+0x80>
    32a2:	f8 01       	movw	r30, r16
    32a4:	82 85       	ldd	r24, Z+10	; 0x0a
    32a6:	83 ff       	sbrs	r24, 3
    32a8:	0e c0       	rjmp	.+28     	; 0x32c6 <csp_route_security_check+0x7c>
    32aa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    32ac:	9f 8d       	ldd	r25, Y+31	; 0x1f
    32ae:	a8 a1       	ldd	r26, Y+32	; 0x20
    32b0:	b9 a1       	ldd	r27, Y+33	; 0x21
    32b2:	01 96       	adiw	r24, 0x01	; 1
    32b4:	a1 1d       	adc	r26, r1
    32b6:	b1 1d       	adc	r27, r1
    32b8:	8e 8f       	std	Y+30, r24	; 0x1e
    32ba:	9f 8f       	std	Y+31, r25	; 0x1f
    32bc:	a8 a3       	std	Y+32, r26	; 0x20
    32be:	b9 a3       	std	Y+33, r27	; 0x21
    32c0:	8b ef       	ldi	r24, 0xFB	; 251
    32c2:	9f ef       	ldi	r25, 0xFF	; 255
    32c4:	02 c0       	rjmp	.+4      	; 0x32ca <csp_route_security_check+0x80>
    32c6:	80 e0       	ldi	r24, 0x00	; 0
    32c8:	90 e0       	ldi	r25, 0x00	; 0
    32ca:	df 91       	pop	r29
    32cc:	cf 91       	pop	r28
    32ce:	1f 91       	pop	r17
    32d0:	0f 91       	pop	r16
    32d2:	08 95       	ret

000032d4 <csp_route_next_packet>:
    32d4:	2f ef       	ldi	r18, 0xFF	; 255
    32d6:	3f ef       	ldi	r19, 0xFF	; 255
    32d8:	40 e0       	ldi	r20, 0x00	; 0
    32da:	50 e0       	ldi	r21, 0x00	; 0
    32dc:	bc 01       	movw	r22, r24
    32de:	80 91 34 3e 	lds	r24, 0x3E34
    32e2:	90 91 35 3e 	lds	r25, 0x3E35
    32e6:	58 d8       	rcall	.-3920   	; 0x2398 <csp_queue_dequeue>
    32e8:	01 97       	sbiw	r24, 0x01	; 1
    32ea:	19 f0       	breq	.+6      	; 0x32f2 <csp_route_next_packet+0x1e>
    32ec:	8d ef       	ldi	r24, 0xFD	; 253
    32ee:	9f ef       	ldi	r25, 0xFF	; 255
    32f0:	08 95       	ret
    32f2:	80 e0       	ldi	r24, 0x00	; 0
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	08 95       	ret

000032f8 <csp_route_start_task>:
    32f8:	ef 92       	push	r14
    32fa:	ff 92       	push	r15
    32fc:	0f 93       	push	r16
    32fe:	1f 93       	push	r17
    3300:	0f 2e       	mov	r0, r31
    3302:	f6 e3       	ldi	r31, 0x36	; 54
    3304:	ef 2e       	mov	r14, r31
    3306:	fe e3       	ldi	r31, 0x3E	; 62
    3308:	ff 2e       	mov	r15, r31
    330a:	f0 2d       	mov	r31, r0
    330c:	8b 01       	movw	r16, r22
    330e:	20 e0       	ldi	r18, 0x00	; 0
    3310:	30 e0       	ldi	r19, 0x00	; 0
    3312:	ac 01       	movw	r20, r24
    3314:	6e e8       	ldi	r22, 0x8E	; 142
    3316:	70 e2       	ldi	r23, 0x20	; 32
    3318:	80 e5       	ldi	r24, 0x50	; 80
    331a:	9a e1       	ldi	r25, 0x1A	; 26
    331c:	09 d9       	rcall	.-3566   	; 0x2530 <csp_thread_create>
    331e:	21 e0       	ldi	r18, 0x01	; 1
    3320:	30 e0       	ldi	r19, 0x00	; 0
    3322:	89 2b       	or	r24, r25
    3324:	11 f4       	brne	.+4      	; 0x332a <csp_route_start_task+0x32>
    3326:	20 e0       	ldi	r18, 0x00	; 0
    3328:	30 e0       	ldi	r19, 0x00	; 0
    332a:	88 27       	eor	r24, r24
    332c:	99 27       	eor	r25, r25
    332e:	82 1b       	sub	r24, r18
    3330:	93 0b       	sbc	r25, r19
    3332:	1f 91       	pop	r17
    3334:	0f 91       	pop	r16
    3336:	ff 90       	pop	r15
    3338:	ef 90       	pop	r14
    333a:	08 95       	ret

0000333c <csp_route_get_if_by_name>:
    333c:	0f 93       	push	r16
    333e:	1f 93       	push	r17
    3340:	cf 93       	push	r28
    3342:	df 93       	push	r29
    3344:	8c 01       	movw	r16, r24
    3346:	c0 91 9b 3e 	lds	r28, 0x3E9B
    334a:	d0 91 9c 3e 	lds	r29, 0x3E9C
    334e:	20 97       	sbiw	r28, 0x00	; 0
    3350:	71 f0       	breq	.+28     	; 0x336e <csp_route_get_if_by_name+0x32>
    3352:	4a e0       	ldi	r20, 0x0A	; 10
    3354:	50 e0       	ldi	r21, 0x00	; 0
    3356:	b8 01       	movw	r22, r16
    3358:	88 81       	ld	r24, Y
    335a:	99 81       	ldd	r25, Y+1	; 0x01
    335c:	0e 94 57 2c 	call	0x58ae	; 0x58ae <strncmp>
    3360:	89 2b       	or	r24, r25
    3362:	29 f0       	breq	.+10     	; 0x336e <csp_route_get_if_by_name+0x32>
    3364:	0a a8       	ldd	r0, Y+50	; 0x32
    3366:	db a9       	ldd	r29, Y+51	; 0x33
    3368:	c0 2d       	mov	r28, r0
    336a:	20 97       	sbiw	r28, 0x00	; 0
    336c:	91 f7       	brne	.-28     	; 0x3352 <csp_route_get_if_by_name+0x16>
    336e:	ce 01       	movw	r24, r28
    3370:	df 91       	pop	r29
    3372:	cf 91       	pop	r28
    3374:	1f 91       	pop	r17
    3376:	0f 91       	pop	r16
    3378:	08 95       	ret

0000337a <csp_route_add_if>:
    337a:	a0 91 9b 3e 	lds	r26, 0x3E9B
    337e:	b0 91 9c 3e 	lds	r27, 0x3E9C
    3382:	10 97       	sbiw	r26, 0x00	; 0
    3384:	41 f4       	brne	.+16     	; 0x3396 <csp_route_add_if+0x1c>
    3386:	80 93 9b 3e 	sts	0x3E9B, r24
    338a:	90 93 9c 3e 	sts	0x3E9C, r25
    338e:	fc 01       	movw	r30, r24
    3390:	12 aa       	std	Z+50, r1	; 0x32
    3392:	13 aa       	std	Z+51, r1	; 0x33
    3394:	08 95       	ret
    3396:	a8 17       	cp	r26, r24
    3398:	b9 07       	cpc	r27, r25
    339a:	b9 f0       	breq	.+46     	; 0x33ca <csp_route_add_if+0x50>
    339c:	d2 96       	adiw	r26, 0x32	; 50
    339e:	ed 91       	ld	r30, X+
    33a0:	fc 91       	ld	r31, X
    33a2:	d3 97       	sbiw	r26, 0x33	; 51
    33a4:	30 97       	sbiw	r30, 0x00	; 0
    33a6:	39 f4       	brne	.+14     	; 0x33b6 <csp_route_add_if+0x3c>
    33a8:	0a c0       	rjmp	.+20     	; 0x33be <csp_route_add_if+0x44>
    33aa:	22 a9       	ldd	r18, Z+50	; 0x32
    33ac:	33 a9       	ldd	r19, Z+51	; 0x33
    33ae:	21 15       	cp	r18, r1
    33b0:	31 05       	cpc	r19, r1
    33b2:	31 f0       	breq	.+12     	; 0x33c0 <csp_route_add_if+0x46>
    33b4:	f9 01       	movw	r30, r18
    33b6:	8e 17       	cp	r24, r30
    33b8:	9f 07       	cpc	r25, r31
    33ba:	b9 f7       	brne	.-18     	; 0x33aa <csp_route_add_if+0x30>
    33bc:	08 95       	ret
    33be:	fd 01       	movw	r30, r26
    33c0:	82 ab       	std	Z+50, r24	; 0x32
    33c2:	93 ab       	std	Z+51, r25	; 0x33
    33c4:	fc 01       	movw	r30, r24
    33c6:	12 aa       	std	Z+50, r1	; 0x32
    33c8:	13 aa       	std	Z+51, r1	; 0x33
    33ca:	08 95       	ret

000033cc <csp_route_set>:
    33cc:	0f 93       	push	r16
    33ce:	1f 93       	push	r17
    33d0:	cf 93       	push	r28
    33d2:	df 93       	push	r29
    33d4:	18 2f       	mov	r17, r24
    33d6:	eb 01       	movw	r28, r22
    33d8:	04 2f       	mov	r16, r20
    33da:	20 97       	sbiw	r28, 0x00	; 0
    33dc:	99 f0       	breq	.+38     	; 0x3404 <csp_route_set+0x38>
    33de:	cb 01       	movw	r24, r22
    33e0:	cc df       	rcall	.-104    	; 0x337a <csp_route_add_if>
    33e2:	11 32       	cpi	r17, 0x21	; 33
    33e4:	90 f4       	brcc	.+36     	; 0x340a <csp_route_set+0x3e>
    33e6:	81 2f       	mov	r24, r17
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	fc 01       	movw	r30, r24
    33ec:	ee 0f       	add	r30, r30
    33ee:	ff 1f       	adc	r31, r31
    33f0:	e8 0f       	add	r30, r24
    33f2:	f9 1f       	adc	r31, r25
    33f4:	e8 5c       	subi	r30, 0xC8	; 200
    33f6:	f1 4c       	sbci	r31, 0xC1	; 193
    33f8:	c0 83       	st	Z, r28
    33fa:	d1 83       	std	Z+1, r29	; 0x01
    33fc:	02 83       	std	Z+2, r16	; 0x02
    33fe:	80 e0       	ldi	r24, 0x00	; 0
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	05 c0       	rjmp	.+10     	; 0x340e <csp_route_set+0x42>
    3404:	8e ef       	ldi	r24, 0xFE	; 254
    3406:	9f ef       	ldi	r25, 0xFF	; 255
    3408:	02 c0       	rjmp	.+4      	; 0x340e <csp_route_set+0x42>
    340a:	8e ef       	ldi	r24, 0xFE	; 254
    340c:	9f ef       	ldi	r25, 0xFF	; 255
    340e:	df 91       	pop	r29
    3410:	cf 91       	pop	r28
    3412:	1f 91       	pop	r17
    3414:	0f 91       	pop	r16
    3416:	08 95       	ret

00003418 <csp_route_table_init>:
    3418:	83 e6       	ldi	r24, 0x63	; 99
    341a:	e8 e3       	ldi	r30, 0x38	; 56
    341c:	fe e3       	ldi	r31, 0x3E	; 62
    341e:	df 01       	movw	r26, r30
    3420:	1d 92       	st	X+, r1
    3422:	8a 95       	dec	r24
    3424:	e9 f7       	brne	.-6      	; 0x3420 <csp_route_table_init+0x8>
    3426:	80 91 34 3e 	lds	r24, 0x3E34
    342a:	90 91 35 3e 	lds	r25, 0x3E35
    342e:	89 2b       	or	r24, r25
    3430:	61 f4       	brne	.+24     	; 0x344a <csp_route_table_init+0x32>
    3432:	64 e0       	ldi	r22, 0x04	; 4
    3434:	70 e0       	ldi	r23, 0x00	; 0
    3436:	8a e0       	ldi	r24, 0x0A	; 10
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	0e 94 b7 11 	call	0x236e	; 0x236e <csp_queue_create>
    343e:	80 93 34 3e 	sts	0x3E34, r24
    3442:	90 93 35 3e 	sts	0x3E35, r25
    3446:	89 2b       	or	r24, r25
    3448:	71 f0       	breq	.+28     	; 0x3466 <csp_route_table_init+0x4e>
    344a:	4f ef       	ldi	r20, 0xFF	; 255
    344c:	6b e3       	ldi	r22, 0x3B	; 59
    344e:	70 e2       	ldi	r23, 0x20	; 32
    3450:	80 91 47 3f 	lds	r24, 0x3F47
    3454:	bb df       	rcall	.-138    	; 0x33cc <csp_route_set>
    3456:	4f ef       	ldi	r20, 0xFF	; 255
    3458:	6b e3       	ldi	r22, 0x3B	; 59
    345a:	70 e2       	ldi	r23, 0x20	; 32
    345c:	80 e2       	ldi	r24, 0x20	; 32
    345e:	b6 df       	rcall	.-148    	; 0x33cc <csp_route_set>
    3460:	80 e0       	ldi	r24, 0x00	; 0
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	08 95       	ret
    3466:	8f ef       	ldi	r24, 0xFF	; 255
    3468:	9f ef       	ldi	r25, 0xFF	; 255
    346a:	08 95       	ret

0000346c <csp_route_if>:
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	fc 01       	movw	r30, r24
    3470:	ee 0f       	add	r30, r30
    3472:	ff 1f       	adc	r31, r31
    3474:	e8 0f       	add	r30, r24
    3476:	f9 1f       	adc	r31, r25
    3478:	e8 5c       	subi	r30, 0xC8	; 200
    347a:	f1 4c       	sbci	r31, 0xC1	; 193
    347c:	20 81       	ld	r18, Z
    347e:	31 81       	ldd	r19, Z+1	; 0x01
    3480:	23 2b       	or	r18, r19
    3482:	11 f0       	breq	.+4      	; 0x3488 <csp_route_if+0x1c>
    3484:	cf 01       	movw	r24, r30
    3486:	08 95       	ret
    3488:	80 91 98 3e 	lds	r24, 0x3E98
    348c:	90 91 99 3e 	lds	r25, 0x3E99
    3490:	89 2b       	or	r24, r25
    3492:	19 f0       	breq	.+6      	; 0x349a <csp_route_if+0x2e>
    3494:	88 e9       	ldi	r24, 0x98	; 152
    3496:	9e e3       	ldi	r25, 0x3E	; 62
    3498:	08 95       	ret
    349a:	80 e0       	ldi	r24, 0x00	; 0
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	08 95       	ret

000034a0 <csp_task_router>:
    34a0:	cf 93       	push	r28
    34a2:	df 93       	push	r29
    34a4:	00 d0       	rcall	.+0      	; 0x34a6 <csp_task_router+0x6>
    34a6:	00 d0       	rcall	.+0      	; 0x34a8 <csp_task_router+0x8>
    34a8:	cd b7       	in	r28, 0x3d	; 61
    34aa:	de b7       	in	r29, 0x3e	; 62
    34ac:	ce 01       	movw	r24, r28
    34ae:	01 96       	adiw	r24, 0x01	; 1
    34b0:	11 df       	rcall	.-478    	; 0x32d4 <csp_route_next_packet>
    34b2:	89 2b       	or	r24, r25
    34b4:	d9 f7       	brne	.-10     	; 0x34ac <csp_task_router+0xc>
    34b6:	cb 80       	ldd	r12, Y+3	; 0x03
    34b8:	dc 80       	ldd	r13, Y+4	; 0x04
    34ba:	cd 82       	std	Y+5, r12	; 0x05
    34bc:	de 82       	std	Y+6, r13	; 0x06
    34be:	d6 01       	movw	r26, r12
    34c0:	1c 96       	adiw	r26, 0x0c	; 12
    34c2:	9c 91       	ld	r25, X
    34c4:	1c 97       	sbiw	r26, 0x0c	; 12
    34c6:	92 95       	swap	r25
    34c8:	9f 70       	andi	r25, 0x0F	; 15
    34ca:	1d 96       	adiw	r26, 0x0d	; 13
    34cc:	8c 91       	ld	r24, X
    34ce:	81 70       	andi	r24, 0x01	; 1
    34d0:	82 95       	swap	r24
    34d2:	80 7f       	andi	r24, 0xF0	; 240
    34d4:	89 2b       	or	r24, r25
    34d6:	48 2f       	mov	r20, r24
    34d8:	50 e0       	ldi	r21, 0x00	; 0
    34da:	20 91 47 3f 	lds	r18, 0x3F47
    34de:	30 e0       	ldi	r19, 0x00	; 0
    34e0:	42 17       	cp	r20, r18
    34e2:	53 07       	cpc	r21, r19
    34e4:	21 f1       	breq	.+72     	; 0x352e <csp_task_router+0x8e>
    34e6:	8f 31       	cpi	r24, 0x1F	; 31
    34e8:	11 f1       	breq	.+68     	; 0x352e <csp_task_router+0x8e>
    34ea:	c0 df       	rcall	.-128    	; 0x346c <csp_route_if>
    34ec:	00 97       	sbiw	r24, 0x00	; 0
    34ee:	59 f0       	breq	.+22     	; 0x3506 <csp_task_router+0x66>
    34f0:	dc 01       	movw	r26, r24
    34f2:	ed 91       	ld	r30, X+
    34f4:	fc 91       	ld	r31, X
    34f6:	89 81       	ldd	r24, Y+1	; 0x01
    34f8:	9a 81       	ldd	r25, Y+2	; 0x02
    34fa:	e8 17       	cp	r30, r24
    34fc:	f9 07       	cpc	r31, r25
    34fe:	31 f4       	brne	.+12     	; 0x350c <csp_task_router+0x6c>
    3500:	81 85       	ldd	r24, Z+9	; 0x09
    3502:	81 11       	cpse	r24, r1
    3504:	03 c0       	rjmp	.+6      	; 0x350c <csp_task_router+0x6c>
    3506:	c6 01       	movw	r24, r12
    3508:	48 d9       	rcall	.-3440   	; 0x279a <csp_buffer_free>
    350a:	d0 cf       	rjmp	.-96     	; 0x34ac <csp_task_router+0xc>
    350c:	f6 01       	movw	r30, r12
    350e:	62 85       	ldd	r22, Z+10	; 0x0a
    3510:	73 85       	ldd	r23, Z+11	; 0x0b
    3512:	84 85       	ldd	r24, Z+12	; 0x0c
    3514:	95 85       	ldd	r25, Z+13	; 0x0d
    3516:	00 e0       	ldi	r16, 0x00	; 0
    3518:	10 e0       	ldi	r17, 0x00	; 0
    351a:	98 01       	movw	r18, r16
    351c:	a6 01       	movw	r20, r12
    351e:	dd dc       	rcall	.-1606   	; 0x2eda <csp_send_direct>
    3520:	89 2b       	or	r24, r25
    3522:	09 f4       	brne	.+2      	; 0x3526 <csp_task_router+0x86>
    3524:	c3 cf       	rjmp	.-122    	; 0x34ac <csp_task_router+0xc>
    3526:	8d 81       	ldd	r24, Y+5	; 0x05
    3528:	9e 81       	ldd	r25, Y+6	; 0x06
    352a:	37 d9       	rcall	.-3474   	; 0x279a <csp_buffer_free>
    352c:	bf cf       	rjmp	.-130    	; 0x34ac <csp_task_router+0xc>
    352e:	d6 01       	movw	r26, r12
    3530:	1b 96       	adiw	r26, 0x0b	; 11
    3532:	9c 91       	ld	r25, X
    3534:	1b 97       	sbiw	r26, 0x0b	; 11
    3536:	92 95       	swap	r25
    3538:	96 95       	lsr	r25
    353a:	96 95       	lsr	r25
    353c:	93 70       	andi	r25, 0x03	; 3
    353e:	1c 96       	adiw	r26, 0x0c	; 12
    3540:	8c 91       	ld	r24, X
    3542:	8f 70       	andi	r24, 0x0F	; 15
    3544:	88 0f       	add	r24, r24
    3546:	88 0f       	add	r24, r24
    3548:	89 2b       	or	r24, r25
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	0b de       	rcall	.-1002   	; 0x3164 <csp_port_get_socket>
    354e:	8c 01       	movw	r16, r24
    3550:	00 97       	sbiw	r24, 0x00	; 0
    3552:	09 f4       	brne	.+2      	; 0x3556 <csp_task_router+0xb6>
    3554:	b5 c0       	rjmp	.+362    	; 0x36c0 <csp_task_router+0x220>
    3556:	fc 01       	movw	r30, r24
    3558:	64 89       	ldd	r22, Z+20	; 0x14
    355a:	75 89       	ldd	r23, Z+21	; 0x15
    355c:	86 89       	ldd	r24, Z+22	; 0x16
    355e:	97 89       	ldd	r25, Z+23	; 0x17
    3560:	70 ff       	sbrs	r23, 0
    3562:	bd c0       	rjmp	.+378    	; 0x36de <csp_task_router+0x23e>
    3564:	2d 81       	ldd	r18, Y+5	; 0x05
    3566:	3e 81       	ldd	r19, Y+6	; 0x06
    3568:	49 81       	ldd	r20, Y+1	; 0x01
    356a:	5a 81       	ldd	r21, Y+2	; 0x02
    356c:	6e de       	rcall	.-804    	; 0x324a <csp_route_security_check>
    356e:	99 23       	and	r25, r25
    3570:	24 f4       	brge	.+8      	; 0x357a <csp_task_router+0xda>
    3572:	8d 81       	ldd	r24, Y+5	; 0x05
    3574:	9e 81       	ldd	r25, Y+6	; 0x06
    3576:	11 d9       	rcall	.-3550   	; 0x279a <csp_buffer_free>
    3578:	99 cf       	rjmp	.-206    	; 0x34ac <csp_task_router+0xc>
    357a:	20 e0       	ldi	r18, 0x00	; 0
    357c:	30 e0       	ldi	r19, 0x00	; 0
    357e:	a9 01       	movw	r20, r18
    3580:	be 01       	movw	r22, r28
    3582:	6b 5f       	subi	r22, 0xFB	; 251
    3584:	7f 4f       	sbci	r23, 0xFF	; 255
    3586:	d8 01       	movw	r26, r16
    3588:	1e 96       	adiw	r26, 0x0e	; 14
    358a:	8d 91       	ld	r24, X+
    358c:	9c 91       	ld	r25, X
    358e:	1f 97       	sbiw	r26, 0x0f	; 15
    3590:	0e 94 ba 11 	call	0x2374	; 0x2374 <csp_queue_enqueue>
    3594:	01 97       	sbiw	r24, 0x01	; 1
    3596:	09 f4       	brne	.+2      	; 0x359a <csp_task_router+0xfa>
    3598:	89 cf       	rjmp	.-238    	; 0x34ac <csp_task_router+0xc>
    359a:	8d 81       	ldd	r24, Y+5	; 0x05
    359c:	9e 81       	ldd	r25, Y+6	; 0x06
    359e:	fd d8       	rcall	.-3590   	; 0x279a <csp_buffer_free>
    35a0:	85 cf       	rjmp	.-246    	; 0x34ac <csp_task_router+0xc>
    35a2:	8d 81       	ldd	r24, Y+5	; 0x05
    35a4:	9e 81       	ldd	r25, Y+6	; 0x06
    35a6:	f9 d8       	rcall	.-3598   	; 0x279a <csp_buffer_free>
    35a8:	81 cf       	rjmp	.-254    	; 0x34ac <csp_task_router+0xc>
    35aa:	2d 81       	ldd	r18, Y+5	; 0x05
    35ac:	3e 81       	ldd	r19, Y+6	; 0x06
    35ae:	49 81       	ldd	r20, Y+1	; 0x01
    35b0:	5a 81       	ldd	r21, Y+2	; 0x02
    35b2:	f8 01       	movw	r30, r16
    35b4:	64 89       	ldd	r22, Z+20	; 0x14
    35b6:	75 89       	ldd	r23, Z+21	; 0x15
    35b8:	86 89       	ldd	r24, Z+22	; 0x16
    35ba:	97 89       	ldd	r25, Z+23	; 0x17
    35bc:	46 de       	rcall	.-884    	; 0x324a <csp_route_security_check>
    35be:	99 23       	and	r25, r25
    35c0:	24 f4       	brge	.+8      	; 0x35ca <csp_task_router+0x12a>
    35c2:	8d 81       	ldd	r24, Y+5	; 0x05
    35c4:	9e 81       	ldd	r25, Y+6	; 0x06
    35c6:	e9 d8       	rcall	.-3630   	; 0x279a <csp_buffer_free>
    35c8:	71 cf       	rjmp	.-286    	; 0x34ac <csp_task_router+0xc>
    35ca:	ed 81       	ldd	r30, Y+5	; 0x05
    35cc:	fe 81       	ldd	r31, Y+6	; 0x06
    35ce:	95 85       	ldd	r25, Z+13	; 0x0d
    35d0:	89 2f       	mov	r24, r25
    35d2:	80 7c       	andi	r24, 0xC0	; 192
    35d4:	2f 2d       	mov	r18, r15
    35d6:	2f 73       	andi	r18, 0x3F	; 63
    35d8:	f2 2e       	mov	r15, r18
    35da:	f8 2a       	or	r15, r24
    35dc:	80 91 47 3f 	lds	r24, 0x3F47
    35e0:	8f 71       	andi	r24, 0x1F	; 31
    35e2:	88 0f       	add	r24, r24
    35e4:	2f 2d       	mov	r18, r15
    35e6:	21 7c       	andi	r18, 0xC1	; 193
    35e8:	f2 2e       	mov	r15, r18
    35ea:	f8 2a       	or	r15, r24
    35ec:	96 95       	lsr	r25
    35ee:	94 fb       	bst	r25, 4
    35f0:	88 27       	eor	r24, r24
    35f2:	80 f9       	bld	r24, 0
    35f4:	80 fb       	bst	r24, 0
    35f6:	f0 f8       	bld	r15, 0
    35f8:	83 85       	ldd	r24, Z+11	; 0x0b
    35fa:	48 2f       	mov	r20, r24
    35fc:	4f 73       	andi	r20, 0x3F	; 63
    35fe:	46 95       	lsr	r20
    3600:	46 95       	lsr	r20
    3602:	92 95       	swap	r25
    3604:	90 7f       	andi	r25, 0xF0	; 240
    3606:	49 2b       	or	r20, r25
    3608:	98 2f       	mov	r25, r24
    360a:	92 95       	swap	r25
    360c:	96 95       	lsr	r25
    360e:	96 95       	lsr	r25
    3610:	93 70       	andi	r25, 0x03	; 3
    3612:	34 85       	ldd	r19, Z+12	; 0x0c
    3614:	3f 70       	andi	r19, 0x0F	; 15
    3616:	33 0f       	add	r19, r19
    3618:	33 0f       	add	r19, r19
    361a:	39 2b       	or	r19, r25
    361c:	82 95       	swap	r24
    361e:	88 0f       	add	r24, r24
    3620:	88 0f       	add	r24, r24
    3622:	80 7c       	andi	r24, 0xC0	; 192
    3624:	38 2b       	or	r19, r24
    3626:	22 85       	ldd	r18, Z+10	; 0x0a
    3628:	62 85       	ldd	r22, Z+10	; 0x0a
    362a:	73 85       	ldd	r23, Z+11	; 0x0b
    362c:	84 85       	ldd	r24, Z+12	; 0x0c
    362e:	95 85       	ldd	r25, Z+13	; 0x0d
    3630:	5f 2d       	mov	r21, r15
    3632:	20 da       	rcall	.-3008   	; 0x2a74 <csp_conn_new>
    3634:	6c 01       	movw	r12, r24
    3636:	00 97       	sbiw	r24, 0x00	; 0
    3638:	21 f4       	brne	.+8      	; 0x3642 <csp_task_router+0x1a2>
    363a:	8d 81       	ldd	r24, Y+5	; 0x05
    363c:	9e 81       	ldd	r25, Y+6	; 0x06
    363e:	ad d8       	rcall	.-3750   	; 0x279a <csp_buffer_free>
    3640:	35 cf       	rjmp	.-406    	; 0x34ac <csp_task_router+0xc>
    3642:	d8 01       	movw	r26, r16
    3644:	1e 96       	adiw	r26, 0x0e	; 14
    3646:	8d 91       	ld	r24, X+
    3648:	9c 91       	ld	r25, X
    364a:	1f 97       	sbiw	r26, 0x0f	; 15
    364c:	f6 01       	movw	r30, r12
    364e:	86 87       	std	Z+14, r24	; 0x0e
    3650:	97 87       	std	Z+15, r25	; 0x0f
    3652:	54 96       	adiw	r26, 0x14	; 20
    3654:	8d 91       	ld	r24, X+
    3656:	9d 91       	ld	r25, X+
    3658:	0d 90       	ld	r0, X+
    365a:	bc 91       	ld	r27, X
    365c:	a0 2d       	mov	r26, r0
    365e:	84 8b       	std	Z+20, r24	; 0x14
    3660:	95 8b       	std	Z+21, r25	; 0x15
    3662:	a6 8b       	std	Z+22, r26	; 0x16
    3664:	b7 8b       	std	Z+23, r27	; 0x17
    3666:	12 c0       	rjmp	.+36     	; 0x368c <csp_task_router+0x1ec>
    3668:	2d 81       	ldd	r18, Y+5	; 0x05
    366a:	3e 81       	ldd	r19, Y+6	; 0x06
    366c:	49 81       	ldd	r20, Y+1	; 0x01
    366e:	5a 81       	ldd	r21, Y+2	; 0x02
    3670:	d6 01       	movw	r26, r12
    3672:	54 96       	adiw	r26, 0x14	; 20
    3674:	6d 91       	ld	r22, X+
    3676:	7d 91       	ld	r23, X+
    3678:	8d 91       	ld	r24, X+
    367a:	9c 91       	ld	r25, X
    367c:	57 97       	sbiw	r26, 0x17	; 23
    367e:	e5 dd       	rcall	.-1078   	; 0x324a <csp_route_security_check>
    3680:	99 23       	and	r25, r25
    3682:	24 f4       	brge	.+8      	; 0x368c <csp_task_router+0x1ec>
    3684:	8d 81       	ldd	r24, Y+5	; 0x05
    3686:	9e 81       	ldd	r25, Y+6	; 0x06
    3688:	88 d8       	rcall	.-3824   	; 0x279a <csp_buffer_free>
    368a:	10 cf       	rjmp	.-480    	; 0x34ac <csp_task_router+0xc>
    368c:	8d 81       	ldd	r24, Y+5	; 0x05
    368e:	9e 81       	ldd	r25, Y+6	; 0x06
    3690:	fc 01       	movw	r30, r24
    3692:	22 85       	ldd	r18, Z+10	; 0x0a
    3694:	21 ff       	sbrs	r18, 1
    3696:	10 c0       	rjmp	.+32     	; 0x36b8 <csp_task_router+0x218>
    3698:	e9 81       	ldd	r30, Y+1	; 0x01
    369a:	fa 81       	ldd	r31, Y+2	; 0x02
    369c:	46 89       	ldd	r20, Z+22	; 0x16
    369e:	57 89       	ldd	r21, Z+23	; 0x17
    36a0:	60 8d       	ldd	r22, Z+24	; 0x18
    36a2:	71 8d       	ldd	r23, Z+25	; 0x19
    36a4:	4f 5f       	subi	r20, 0xFF	; 255
    36a6:	5f 4f       	sbci	r21, 0xFF	; 255
    36a8:	6f 4f       	sbci	r22, 0xFF	; 255
    36aa:	7f 4f       	sbci	r23, 0xFF	; 255
    36ac:	46 8b       	std	Z+22, r20	; 0x16
    36ae:	57 8b       	std	Z+23, r21	; 0x17
    36b0:	60 8f       	std	Z+24, r22	; 0x18
    36b2:	71 8f       	std	Z+25, r23	; 0x19
    36b4:	72 d8       	rcall	.-3868   	; 0x279a <csp_buffer_free>
    36b6:	fa ce       	rjmp	.-524    	; 0x34ac <csp_task_router+0xc>
    36b8:	bc 01       	movw	r22, r24
    36ba:	c6 01       	movw	r24, r12
    36bc:	8a d3       	rcall	.+1812   	; 0x3dd2 <csp_udp_new_packet>
    36be:	f6 ce       	rjmp	.-532    	; 0x34ac <csp_task_router+0xc>
    36c0:	ed 81       	ldd	r30, Y+5	; 0x05
    36c2:	fe 81       	ldd	r31, Y+6	; 0x06
    36c4:	62 85       	ldd	r22, Z+10	; 0x0a
    36c6:	73 85       	ldd	r23, Z+11	; 0x0b
    36c8:	84 85       	ldd	r24, Z+12	; 0x0c
    36ca:	95 85       	ldd	r25, Z+13	; 0x0d
    36cc:	20 e0       	ldi	r18, 0x00	; 0
    36ce:	3f ef       	ldi	r19, 0xFF	; 255
    36d0:	4f ef       	ldi	r20, 0xFF	; 255
    36d2:	5f e3       	ldi	r21, 0x3F	; 63
    36d4:	0f d9       	rcall	.-3554   	; 0x28f4 <csp_conn_find>
    36d6:	6c 01       	movw	r12, r24
    36d8:	00 97       	sbiw	r24, 0x00	; 0
    36da:	31 f6       	brne	.-116    	; 0x3668 <csp_task_router+0x1c8>
    36dc:	62 cf       	rjmp	.-316    	; 0x35a2 <csp_task_router+0x102>
    36de:	ed 81       	ldd	r30, Y+5	; 0x05
    36e0:	fe 81       	ldd	r31, Y+6	; 0x06
    36e2:	62 85       	ldd	r22, Z+10	; 0x0a
    36e4:	73 85       	ldd	r23, Z+11	; 0x0b
    36e6:	84 85       	ldd	r24, Z+12	; 0x0c
    36e8:	95 85       	ldd	r25, Z+13	; 0x0d
    36ea:	20 e0       	ldi	r18, 0x00	; 0
    36ec:	3f ef       	ldi	r19, 0xFF	; 255
    36ee:	4f ef       	ldi	r20, 0xFF	; 255
    36f0:	5f e3       	ldi	r21, 0x3F	; 63
    36f2:	00 d9       	rcall	.-3584   	; 0x28f4 <csp_conn_find>
    36f4:	6c 01       	movw	r12, r24
    36f6:	00 97       	sbiw	r24, 0x00	; 0
    36f8:	09 f0       	breq	.+2      	; 0x36fc <csp_task_router+0x25c>
    36fa:	b6 cf       	rjmp	.-148    	; 0x3668 <csp_task_router+0x1c8>
    36fc:	56 cf       	rjmp	.-340    	; 0x35aa <csp_task_router+0x10a>

000036fe <csp_route_enqueue>:
    36fe:	0f 93       	push	r16
    3700:	1f 93       	push	r17
    3702:	01 15       	cp	r16, r1
    3704:	11 05       	cpc	r17, r1
    3706:	19 f4       	brne	.+6      	; 0x370e <csp_route_enqueue+0x10>
    3708:	0e 94 ba 11 	call	0x2374	; 0x2374 <csp_queue_enqueue>
    370c:	03 c0       	rjmp	.+6      	; 0x3714 <csp_route_enqueue+0x16>
    370e:	a8 01       	movw	r20, r16
    3710:	0e 94 c5 11 	call	0x238a	; 0x238a <csp_queue_enqueue_isr>
    3714:	01 97       	sbiw	r24, 0x01	; 1
    3716:	19 f4       	brne	.+6      	; 0x371e <csp_route_enqueue+0x20>
    3718:	80 e0       	ldi	r24, 0x00	; 0
    371a:	90 e0       	ldi	r25, 0x00	; 0
    371c:	02 c0       	rjmp	.+4      	; 0x3722 <csp_route_enqueue+0x24>
    371e:	87 ef       	ldi	r24, 0xF7	; 247
    3720:	9f ef       	ldi	r25, 0xFF	; 255
    3722:	1f 91       	pop	r17
    3724:	0f 91       	pop	r16
    3726:	08 95       	ret

00003728 <csp_new_packet>:

void csp_new_packet(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    3728:	af 92       	push	r10
    372a:	bf 92       	push	r11
    372c:	cf 92       	push	r12
    372e:	df 92       	push	r13
    3730:	ef 92       	push	r14
    3732:	ff 92       	push	r15
    3734:	0f 93       	push	r16
    3736:	1f 93       	push	r17
    3738:	cf 93       	push	r28
    373a:	df 93       	push	r29
    373c:	00 d0       	rcall	.+0      	; 0x373e <csp_new_packet+0x16>
    373e:	1f 92       	push	r1
    3740:	cd b7       	in	r28, 0x3d	; 61
    3742:	de b7       	in	r29, 0x3e	; 62
    3744:	6c 01       	movw	r12, r24
    3746:	7b 01       	movw	r14, r22
    3748:	5a 01       	movw	r10, r20

	int result, fifo;

	if (packet == NULL) {
    374a:	00 97       	sbiw	r24, 0x00	; 0
    374c:	09 f4       	brne	.+2      	; 0x3750 <csp_new_packet+0x28>
    374e:	50 c0       	rjmp	.+160    	; 0x37f0 <csp_new_packet+0xc8>
		csp_log_warn("csp_new packet called with NULL packet\r\n");
		return;
	} else if (interface == NULL) {
    3750:	61 15       	cp	r22, r1
    3752:	71 05       	cpc	r23, r1
    3754:	41 f4       	brne	.+16     	; 0x3766 <csp_new_packet+0x3e>
		csp_log_warn("csp_new packet called with NULL interface\r\n");
		if (pxTaskWoken == NULL)
    3756:	41 15       	cp	r20, r1
    3758:	51 05       	cpc	r21, r1
    375a:	11 f4       	brne	.+4      	; 0x3760 <csp_new_packet+0x38>
			csp_buffer_free(packet);
    375c:	1e d8       	rcall	.-4036   	; 0x279a <csp_buffer_free>
    375e:	48 c0       	rjmp	.+144    	; 0x37f0 <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    3760:	0e 94 95 13 	call	0x272a	; 0x272a <csp_buffer_free_isr>
    3764:	45 c0       	rjmp	.+138    	; 0x37f0 <csp_new_packet+0xc8>
		return;
	}

	csp_route_queue_t queue_element;
	queue_element.interface = interface;
    3766:	69 83       	std	Y+1, r22	; 0x01
    3768:	7a 83       	std	Y+2, r23	; 0x02
	queue_element.outcomingPacket = packet;
    376a:	8b 83       	std	Y+3, r24	; 0x03
    376c:	9c 83       	std	Y+4, r25	; 0x04

	fifo = csp_route_get_fifo(packet->id.pri);
	result = csp_route_enqueue(router_input_fifo[fifo], &queue_element, 0, pxTaskWoken);
    376e:	8a 01       	movw	r16, r20
    3770:	20 e0       	ldi	r18, 0x00	; 0
    3772:	30 e0       	ldi	r19, 0x00	; 0
    3774:	a9 01       	movw	r20, r18
    3776:	be 01       	movw	r22, r28
    3778:	6f 5f       	subi	r22, 0xFF	; 255
    377a:	7f 4f       	sbci	r23, 0xFF	; 255
    377c:	80 91 34 3e 	lds	r24, 0x3E34
    3780:	90 91 35 3e 	lds	r25, 0x3E35
    3784:	bc df       	rcall	.-136    	; 0x36fe <csp_route_enqueue>

	if (result != CSP_ERR_NONE) {
    3786:	89 2b       	or	r24, r25
    3788:	b1 f0       	breq	.+44     	; 0x37b6 <csp_new_packet+0x8e>
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.\r\n");
		interface->drop++;
    378a:	f7 01       	movw	r30, r14
    378c:	82 8d       	ldd	r24, Z+26	; 0x1a
    378e:	93 8d       	ldd	r25, Z+27	; 0x1b
    3790:	a4 8d       	ldd	r26, Z+28	; 0x1c
    3792:	b5 8d       	ldd	r27, Z+29	; 0x1d
    3794:	01 96       	adiw	r24, 0x01	; 1
    3796:	a1 1d       	adc	r26, r1
    3798:	b1 1d       	adc	r27, r1
    379a:	82 8f       	std	Z+26, r24	; 0x1a
    379c:	93 8f       	std	Z+27, r25	; 0x1b
    379e:	a4 8f       	std	Z+28, r26	; 0x1c
    37a0:	b5 8f       	std	Z+29, r27	; 0x1d
		if (pxTaskWoken == NULL)
    37a2:	ab 28       	or	r10, r11
    37a4:	21 f4       	brne	.+8      	; 0x37ae <csp_new_packet+0x86>
			csp_buffer_free(packet);
    37a6:	c6 01       	movw	r24, r12
    37a8:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
    37ac:	21 c0       	rjmp	.+66     	; 0x37f0 <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    37ae:	c6 01       	movw	r24, r12
    37b0:	0e 94 95 13 	call	0x272a	; 0x272a <csp_buffer_free_isr>
    37b4:	1d c0       	rjmp	.+58     	; 0x37f0 <csp_new_packet+0xc8>
	} else {
		interface->rx++;
    37b6:	f7 01       	movw	r30, r14
    37b8:	46 85       	ldd	r20, Z+14	; 0x0e
    37ba:	57 85       	ldd	r21, Z+15	; 0x0f
    37bc:	60 89       	ldd	r22, Z+16	; 0x10
    37be:	71 89       	ldd	r23, Z+17	; 0x11
    37c0:	4f 5f       	subi	r20, 0xFF	; 255
    37c2:	5f 4f       	sbci	r21, 0xFF	; 255
    37c4:	6f 4f       	sbci	r22, 0xFF	; 255
    37c6:	7f 4f       	sbci	r23, 0xFF	; 255
    37c8:	46 87       	std	Z+14, r20	; 0x0e
    37ca:	57 87       	std	Z+15, r21	; 0x0f
    37cc:	60 8b       	std	Z+16, r22	; 0x10
    37ce:	71 8b       	std	Z+17, r23	; 0x11
		interface->rxbytes += packet->length;
    37d0:	f6 01       	movw	r30, r12
    37d2:	20 85       	ldd	r18, Z+8	; 0x08
    37d4:	31 85       	ldd	r19, Z+9	; 0x09
    37d6:	f7 01       	movw	r30, r14
    37d8:	82 a5       	ldd	r24, Z+42	; 0x2a
    37da:	93 a5       	ldd	r25, Z+43	; 0x2b
    37dc:	a4 a5       	ldd	r26, Z+44	; 0x2c
    37de:	b5 a5       	ldd	r27, Z+45	; 0x2d
    37e0:	82 0f       	add	r24, r18
    37e2:	93 1f       	adc	r25, r19
    37e4:	a1 1d       	adc	r26, r1
    37e6:	b1 1d       	adc	r27, r1
    37e8:	82 a7       	std	Z+42, r24	; 0x2a
    37ea:	93 a7       	std	Z+43, r25	; 0x2b
    37ec:	a4 a7       	std	Z+44, r26	; 0x2c
    37ee:	b5 a7       	std	Z+45, r27	; 0x2d
	}

}
    37f0:	24 96       	adiw	r28, 0x04	; 4
    37f2:	cd bf       	out	0x3d, r28	; 61
    37f4:	de bf       	out	0x3e, r29	; 62
    37f6:	df 91       	pop	r29
    37f8:	cf 91       	pop	r28
    37fa:	1f 91       	pop	r17
    37fc:	0f 91       	pop	r16
    37fe:	ff 90       	pop	r15
    3800:	ef 90       	pop	r14
    3802:	df 90       	pop	r13
    3804:	cf 90       	pop	r12
    3806:	bf 90       	pop	r11
    3808:	af 90       	pop	r10
    380a:	08 95       	ret

0000380c <csp_route_get_nexthop_mac>:

uint8_t csp_route_get_nexthop_mac(uint8_t node) {

	csp_route_t * route = csp_route_if(node);
    380c:	2f de       	rcall	.-930    	; 0x346c <csp_route_if>
	return route->nexthop_mac_addr;

}
    380e:	fc 01       	movw	r30, r24
    3810:	82 81       	ldd	r24, Z+2	; 0x02
    3812:	08 95       	ret

00003814 <csp_cmp_handler>:
	return CSP_ERR_NONE;

}

/* CSP Management Protocol handler */
int csp_cmp_handler(csp_conn_t * conn, csp_packet_t * packet) {
    3814:	0f 93       	push	r16
    3816:	1f 93       	push	r17
    3818:	cf 93       	push	r28
    381a:	df 93       	push	r29
    381c:	eb 01       	movw	r28, r22

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    381e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3820:	81 11       	cpse	r24, r1
    3822:	55 c1       	rjmp	.+682    	; 0x3ace <csp_cmp_handler+0x2ba>
		return ret;

	switch (cmp->code) {
    3824:	8f 85       	ldd	r24, Y+15	; 0x0f
    3826:	83 30       	cpi	r24, 0x03	; 3
    3828:	09 f4       	brne	.+2      	; 0x382c <csp_cmp_handler+0x18>
    382a:	6d c0       	rjmp	.+218    	; 0x3906 <csp_cmp_handler+0xf2>
    382c:	30 f4       	brcc	.+12     	; 0x383a <csp_cmp_handler+0x26>
    382e:	81 30       	cpi	r24, 0x01	; 1
    3830:	69 f0       	breq	.+26     	; 0x384c <csp_cmp_handler+0x38>
    3832:	82 30       	cpi	r24, 0x02	; 2
    3834:	09 f4       	brne	.+2      	; 0x3838 <csp_cmp_handler+0x24>
    3836:	4f c0       	rjmp	.+158    	; 0x38d6 <csp_cmp_handler+0xc2>
    3838:	45 c1       	rjmp	.+650    	; 0x3ac4 <csp_cmp_handler+0x2b0>
    383a:	85 30       	cpi	r24, 0x05	; 5
    383c:	09 f4       	brne	.+2      	; 0x3840 <csp_cmp_handler+0x2c>
    383e:	f1 c0       	rjmp	.+482    	; 0x3a22 <csp_cmp_handler+0x20e>
    3840:	08 f4       	brcc	.+2      	; 0x3844 <csp_cmp_handler+0x30>
    3842:	d8 c0       	rjmp	.+432    	; 0x39f4 <csp_cmp_handler+0x1e0>
    3844:	86 30       	cpi	r24, 0x06	; 6
    3846:	09 f4       	brne	.+2      	; 0x384a <csp_cmp_handler+0x36>
    3848:	06 c1       	rjmp	.+524    	; 0x3a56 <csp_cmp_handler+0x242>
    384a:	3c c1       	rjmp	.+632    	; 0x3ac4 <csp_cmp_handler+0x2b0>
#define CSP_RPS_MTU	196

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, GIT_REV, CSP_CMP_IDENT_REV_LEN);
    384c:	44 e1       	ldi	r20, 0x14	; 20
    384e:	50 e0       	ldi	r21, 0x00	; 0
    3850:	62 e9       	ldi	r22, 0x92	; 146
    3852:	70 e2       	ldi	r23, 0x20	; 32
    3854:	ce 01       	movw	r24, r28
    3856:	8e 5b       	subi	r24, 0xBE	; 190
    3858:	9f 4f       	sbci	r25, 0xFF	; 255
    385a:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    385e:	fe 01       	movw	r30, r28
    3860:	eb 5a       	subi	r30, 0xAB	; 171
    3862:	ff 4f       	sbci	r31, 0xFF	; 255
    3864:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    3866:	8c e0       	ldi	r24, 0x0C	; 12
    3868:	ea e9       	ldi	r30, 0x9A	; 154
    386a:	f0 e2       	ldi	r31, 0x20	; 32
    386c:	de 01       	movw	r26, r28
    386e:	aa 5a       	subi	r26, 0xAA	; 170
    3870:	bf 4f       	sbci	r27, 0xFF	; 255
    3872:	01 90       	ld	r0, Z+
    3874:	0d 92       	st	X+, r0
    3876:	8a 95       	dec	r24
    3878:	e1 f7       	brne	.-8      	; 0x3872 <csp_cmp_handler+0x5e>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    387a:	fe 01       	movw	r30, r28
    387c:	ef 59       	subi	r30, 0x9F	; 159
    387e:	ff 4f       	sbci	r31, 0xFF	; 255
    3880:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    3882:	89 e0       	ldi	r24, 0x09	; 9
    3884:	e6 ea       	ldi	r30, 0xA6	; 166
    3886:	f0 e2       	ldi	r31, 0x20	; 32
    3888:	de 01       	movw	r26, r28
    388a:	ae 59       	subi	r26, 0x9E	; 158
    388c:	bf 4f       	sbci	r27, 0xFF	; 255
    388e:	01 90       	ld	r0, Z+
    3890:	0d 92       	st	X+, r0
    3892:	8a 95       	dec	r24
    3894:	e1 f7       	brne	.-8      	; 0x388e <csp_cmp_handler+0x7a>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    3896:	fe 01       	movw	r30, r28
    3898:	e6 59       	subi	r30, 0x96	; 150
    389a:	ff 4f       	sbci	r31, 0xFF	; 255
    389c:	10 82       	st	Z, r1

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    389e:	70 da       	rcall	.-2848   	; 0x2d80 <csp_get_hostname>
    38a0:	44 e1       	ldi	r20, 0x14	; 20
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	bc 01       	movw	r22, r24
    38a6:	ce 01       	movw	r24, r28
    38a8:	40 96       	adiw	r24, 0x10	; 16
    38aa:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';
    38ae:	1b a2       	std	Y+35, r1	; 0x23

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    38b0:	6c da       	rcall	.-2856   	; 0x2d8a <csp_get_model>
    38b2:	4e e1       	ldi	r20, 0x1E	; 30
    38b4:	50 e0       	ldi	r21, 0x00	; 0
    38b6:	bc 01       	movw	r22, r24
    38b8:	ce 01       	movw	r24, r28
    38ba:	84 96       	adiw	r24, 0x24	; 36
    38bc:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    38c0:	fe 01       	movw	r30, r28
    38c2:	ef 5b       	subi	r30, 0xBF	; 191
    38c4:	ff 4f       	sbci	r31, 0xFF	; 255
    38c6:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    38c8:	8d e5       	ldi	r24, 0x5D	; 93
    38ca:	90 e0       	ldi	r25, 0x00	; 0
    38cc:	88 87       	std	Y+8, r24	; 0x08
    38ce:	99 87       	std	Y+9, r25	; 0x09
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
    38d0:	80 e0       	ldi	r24, 0x00	; 0
    38d2:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;
    38d4:	f9 c0       	rjmp	.+498    	; 0x3ac8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
    38d6:	cb 01       	movw	r24, r22
    38d8:	42 96       	adiw	r24, 0x12	; 18
    38da:	30 dd       	rcall	.-1440   	; 0x333c <csp_route_get_if_by_name>
	if (ifc == NULL)
    38dc:	00 97       	sbiw	r24, 0x00	; 0
    38de:	49 f0       	breq	.+18     	; 0x38f2 <csp_cmp_handler+0xde>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    38e0:	49 89       	ldd	r20, Y+17	; 0x11
    38e2:	bc 01       	movw	r22, r24
    38e4:	88 89       	ldd	r24, Y+16	; 0x10
    38e6:	72 dd       	rcall	.-1308   	; 0x33cc <csp_route_set>
    38e8:	89 2b       	or	r24, r25
    38ea:	31 f0       	breq	.+12     	; 0x38f8 <csp_cmp_handler+0xe4>
		return CSP_ERR_INVAL;
    38ec:	8e ef       	ldi	r24, 0xFE	; 254
    38ee:	9f ef       	ldi	r25, 0xFF	; 255
    38f0:	05 c0       	rjmp	.+10     	; 0x38fc <csp_cmp_handler+0xe8>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    38f2:	8e ef       	ldi	r24, 0xFE	; 254
    38f4:	9f ef       	ldi	r25, 0xFF	; 255
    38f6:	02 c0       	rjmp	.+4      	; 0x38fc <csp_cmp_handler+0xe8>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    38f8:	80 e0       	ldi	r24, 0x00	; 0
    38fa:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    38fc:	2f e0       	ldi	r18, 0x0F	; 15
    38fe:	30 e0       	ldi	r19, 0x00	; 0
    3900:	28 87       	std	Y+8, r18	; 0x08
    3902:	39 87       	std	Y+9, r19	; 0x09
			break;
    3904:	e1 c0       	rjmp	.+450    	; 0x3ac8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
    3906:	cb 01       	movw	r24, r22
    3908:	40 96       	adiw	r24, 0x10	; 16
    390a:	18 dd       	rcall	.-1488   	; 0x333c <csp_route_get_if_by_name>
    390c:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    390e:	00 97       	sbiw	r24, 0x00	; 0
    3910:	09 f4       	brne	.+2      	; 0x3914 <csp_cmp_handler+0x100>
    3912:	69 c0       	rjmp	.+210    	; 0x39e6 <csp_cmp_handler+0x1d2>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    3914:	fc 01       	movw	r30, r24
    3916:	62 85       	ldd	r22, Z+10	; 0x0a
    3918:	73 85       	ldd	r23, Z+11	; 0x0b
    391a:	84 85       	ldd	r24, Z+12	; 0x0c
    391c:	95 85       	ldd	r25, Z+13	; 0x0d
    391e:	c6 d9       	rcall	.-3188   	; 0x2cac <csp_hton32>
    3920:	6b 8f       	std	Y+27, r22	; 0x1b
    3922:	7c 8f       	std	Y+28, r23	; 0x1c
    3924:	8d 8f       	std	Y+29, r24	; 0x1d
    3926:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    3928:	f8 01       	movw	r30, r16
    392a:	66 85       	ldd	r22, Z+14	; 0x0e
    392c:	77 85       	ldd	r23, Z+15	; 0x0f
    392e:	80 89       	ldd	r24, Z+16	; 0x10
    3930:	91 89       	ldd	r25, Z+17	; 0x11
    3932:	bc d9       	rcall	.-3208   	; 0x2cac <csp_hton32>
    3934:	6f 8f       	std	Y+31, r22	; 0x1f
    3936:	78 a3       	std	Y+32, r23	; 0x20
    3938:	89 a3       	std	Y+33, r24	; 0x21
    393a:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    393c:	f8 01       	movw	r30, r16
    393e:	62 89       	ldd	r22, Z+18	; 0x12
    3940:	73 89       	ldd	r23, Z+19	; 0x13
    3942:	84 89       	ldd	r24, Z+20	; 0x14
    3944:	95 89       	ldd	r25, Z+21	; 0x15
    3946:	b2 d9       	rcall	.-3228   	; 0x2cac <csp_hton32>
    3948:	6b a3       	std	Y+35, r22	; 0x23
    394a:	7c a3       	std	Y+36, r23	; 0x24
    394c:	8d a3       	std	Y+37, r24	; 0x25
    394e:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    3950:	f8 01       	movw	r30, r16
    3952:	66 89       	ldd	r22, Z+22	; 0x16
    3954:	77 89       	ldd	r23, Z+23	; 0x17
    3956:	80 8d       	ldd	r24, Z+24	; 0x18
    3958:	91 8d       	ldd	r25, Z+25	; 0x19
    395a:	a8 d9       	rcall	.-3248   	; 0x2cac <csp_hton32>
    395c:	6f a3       	std	Y+39, r22	; 0x27
    395e:	78 a7       	std	Y+40, r23	; 0x28
    3960:	89 a7       	std	Y+41, r24	; 0x29
    3962:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    3964:	f8 01       	movw	r30, r16
    3966:	62 8d       	ldd	r22, Z+26	; 0x1a
    3968:	73 8d       	ldd	r23, Z+27	; 0x1b
    396a:	84 8d       	ldd	r24, Z+28	; 0x1c
    396c:	95 8d       	ldd	r25, Z+29	; 0x1d
    396e:	9e d9       	rcall	.-3268   	; 0x2cac <csp_hton32>
    3970:	6b a7       	std	Y+43, r22	; 0x2b
    3972:	7c a7       	std	Y+44, r23	; 0x2c
    3974:	8d a7       	std	Y+45, r24	; 0x2d
    3976:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    3978:	f8 01       	movw	r30, r16
    397a:	66 8d       	ldd	r22, Z+30	; 0x1e
    397c:	77 8d       	ldd	r23, Z+31	; 0x1f
    397e:	80 a1       	ldd	r24, Z+32	; 0x20
    3980:	91 a1       	ldd	r25, Z+33	; 0x21
    3982:	94 d9       	rcall	.-3288   	; 0x2cac <csp_hton32>
    3984:	6f a7       	std	Y+47, r22	; 0x2f
    3986:	78 ab       	std	Y+48, r23	; 0x30
    3988:	89 ab       	std	Y+49, r24	; 0x31
    398a:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    398c:	f8 01       	movw	r30, r16
    398e:	62 a1       	ldd	r22, Z+34	; 0x22
    3990:	73 a1       	ldd	r23, Z+35	; 0x23
    3992:	84 a1       	ldd	r24, Z+36	; 0x24
    3994:	95 a1       	ldd	r25, Z+37	; 0x25
    3996:	8a d9       	rcall	.-3308   	; 0x2cac <csp_hton32>
    3998:	6b ab       	std	Y+51, r22	; 0x33
    399a:	7c ab       	std	Y+52, r23	; 0x34
    399c:	8d ab       	std	Y+53, r24	; 0x35
    399e:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    39a0:	f8 01       	movw	r30, r16
    39a2:	66 a1       	ldd	r22, Z+38	; 0x26
    39a4:	77 a1       	ldd	r23, Z+39	; 0x27
    39a6:	80 a5       	ldd	r24, Z+40	; 0x28
    39a8:	91 a5       	ldd	r25, Z+41	; 0x29
    39aa:	80 d9       	rcall	.-3328   	; 0x2cac <csp_hton32>
    39ac:	6f ab       	std	Y+55, r22	; 0x37
    39ae:	78 af       	std	Y+56, r23	; 0x38
    39b0:	89 af       	std	Y+57, r24	; 0x39
    39b2:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    39b4:	f8 01       	movw	r30, r16
    39b6:	62 a5       	ldd	r22, Z+42	; 0x2a
    39b8:	73 a5       	ldd	r23, Z+43	; 0x2b
    39ba:	84 a5       	ldd	r24, Z+44	; 0x2c
    39bc:	95 a5       	ldd	r25, Z+45	; 0x2d
    39be:	76 d9       	rcall	.-3348   	; 0x2cac <csp_hton32>
    39c0:	6b af       	std	Y+59, r22	; 0x3b
    39c2:	7c af       	std	Y+60, r23	; 0x3c
    39c4:	8d af       	std	Y+61, r24	; 0x3d
    39c6:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    39c8:	f8 01       	movw	r30, r16
    39ca:	66 a5       	ldd	r22, Z+46	; 0x2e
    39cc:	77 a5       	ldd	r23, Z+47	; 0x2f
    39ce:	80 a9       	ldd	r24, Z+48	; 0x30
    39d0:	91 a9       	ldd	r25, Z+49	; 0x31
    39d2:	6c d9       	rcall	.-3368   	; 0x2cac <csp_hton32>
    39d4:	fe 01       	movw	r30, r28
    39d6:	ff 96       	adiw	r30, 0x3f	; 63
    39d8:	60 83       	st	Z, r22
    39da:	71 83       	std	Z+1, r23	; 0x01
    39dc:	82 83       	std	Z+2, r24	; 0x02
    39de:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    39e0:	80 e0       	ldi	r24, 0x00	; 0
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	02 c0       	rjmp	.+4      	; 0x39ea <csp_cmp_handler+0x1d6>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    39e6:	8e ef       	ldi	r24, 0xFE	; 254
    39e8:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    39ea:	25 e3       	ldi	r18, 0x35	; 53
    39ec:	30 e0       	ldi	r19, 0x00	; 0
    39ee:	28 87       	std	Y+8, r18	; 0x08
    39f0:	39 87       	std	Y+9, r19	; 0x09
			break;
    39f2:	6a c0       	rjmp	.+212    	; 0x3ac8 <csp_cmp_handler+0x2b4>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    39f4:	68 89       	ldd	r22, Y+16	; 0x10
    39f6:	79 89       	ldd	r23, Y+17	; 0x11
    39f8:	8a 89       	ldd	r24, Y+18	; 0x12
    39fa:	9b 89       	ldd	r25, Y+19	; 0x13
    39fc:	57 d9       	rcall	.-3410   	; 0x2cac <csp_hton32>
    39fe:	68 8b       	std	Y+16, r22	; 0x10
    3a00:	79 8b       	std	Y+17, r23	; 0x11
    3a02:	8a 8b       	std	Y+18, r24	; 0x12
    3a04:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    3a06:	4c 89       	ldd	r20, Y+20	; 0x14
    3a08:	49 3c       	cpi	r20, 0xC9	; 201
    3a0a:	40 f4       	brcc	.+16     	; 0x3a1c <csp_cmp_handler+0x208>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	memcpy(cmp->peek.data, (void *) (uintptr_t) cmp->peek.addr, cmp->peek.len);
    3a0c:	50 e0       	ldi	r21, 0x00	; 0
    3a0e:	ce 01       	movw	r24, r28
    3a10:	45 96       	adiw	r24, 0x15	; 21
    3a12:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>

	return CSP_ERR_NONE;
    3a16:	80 e0       	ldi	r24, 0x00	; 0
    3a18:	90 e0       	ldi	r25, 0x00	; 0
    3a1a:	56 c0       	rjmp	.+172    	; 0x3ac8 <csp_cmp_handler+0x2b4>

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
		return CSP_ERR_INVAL;
    3a1c:	8e ef       	ldi	r24, 0xFE	; 254
    3a1e:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(if_stats);
			break;

		case CSP_CMP_PEEK:
			ret = do_cmp_peek(cmp);
			break;
    3a20:	53 c0       	rjmp	.+166    	; 0x3ac8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    3a22:	68 89       	ldd	r22, Y+16	; 0x10
    3a24:	79 89       	ldd	r23, Y+17	; 0x11
    3a26:	8a 89       	ldd	r24, Y+18	; 0x12
    3a28:	9b 89       	ldd	r25, Y+19	; 0x13
    3a2a:	40 d9       	rcall	.-3456   	; 0x2cac <csp_hton32>
    3a2c:	dc 01       	movw	r26, r24
    3a2e:	cb 01       	movw	r24, r22
    3a30:	88 8b       	std	Y+16, r24	; 0x10
    3a32:	99 8b       	std	Y+17, r25	; 0x11
    3a34:	aa 8b       	std	Y+18, r26	; 0x12
    3a36:	bb 8b       	std	Y+19, r27	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    3a38:	4c 89       	ldd	r20, Y+20	; 0x14
    3a3a:	49 3c       	cpi	r20, 0xC9	; 201
    3a3c:	48 f4       	brcc	.+18     	; 0x3a50 <csp_cmp_handler+0x23c>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	memcpy((void *) (uintptr_t) cmp->poke.addr, cmp->poke.data, cmp->poke.len);
    3a3e:	50 e0       	ldi	r21, 0x00	; 0
    3a40:	be 01       	movw	r22, r28
    3a42:	6b 5e       	subi	r22, 0xEB	; 235
    3a44:	7f 4f       	sbci	r23, 0xFF	; 255
    3a46:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>

	return CSP_ERR_NONE;
    3a4a:	80 e0       	ldi	r24, 0x00	; 0
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	3c c0       	rjmp	.+120    	; 0x3ac8 <csp_cmp_handler+0x2b4>

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
		return CSP_ERR_INVAL;
    3a50:	8e ef       	ldi	r24, 0xFE	; 254
    3a52:	9f ef       	ldi	r25, 0xFF	; 255
			ret = do_cmp_peek(cmp);
			break;

		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;
    3a54:	39 c0       	rjmp	.+114    	; 0x3ac8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    3a56:	68 89       	ldd	r22, Y+16	; 0x10
    3a58:	79 89       	ldd	r23, Y+17	; 0x11
    3a5a:	8a 89       	ldd	r24, Y+18	; 0x12
    3a5c:	9b 89       	ldd	r25, Y+19	; 0x13
    3a5e:	5b d9       	rcall	.-3402   	; 0x2d16 <csp_ntoh32>
    3a60:	68 8b       	std	Y+16, r22	; 0x10
    3a62:	79 8b       	std	Y+17, r23	; 0x11
    3a64:	8a 8b       	std	Y+18, r24	; 0x12
    3a66:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    3a68:	6c 89       	ldd	r22, Y+20	; 0x14
    3a6a:	7d 89       	ldd	r23, Y+21	; 0x15
    3a6c:	8e 89       	ldd	r24, Y+22	; 0x16
    3a6e:	9f 89       	ldd	r25, Y+23	; 0x17
    3a70:	52 d9       	rcall	.-3420   	; 0x2d16 <csp_ntoh32>
    3a72:	6c 8b       	std	Y+20, r22	; 0x14
    3a74:	7d 8b       	std	Y+21, r23	; 0x15
    3a76:	8e 8b       	std	Y+22, r24	; 0x16
    3a78:	9f 8b       	std	Y+23, r25	; 0x17

	if (cmp->clock.tv_sec != 0) {
    3a7a:	88 89       	ldd	r24, Y+16	; 0x10
    3a7c:	99 89       	ldd	r25, Y+17	; 0x11
    3a7e:	aa 89       	ldd	r26, Y+18	; 0x12
    3a80:	bb 89       	ldd	r27, Y+19	; 0x13
    3a82:	89 2b       	or	r24, r25
    3a84:	8a 2b       	or	r24, r26
    3a86:	8b 2b       	or	r24, r27
    3a88:	21 f0       	breq	.+8      	; 0x3a92 <csp_cmp_handler+0x27e>
		clock_set_time(&cmp->clock);
    3a8a:	ce 01       	movw	r24, r28
    3a8c:	40 96       	adiw	r24, 0x10	; 16
    3a8e:	0e 94 85 04 	call	0x90a	; 0x90a <clock_set_time>
	}

	clock_get_time(&cmp->clock);
    3a92:	ce 01       	movw	r24, r28
    3a94:	40 96       	adiw	r24, 0x10	; 16
    3a96:	0e 94 84 04 	call	0x908	; 0x908 <clock_get_time>
	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    3a9a:	68 89       	ldd	r22, Y+16	; 0x10
    3a9c:	79 89       	ldd	r23, Y+17	; 0x11
    3a9e:	8a 89       	ldd	r24, Y+18	; 0x12
    3aa0:	9b 89       	ldd	r25, Y+19	; 0x13
    3aa2:	04 d9       	rcall	.-3576   	; 0x2cac <csp_hton32>
    3aa4:	68 8b       	std	Y+16, r22	; 0x10
    3aa6:	79 8b       	std	Y+17, r23	; 0x11
    3aa8:	8a 8b       	std	Y+18, r24	; 0x12
    3aaa:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    3aac:	6c 89       	ldd	r22, Y+20	; 0x14
    3aae:	7d 89       	ldd	r23, Y+21	; 0x15
    3ab0:	8e 89       	ldd	r24, Y+22	; 0x16
    3ab2:	9f 89       	ldd	r25, Y+23	; 0x17
    3ab4:	fb d8       	rcall	.-3594   	; 0x2cac <csp_hton32>
    3ab6:	6c 8b       	std	Y+20, r22	; 0x14
    3ab8:	7d 8b       	std	Y+21, r23	; 0x15
    3aba:	8e 8b       	std	Y+22, r24	; 0x16
    3abc:	9f 8b       	std	Y+23, r25	; 0x17
		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;

		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
    3abe:	80 e0       	ldi	r24, 0x00	; 0
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
			break;
    3ac2:	02 c0       	rjmp	.+4      	; 0x3ac8 <csp_cmp_handler+0x2b4>

		default:
			ret = CSP_ERR_INVAL;
    3ac4:	8e ef       	ldi	r24, 0xFE	; 254
    3ac6:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    3ac8:	2f ef       	ldi	r18, 0xFF	; 255
    3aca:	2e 87       	std	Y+14, r18	; 0x0e

	return ret;
    3acc:	02 c0       	rjmp	.+4      	; 0x3ad2 <csp_cmp_handler+0x2be>
	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;
    3ace:	8e ef       	ldi	r24, 0xFE	; 254
    3ad0:	9f ef       	ldi	r25, 0xFF	; 255
	}

	cmp->type = CSP_CMP_REPLY;

	return ret;
}
    3ad2:	df 91       	pop	r29
    3ad4:	cf 91       	pop	r28
    3ad6:	1f 91       	pop	r17
    3ad8:	0f 91       	pop	r16
    3ada:	08 95       	ret

00003adc <csp_service_handler>:

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    3adc:	af 92       	push	r10
    3ade:	bf 92       	push	r11
    3ae0:	cf 92       	push	r12
    3ae2:	df 92       	push	r13
    3ae4:	ef 92       	push	r14
    3ae6:	ff 92       	push	r15
    3ae8:	0f 93       	push	r16
    3aea:	1f 93       	push	r17
    3aec:	cf 93       	push	r28
    3aee:	df 93       	push	r29
    3af0:	8c 01       	movw	r16, r24
    3af2:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    3af4:	12 d8       	rcall	.-4060   	; 0x2b1a <csp_conn_dport>
    3af6:	87 30       	cpi	r24, 0x07	; 7
    3af8:	91 05       	cpc	r25, r1
    3afa:	08 f0       	brcs	.+2      	; 0x3afe <csp_service_handler+0x22>
    3afc:	90 c0       	rjmp	.+288    	; 0x3c1e <csp_service_handler+0x142>
    3afe:	fc 01       	movw	r30, r24
    3b00:	e2 50       	subi	r30, 0x02	; 2
    3b02:	ff 4f       	sbci	r31, 0xFF	; 255
    3b04:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <__tablejump2__>

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    3b08:	be 01       	movw	r22, r28
    3b0a:	c8 01       	movw	r24, r16
    3b0c:	83 de       	rcall	.-762    	; 0x3814 <csp_cmp_handler>
    3b0e:	89 2b       	or	r24, r25
    3b10:	09 f4       	brne	.+2      	; 0x3b14 <csp_service_handler+0x38>
    3b12:	89 c0       	rjmp	.+274    	; 0x3c26 <csp_service_handler+0x14a>
			csp_buffer_free(packet);
    3b14:	ce 01       	movw	r24, r28
    3b16:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
			return;
    3b1a:	92 c0       	rjmp	.+292    	; 0x3c40 <csp_service_handler+0x164>
		break;

	case CSP_PS: {

		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    3b1c:	0e 94 29 12 	call	0x2452	; 0x2452 <csp_sys_tasklist_size>
    3b20:	7c 01       	movw	r14, r24
		char * pslist = csp_malloc(task_list_size);
    3b22:	0e 94 b1 11 	call	0x2362	; 0x2362 <csp_malloc>
    3b26:	5c 01       	movw	r10, r24

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    3b28:	0e 94 25 12 	call	0x244a	; 0x244a <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    3b2c:	b7 01       	movw	r22, r14
    3b2e:	c5 01       	movw	r24, r10
    3b30:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <strnlen>
    3b34:	6c 01       	movw	r12, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    3b36:	18 16       	cp	r1, r24
    3b38:	19 06       	cpc	r1, r25
    3b3a:	0c f0       	brlt	.+2      	; 0x3b3e <csp_service_handler+0x62>
    3b3c:	74 c0       	rjmp	.+232    	; 0x3c26 <csp_service_handler+0x14a>
		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
    3b3e:	e1 2c       	mov	r14, r1
    3b40:	f1 2c       	mov	r15, r1
		while(i < pslen) {

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    3b42:	20 97       	sbiw	r28, 0x00	; 0
    3b44:	41 f4       	brne	.+16     	; 0x3b56 <csp_service_handler+0x7a>
				packet = csp_buffer_get(CSP_RPS_MTU);
    3b46:	84 ec       	ldi	r24, 0xC4	; 196
    3b48:	90 e0       	ldi	r25, 0x00	; 0
    3b4a:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <csp_buffer_get>
    3b4e:	ec 01       	movw	r28, r24
			if (packet == NULL)
    3b50:	00 97       	sbiw	r24, 0x00	; 0
    3b52:	09 f4       	brne	.+2      	; 0x3b56 <csp_service_handler+0x7a>
    3b54:	75 c0       	rjmp	.+234    	; 0x3c40 <csp_service_handler+0x164>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    3b56:	a6 01       	movw	r20, r12
    3b58:	4e 19       	sub	r20, r14
    3b5a:	5f 09       	sbc	r21, r15
    3b5c:	45 3c       	cpi	r20, 0xC5	; 197
    3b5e:	51 05       	cpc	r21, r1
    3b60:	14 f0       	brlt	.+4      	; 0x3b66 <csp_service_handler+0x8a>
    3b62:	44 ec       	ldi	r20, 0xC4	; 196
    3b64:	50 e0       	ldi	r21, 0x00	; 0
    3b66:	48 87       	std	Y+8, r20	; 0x08
    3b68:	59 87       	std	Y+9, r21	; 0x09

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    3b6a:	b5 01       	movw	r22, r10
    3b6c:	6e 0d       	add	r22, r14
    3b6e:	7f 1d       	adc	r23, r15
    3b70:	ce 01       	movw	r24, r28
    3b72:	0e 96       	adiw	r24, 0x0e	; 14
    3b74:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
			i += packet->length;
    3b78:	88 85       	ldd	r24, Y+8	; 0x08
    3b7a:	99 85       	ldd	r25, Y+9	; 0x09
    3b7c:	e8 0e       	add	r14, r24
    3b7e:	f9 1e       	adc	r15, r25
			if (!csp_send(conn, packet, 0))
    3b80:	20 e0       	ldi	r18, 0x00	; 0
    3b82:	30 e0       	ldi	r19, 0x00	; 0
    3b84:	a9 01       	movw	r20, r18
    3b86:	be 01       	movw	r22, r28
    3b88:	c8 01       	movw	r24, r16
    3b8a:	51 da       	rcall	.-2910   	; 0x302e <csp_send>
    3b8c:	89 2b       	or	r24, r25
    3b8e:	19 f4       	brne	.+6      	; 0x3b96 <csp_service_handler+0xba>
				csp_buffer_free(packet);
    3b90:	ce 01       	movw	r24, r28
    3b92:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    3b96:	ec 14       	cp	r14, r12
    3b98:	fd 04       	cpc	r15, r13
    3b9a:	0c f0       	brlt	.+2      	; 0x3b9e <csp_service_handler+0xc2>
    3b9c:	51 c0       	rjmp	.+162    	; 0x3c40 <csp_service_handler+0x164>
    3b9e:	c0 e0       	ldi	r28, 0x00	; 0
    3ba0:	d0 e0       	ldi	r29, 0x00	; 0
    3ba2:	cf cf       	rjmp	.-98     	; 0x3b42 <csp_service_handler+0x66>
		}
		break;
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    3ba4:	0e 94 2f 12 	call	0x245e	; 0x245e <csp_sys_memfree>

		total = csp_hton32(total);
    3ba8:	81 d8       	rcall	.-3838   	; 0x2cac <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    3baa:	6e 87       	std	Y+14, r22	; 0x0e
    3bac:	7f 87       	std	Y+15, r23	; 0x0f
    3bae:	88 8b       	std	Y+16, r24	; 0x10
    3bb0:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    3bb2:	84 e0       	ldi	r24, 0x04	; 4
    3bb4:	90 e0       	ldi	r25, 0x00	; 0
    3bb6:	88 87       	std	Y+8, r24	; 0x08
    3bb8:	99 87       	std	Y+9, r25	; 0x09
    3bba:	35 c0       	rjmp	.+106    	; 0x3c26 <csp_service_handler+0x14a>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    3bbc:	6e 85       	ldd	r22, Y+14	; 0x0e
    3bbe:	7f 85       	ldd	r23, Y+15	; 0x0f
    3bc0:	88 89       	ldd	r24, Y+16	; 0x10
    3bc2:	99 89       	ldd	r25, Y+17	; 0x11
    3bc4:	a8 d8       	rcall	.-3760   	; 0x2d16 <csp_ntoh32>

		/* If the magic word is invalid, return */
		if (magic_word != 0x80078007) {
    3bc6:	67 30       	cpi	r22, 0x07	; 7
    3bc8:	70 48       	sbci	r23, 0x80	; 128
    3bca:	87 40       	sbci	r24, 0x07	; 7
    3bcc:	90 48       	sbci	r25, 0x80	; 128
    3bce:	21 f0       	breq	.+8      	; 0x3bd8 <csp_service_handler+0xfc>
			csp_buffer_free(packet);
    3bd0:	ce 01       	movw	r24, r28
    3bd2:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
			return;
    3bd6:	34 c0       	rjmp	.+104    	; 0x3c40 <csp_service_handler+0x164>
		}

		/* Otherwise Reboot */
		csp_sys_reboot();
    3bd8:	0e 94 86 12 	call	0x250c	; 0x250c <csp_sys_reboot>
		
		csp_buffer_free(packet);
    3bdc:	ce 01       	movw	r24, r28
    3bde:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
		return;
    3be2:	2e c0       	rjmp	.+92     	; 0x3c40 <csp_service_handler+0x164>
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    3be4:	0e 94 04 14 	call	0x2808	; 0x2808 <csp_buffer_remaining>
    3be8:	bc 01       	movw	r22, r24
    3bea:	88 27       	eor	r24, r24
    3bec:	77 fd       	sbrc	r23, 7
    3bee:	80 95       	com	r24
    3bf0:	98 2f       	mov	r25, r24
		size = csp_hton32(size);
    3bf2:	5c d8       	rcall	.-3912   	; 0x2cac <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    3bf4:	6e 87       	std	Y+14, r22	; 0x0e
    3bf6:	7f 87       	std	Y+15, r23	; 0x0f
    3bf8:	88 8b       	std	Y+16, r24	; 0x10
    3bfa:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(size);
    3bfc:	84 e0       	ldi	r24, 0x04	; 4
    3bfe:	90 e0       	ldi	r25, 0x00	; 0
    3c00:	88 87       	std	Y+8, r24	; 0x08
    3c02:	99 87       	std	Y+9, r25	; 0x09
    3c04:	10 c0       	rjmp	.+32     	; 0x3c26 <csp_service_handler+0x14a>
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    3c06:	0e 94 bb 12 	call	0x2576	; 0x2576 <csp_get_s>
		time = csp_hton32(time);
    3c0a:	50 d8       	rcall	.-3936   	; 0x2cac <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    3c0c:	6e 87       	std	Y+14, r22	; 0x0e
    3c0e:	7f 87       	std	Y+15, r23	; 0x0f
    3c10:	88 8b       	std	Y+16, r24	; 0x10
    3c12:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    3c14:	84 e0       	ldi	r24, 0x04	; 4
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	88 87       	std	Y+8, r24	; 0x08
    3c1a:	99 87       	std	Y+9, r25	; 0x09
    3c1c:	04 c0       	rjmp	.+8      	; 0x3c26 <csp_service_handler+0x14a>
		break;
	}

	default:
		csp_buffer_free(packet);
    3c1e:	ce 01       	movw	r24, r28
    3c20:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
		return;
    3c24:	0d c0       	rjmp	.+26     	; 0x3c40 <csp_service_handler+0x164>
	}

	if (packet != NULL) {
    3c26:	20 97       	sbiw	r28, 0x00	; 0
    3c28:	59 f0       	breq	.+22     	; 0x3c40 <csp_service_handler+0x164>
		if (!csp_send(conn, packet, 0))
    3c2a:	20 e0       	ldi	r18, 0x00	; 0
    3c2c:	30 e0       	ldi	r19, 0x00	; 0
    3c2e:	a9 01       	movw	r20, r18
    3c30:	be 01       	movw	r22, r28
    3c32:	c8 01       	movw	r24, r16
    3c34:	fc d9       	rcall	.-3080   	; 0x302e <csp_send>
    3c36:	89 2b       	or	r24, r25
    3c38:	19 f4       	brne	.+6      	; 0x3c40 <csp_service_handler+0x164>
			csp_buffer_free(packet);
    3c3a:	ce 01       	movw	r24, r28
    3c3c:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
	}

}
    3c40:	df 91       	pop	r29
    3c42:	cf 91       	pop	r28
    3c44:	1f 91       	pop	r17
    3c46:	0f 91       	pop	r16
    3c48:	ff 90       	pop	r15
    3c4a:	ef 90       	pop	r14
    3c4c:	df 90       	pop	r13
    3c4e:	cf 90       	pop	r12
    3c50:	bf 90       	pop	r11
    3c52:	af 90       	pop	r10
    3c54:	08 95       	ret

00003c56 <csp_i2c_tx>:
#include <csp/csp_interface.h>
#include <csp/csp_error.h>
#include <csp/interfaces/csp_if_i2c.h>
#include <csp/drivers/i2c.h>

int csp_i2c_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    3c56:	cf 92       	push	r12
    3c58:	df 92       	push	r13
    3c5a:	ef 92       	push	r14
    3c5c:	ff 92       	push	r15
    3c5e:	cf 93       	push	r28
    3c60:	df 93       	push	r29
    3c62:	eb 01       	movw	r28, r22
    3c64:	69 01       	movw	r12, r18
    3c66:	7a 01       	movw	r14, r20

	/* Cast the CSP packet buffer into an i2c frame */
	i2c_frame_t * frame = (i2c_frame_t *) packet;

	/* Insert destination node into the i2c destination field */
	if (csp_route_get_nexthop_mac(packet->id.dst) == CSP_NODE_MAC) {
    3c68:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c6a:	92 95       	swap	r25
    3c6c:	9f 70       	andi	r25, 0x0F	; 15
    3c6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c70:	81 70       	andi	r24, 0x01	; 1
    3c72:	82 95       	swap	r24
    3c74:	80 7f       	andi	r24, 0xF0	; 240
    3c76:	89 2b       	or	r24, r25
    3c78:	c9 dd       	rcall	.-1134   	; 0x380c <csp_route_get_nexthop_mac>
    3c7a:	8f 3f       	cpi	r24, 0xFF	; 255
    3c7c:	51 f4       	brne	.+20     	; 0x3c92 <csp_i2c_tx+0x3c>
		frame->dest = packet->id.dst;
    3c7e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c80:	92 95       	swap	r25
    3c82:	9f 70       	andi	r25, 0x0F	; 15
    3c84:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c86:	81 70       	andi	r24, 0x01	; 1
    3c88:	82 95       	swap	r24
    3c8a:	80 7f       	andi	r24, 0xF0	; 240
    3c8c:	89 2b       	or	r24, r25
    3c8e:	8e 83       	std	Y+6, r24	; 0x06
    3c90:	0a c0       	rjmp	.+20     	; 0x3ca6 <csp_i2c_tx+0x50>
	} else {
		frame->dest = csp_route_get_nexthop_mac(packet->id.dst);
    3c92:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c94:	92 95       	swap	r25
    3c96:	9f 70       	andi	r25, 0x0F	; 15
    3c98:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c9a:	81 70       	andi	r24, 0x01	; 1
    3c9c:	82 95       	swap	r24
    3c9e:	80 7f       	andi	r24, 0xF0	; 240
    3ca0:	89 2b       	or	r24, r25
    3ca2:	b4 dd       	rcall	.-1176   	; 0x380c <csp_route_get_nexthop_mac>
    3ca4:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* Save the outgoing id in the buffer */
	packet->id.ext = csp_hton32(packet->id.ext);
    3ca6:	6a 85       	ldd	r22, Y+10	; 0x0a
    3ca8:	7b 85       	ldd	r23, Y+11	; 0x0b
    3caa:	8c 85       	ldd	r24, Y+12	; 0x0c
    3cac:	9d 85       	ldd	r25, Y+13	; 0x0d
    3cae:	0e 94 56 16 	call	0x2cac	; 0x2cac <csp_hton32>
    3cb2:	6a 87       	std	Y+10, r22	; 0x0a
    3cb4:	7b 87       	std	Y+11, r23	; 0x0b
    3cb6:	8c 87       	std	Y+12, r24	; 0x0c
    3cb8:	9d 87       	std	Y+13, r25	; 0x0d

	/* Add the CSP header to the I2C length field */
	frame->len += sizeof(packet->id);
    3cba:	88 85       	ldd	r24, Y+8	; 0x08
    3cbc:	99 85       	ldd	r25, Y+9	; 0x09
    3cbe:	04 96       	adiw	r24, 0x04	; 4
    3cc0:	88 87       	std	Y+8, r24	; 0x08
    3cc2:	99 87       	std	Y+9, r25	; 0x09
	frame->len_rx = 0;
    3cc4:	1f 82       	std	Y+7, r1	; 0x07

	/* Some I2C drivers support X number of retries
	 * CSP don't care about this. If it doesn't work the first
	 * time, don'y use time on it.
	 */
	frame->retries = 0;
    3cc6:	19 82       	std	Y+1, r1	; 0x01

	/* enqueue the frame */
	if (i2c_send(0, frame, timeout) != E_NO_ERR)
    3cc8:	a6 01       	movw	r20, r12
    3cca:	be 01       	movw	r22, r28
    3ccc:	80 e0       	ldi	r24, 0x00	; 0
    3cce:	90 e0       	ldi	r25, 0x00	; 0
    3cd0:	0e 94 72 04 	call	0x8e4	; 0x8e4 <i2c_send>
    3cd4:	01 96       	adiw	r24, 0x01	; 1
    3cd6:	19 f0       	breq	.+6      	; 0x3cde <csp_i2c_tx+0x88>
		return CSP_ERR_DRIVER;
    3cd8:	85 ef       	ldi	r24, 0xF5	; 245
    3cda:	9f ef       	ldi	r25, 0xFF	; 255
    3cdc:	02 c0       	rjmp	.+4      	; 0x3ce2 <csp_i2c_tx+0x8c>

	return CSP_ERR_NONE;
    3cde:	80 e0       	ldi	r24, 0x00	; 0
    3ce0:	90 e0       	ldi	r25, 0x00	; 0

}
    3ce2:	df 91       	pop	r29
    3ce4:	cf 91       	pop	r28
    3ce6:	ff 90       	pop	r15
    3ce8:	ef 90       	pop	r14
    3cea:	df 90       	pop	r13
    3cec:	cf 90       	pop	r12
    3cee:	08 95       	ret

00003cf0 <csp_i2c_rx>:
 * When a frame is received, cast it to a csp_packet
 * and send it directly to the CSP new packet function.
 * Context: ISR only
 * @param frame
 */
void csp_i2c_rx(i2c_frame_t * frame, void * pxTaskWoken) {
    3cf0:	0f 93       	push	r16
    3cf2:	1f 93       	push	r17
    3cf4:	cf 93       	push	r28
    3cf6:	df 93       	push	r29
    3cf8:	ec 01       	movw	r28, r24
    3cfa:	8b 01       	movw	r16, r22

	static csp_packet_t * packet;

	/* Validate input */
	if (frame == NULL)
    3cfc:	00 97       	sbiw	r24, 0x00	; 0
    3cfe:	79 f1       	breq	.+94     	; 0x3d5e <csp_i2c_rx+0x6e>
		return;

	if ((frame->len < 4) || (frame->len > I2C_MTU)) {
    3d00:	88 85       	ldd	r24, Y+8	; 0x08
    3d02:	99 85       	ldd	r25, Y+9	; 0x09
    3d04:	04 97       	sbiw	r24, 0x04	; 4
    3d06:	8d 3f       	cpi	r24, 0xFD	; 253
    3d08:	91 05       	cpc	r25, r1
    3d0a:	88 f0       	brcs	.+34     	; 0x3d2e <csp_i2c_rx+0x3e>
		csp_if_i2c.frame++;
    3d0c:	e9 e2       	ldi	r30, 0x29	; 41
    3d0e:	f0 e2       	ldi	r31, 0x20	; 32
    3d10:	80 81       	ld	r24, Z
    3d12:	91 81       	ldd	r25, Z+1	; 0x01
    3d14:	a2 81       	ldd	r26, Z+2	; 0x02
    3d16:	b3 81       	ldd	r27, Z+3	; 0x03
    3d18:	01 96       	adiw	r24, 0x01	; 1
    3d1a:	a1 1d       	adc	r26, r1
    3d1c:	b1 1d       	adc	r27, r1
    3d1e:	80 83       	st	Z, r24
    3d20:	91 83       	std	Z+1, r25	; 0x01
    3d22:	a2 83       	std	Z+2, r26	; 0x02
    3d24:	b3 83       	std	Z+3, r27	; 0x03
		csp_buffer_free_isr(frame);
    3d26:	ce 01       	movw	r24, r28
    3d28:	0e 94 95 13 	call	0x272a	; 0x272a <csp_buffer_free_isr>
		return;
    3d2c:	18 c0       	rjmp	.+48     	; 0x3d5e <csp_i2c_rx+0x6e>
	}

	/* Strip the CSP header off the length field before converting to CSP packet */
	frame->len -= sizeof(csp_id_t);
    3d2e:	88 87       	std	Y+8, r24	; 0x08
    3d30:	99 87       	std	Y+9, r25	; 0x09

	/* Convert the packet from network to host order */
	packet = (csp_packet_t *) frame;
    3d32:	c0 93 9d 3e 	sts	0x3E9D, r28
    3d36:	d0 93 9e 3e 	sts	0x3E9E, r29
	packet->id.ext = csp_ntoh32(packet->id.ext);
    3d3a:	6a 85       	ldd	r22, Y+10	; 0x0a
    3d3c:	7b 85       	ldd	r23, Y+11	; 0x0b
    3d3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d40:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d42:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <csp_ntoh32>
    3d46:	6a 87       	std	Y+10, r22	; 0x0a
    3d48:	7b 87       	std	Y+11, r23	; 0x0b
    3d4a:	8c 87       	std	Y+12, r24	; 0x0c
    3d4c:	9d 87       	std	Y+13, r25	; 0x0d

	/* Receive the packet in CSP */
	csp_new_packet(packet, &csp_if_i2c, pxTaskWoken);
    3d4e:	a8 01       	movw	r20, r16
    3d50:	67 e0       	ldi	r22, 0x07	; 7
    3d52:	70 e2       	ldi	r23, 0x20	; 32
    3d54:	80 91 9d 3e 	lds	r24, 0x3E9D
    3d58:	90 91 9e 3e 	lds	r25, 0x3E9E
    3d5c:	e5 dc       	rcall	.-1590   	; 0x3728 <csp_new_packet>

}
    3d5e:	df 91       	pop	r29
    3d60:	cf 91       	pop	r28
    3d62:	1f 91       	pop	r17
    3d64:	0f 91       	pop	r16
    3d66:	08 95       	ret

00003d68 <csp_i2c_init>:

int csp_i2c_init(uint8_t addr, int handle, int speed) {
    3d68:	cf 92       	push	r12
    3d6a:	df 92       	push	r13
    3d6c:	ef 92       	push	r14
    3d6e:	ff 92       	push	r15
    3d70:	0f 93       	push	r16
    3d72:	1f 93       	push	r17
    3d74:	e8 2f       	mov	r30, r24
    3d76:	cb 01       	movw	r24, r22
    3d78:	9a 01       	movw	r18, r20

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
    3d7a:	0f 2e       	mov	r0, r31
    3d7c:	f8 e7       	ldi	r31, 0x78	; 120
    3d7e:	cf 2e       	mov	r12, r31
    3d80:	fe e1       	ldi	r31, 0x1E	; 30
    3d82:	df 2e       	mov	r13, r31
    3d84:	f0 2d       	mov	r31, r0
    3d86:	0f 2e       	mov	r0, r31
    3d88:	fa e0       	ldi	r31, 0x0A	; 10
    3d8a:	ef 2e       	mov	r14, r31
    3d8c:	f1 2c       	mov	r15, r1
    3d8e:	f0 2d       	mov	r31, r0
    3d90:	0a e0       	ldi	r16, 0x0A	; 10
    3d92:	10 e0       	ldi	r17, 0x00	; 0
    3d94:	4e 2f       	mov	r20, r30
    3d96:	60 e0       	ldi	r22, 0x00	; 0
    3d98:	70 e0       	ldi	r23, 0x00	; 0
    3d9a:	0e 94 4f 04 	call	0x89e	; 0x89e <i2c_init>
    3d9e:	01 96       	adiw	r24, 0x01	; 1
    3da0:	31 f4       	brne	.+12     	; 0x3dae <csp_i2c_init+0x46>
		return CSP_ERR_DRIVER;

	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);
    3da2:	87 e0       	ldi	r24, 0x07	; 7
    3da4:	90 e2       	ldi	r25, 0x20	; 32
    3da6:	e9 da       	rcall	.-2606   	; 0x337a <csp_route_add_if>

	return CSP_ERR_NONE;
    3da8:	80 e0       	ldi	r24, 0x00	; 0
    3daa:	90 e0       	ldi	r25, 0x00	; 0
    3dac:	02 c0       	rjmp	.+4      	; 0x3db2 <csp_i2c_init+0x4a>

int csp_i2c_init(uint8_t addr, int handle, int speed) {

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    3dae:	85 ef       	ldi	r24, 0xF5	; 245
    3db0:	9f ef       	ldi	r25, 0xFF	; 255
	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);

	return CSP_ERR_NONE;

}
    3db2:	1f 91       	pop	r17
    3db4:	0f 91       	pop	r16
    3db6:	ff 90       	pop	r15
    3db8:	ef 90       	pop	r14
    3dba:	df 90       	pop	r13
    3dbc:	cf 90       	pop	r12
    3dbe:	08 95       	ret

00003dc0 <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    3dc0:	cb 01       	movw	r24, r22

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_new_packet(packet, &csp_if_lo, NULL);
    3dc2:	40 e0       	ldi	r20, 0x00	; 0
    3dc4:	50 e0       	ldi	r21, 0x00	; 0
    3dc6:	6b e3       	ldi	r22, 0x3B	; 59
    3dc8:	70 e2       	ldi	r23, 0x20	; 32
    3dca:	ae dc       	rcall	.-1700   	; 0x3728 <csp_new_packet>

	return CSP_ERR_NONE;

}
    3dcc:	80 e0       	ldi	r24, 0x00	; 0
    3dce:	90 e0       	ldi	r25, 0x00	; 0
    3dd0:	08 95       	ret

00003dd2 <csp_udp_new_packet>:
#include <csp/csp.h>
#include <csp/arch/csp_queue.h>
#include "../csp_port.h"
#include "../csp_conn.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    3dd2:	0f 93       	push	r16
    3dd4:	1f 93       	push	r17
    3dd6:	cf 93       	push	r28
    3dd8:	df 93       	push	r29
    3dda:	1f 92       	push	r1
    3ddc:	1f 92       	push	r1
    3dde:	cd b7       	in	r28, 0x3d	; 61
    3de0:	de b7       	in	r29, 0x3e	; 62
    3de2:	89 83       	std	Y+1, r24	; 0x01
    3de4:	9a 83       	std	Y+2, r25	; 0x02
    3de6:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    3de8:	0e 94 0a 14 	call	0x2814	; 0x2814 <csp_conn_enqueue_packet>
    3dec:	99 23       	and	r25, r25
    3dee:	24 f4       	brge	.+8      	; 0x3df8 <csp_udp_new_packet+0x26>
		csp_log_error("Connection buffer queue full!\r\n");
		csp_buffer_free(packet);
    3df0:	c8 01       	movw	r24, r16
    3df2:	0e 94 cd 13 	call	0x279a	; 0x279a <csp_buffer_free>
		return;
    3df6:	19 c0       	rjmp	.+50     	; 0x3e2a <csp_udp_new_packet+0x58>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    3df8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfc:	86 85       	ldd	r24, Z+14	; 0x0e
    3dfe:	97 85       	ldd	r25, Z+15	; 0x0f
    3e00:	00 97       	sbiw	r24, 0x00	; 0
    3e02:	99 f0       	breq	.+38     	; 0x3e2a <csp_udp_new_packet+0x58>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    3e04:	20 e0       	ldi	r18, 0x00	; 0
    3e06:	30 e0       	ldi	r19, 0x00	; 0
    3e08:	a9 01       	movw	r20, r18
    3e0a:	be 01       	movw	r22, r28
    3e0c:	6f 5f       	subi	r22, 0xFF	; 255
    3e0e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e10:	0e 94 ba 11 	call	0x2374	; 0x2374 <csp_queue_enqueue>
    3e14:	01 97       	sbiw	r24, 0x01	; 1
    3e16:	29 f0       	breq	.+10     	; 0x3e22 <csp_udp_new_packet+0x50>
			csp_log_warn("Warning socket connection queue full\r\n");
			csp_close(conn);
    3e18:	89 81       	ldd	r24, Y+1	; 0x01
    3e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e1c:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <csp_close>
			return;
    3e20:	04 c0       	rjmp	.+8      	; 0x3e2a <csp_udp_new_packet+0x58>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    3e22:	e9 81       	ldd	r30, Y+1	; 0x01
    3e24:	fa 81       	ldd	r31, Y+2	; 0x02
    3e26:	16 86       	std	Z+14, r1	; 0x0e
    3e28:	17 86       	std	Z+15, r1	; 0x0f
	}

}
    3e2a:	0f 90       	pop	r0
    3e2c:	0f 90       	pop	r0
    3e2e:	df 91       	pop	r29
    3e30:	cf 91       	pop	r28
    3e32:	1f 91       	pop	r17
    3e34:	0f 91       	pop	r16
    3e36:	08 95       	ret

00003e38 <blink>:
    3e38:	c0 e6       	ldi	r28, 0x60	; 96
    3e3a:	d6 e0       	ldi	r29, 0x06	; 6
    3e3c:	10 e1       	ldi	r17, 0x10	; 16
    3e3e:	1f 83       	std	Y+7, r17	; 0x07
	
	while (1) {
				
		led_yellow_toggle();
		
        vTaskDelay(1000);
    3e40:	88 ee       	ldi	r24, 0xE8	; 232
    3e42:	93 e0       	ldi	r25, 0x03	; 3
    3e44:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <vTaskDelay>
    3e48:	fa cf       	rjmp	.-12     	; 0x3e3e <blink+0x6>

00003e4a <main>:
	}
}

int main(void) {
    3e4a:	af 92       	push	r10
    3e4c:	bf 92       	push	r11
    3e4e:	cf 92       	push	r12
    3e50:	df 92       	push	r13
    3e52:	ef 92       	push	r14
    3e54:	ff 92       	push	r15
    3e56:	0f 93       	push	r16
	
	// initialize the xMega peripherals
	boardInit();
    3e58:	05 d7       	rcall	.+3594   	; 0x4c64 <boardInit>
	
	// Initialize the CSP buffers
	csp_buffer_init(CSP_BUFFER_COUNT, CSP_BUFFER_SIZE);
    3e5a:	66 e5       	ldi	r22, 0x56	; 86
    3e5c:	70 e0       	ldi	r23, 0x00	; 0
    3e5e:	81 e0       	ldi	r24, 0x01	; 1
    3e60:	90 e0       	ldi	r25, 0x00	; 0
    3e62:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <csp_buffer_init>
			
	// Initialize the CSP
	csp_init(CSP_MY_ADDRESS);
    3e66:	81 e0       	ldi	r24, 0x01	; 1
    3e68:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <csp_init>
	
	// Initialize the CSP I2C interface
	csp_i2c_init(CSP_I2C_SLAVE_ADDRESS, 0, CSP_I2C_BAUDSETTING);
    3e6c:	43 e2       	ldi	r20, 0x23	; 35
    3e6e:	50 e0       	ldi	r21, 0x00	; 0
    3e70:	60 e0       	ldi	r22, 0x00	; 0
    3e72:	70 e0       	ldi	r23, 0x00	; 0
    3e74:	81 e0       	ldi	r24, 0x01	; 1
    3e76:	78 df       	rcall	.-272    	; 0x3d68 <csp_i2c_init>
					
	// Add route to OBC via i2c 
	csp_route_set(CSP_BOARD_ADDRESS, &csp_if_i2c, CSP_I2C_BOARD_ADDRESS);		
    3e78:	43 e0       	ldi	r20, 0x03	; 3
    3e7a:	67 e0       	ldi	r22, 0x07	; 7
    3e7c:	70 e2       	ldi	r23, 0x20	; 32
    3e7e:	83 e0       	ldi	r24, 0x03	; 3
    3e80:	a5 da       	rcall	.-2742   	; 0x33cc <csp_route_set>
					
	// Start router task
	csp_route_start_task(CSP_ROUTER_STACK, CSP_ROUTER_PRIORITY);
    3e82:	60 e0       	ldi	r22, 0x00	; 0
    3e84:	70 e0       	ldi	r23, 0x00	; 0
    3e86:	84 ef       	ldi	r24, 0xF4	; 244
    3e88:	91 e0       	ldi	r25, 0x01	; 1
    3e8a:	36 da       	rcall	.-2964   	; 0x32f8 <csp_route_start_task>
				
	/* -------------------------------------------------------------------- */
	/*	Starts blinking task - only for debug								*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(blink, (signed char*) "blink", 64, NULL, configNORMAL_PRIORITY, NULL);
    3e8c:	a1 2c       	mov	r10, r1
    3e8e:	b1 2c       	mov	r11, r1
    3e90:	c1 2c       	mov	r12, r1
    3e92:	d1 2c       	mov	r13, r1
    3e94:	e1 2c       	mov	r14, r1
    3e96:	f1 2c       	mov	r15, r1
    3e98:	00 e0       	ldi	r16, 0x00	; 0
    3e9a:	20 e0       	ldi	r18, 0x00	; 0
    3e9c:	30 e0       	ldi	r19, 0x00	; 0
    3e9e:	40 e4       	ldi	r20, 0x40	; 64
    3ea0:	50 e0       	ldi	r21, 0x00	; 0
    3ea2:	68 eb       	ldi	r22, 0xB8	; 184
    3ea4:	70 e2       	ldi	r23, 0x20	; 32
    3ea6:	8c e1       	ldi	r24, 0x1C	; 28
    3ea8:	9f e1       	ldi	r25, 0x1F	; 31
    3eaa:	0e 94 b5 0a 	call	0x156a	; 0x156a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles incoming communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(cspTask, (signed char*) "cspTask", 256, NULL, configNORMAL_PRIORITY, NULL);
    3eae:	20 e0       	ldi	r18, 0x00	; 0
    3eb0:	30 e0       	ldi	r19, 0x00	; 0
    3eb2:	40 e0       	ldi	r20, 0x00	; 0
    3eb4:	51 e0       	ldi	r21, 0x01	; 1
    3eb6:	6e eb       	ldi	r22, 0xBE	; 190
    3eb8:	70 e2       	ldi	r23, 0x20	; 32
    3eba:	8d ea       	ldi	r24, 0xAD	; 173
    3ebc:	93 e0       	ldi	r25, 0x03	; 3
    3ebe:	0e 94 b5 0a 	call	0x156a	; 0x156a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles outgoing communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(mainTask, (signed char*) "mainTask", 512, NULL, configNORMAL_PRIORITY, NULL);
    3ec2:	20 e0       	ldi	r18, 0x00	; 0
    3ec4:	30 e0       	ldi	r19, 0x00	; 0
    3ec6:	40 e0       	ldi	r20, 0x00	; 0
    3ec8:	52 e0       	ldi	r21, 0x02	; 2
    3eca:	66 ec       	ldi	r22, 0xC6	; 198
    3ecc:	70 e2       	ldi	r23, 0x20	; 32
    3ece:	87 e7       	ldi	r24, 0x77	; 119
    3ed0:	9f e1       	ldi	r25, 0x1F	; 31
    3ed2:	0e 94 b5 0a 	call	0x156a	; 0x156a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts the scheduler and all previously created tasks				*/
	/* -------------------------------------------------------------------- */
	vTaskStartScheduler();
    3ed6:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vTaskStartScheduler>
	
	return 0;
    3eda:	80 e0       	ldi	r24, 0x00	; 0
    3edc:	90 e0       	ldi	r25, 0x00	; 0
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	bf 90       	pop	r11
    3eea:	af 90       	pop	r10
    3eec:	08 95       	ret

00003eee <mainTask>:
int16_t timediff;

/* -------------------------------------------------------------------- */
/*	The main task														*/
/* -------------------------------------------------------------------- */
void mainTask(void *p) {
    3eee:	cf 93       	push	r28
    3ef0:	df 93       	push	r29
    3ef2:	cd b7       	in	r28, 0x3d	; 61
    3ef4:	de b7       	in	r29, 0x3e	; 62
    3ef6:	68 97       	sbiw	r28, 0x18	; 24
    3ef8:	cd bf       	out	0x3d, r28	; 61
    3efa:	de bf       	out	0x3e, r29	; 62
	
	// packet used to handle incoming communication
	csp_packet_t * outcomingPacket = csp_buffer_get(CSP_PACKET_SIZE);
    3efc:	88 e4       	ldi	r24, 0x48	; 72
    3efe:	90 e0       	ldi	r25, 0x00	; 0
    3f00:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <csp_buffer_get>
    3f04:	3c 01       	movw	r6, r24
	char text[20];
	
	// infinite while loop of the program 
	while (1) {
		
		if (xQueueReceive(xCSPEventQueue, &xReceivedEvent, 1)) {
    3f06:	20 e0       	ldi	r18, 0x00	; 0
    3f08:	41 e0       	ldi	r20, 0x01	; 1
    3f0a:	50 e0       	ldi	r21, 0x00	; 0
    3f0c:	be 01       	movw	r22, r28
    3f0e:	6e 5f       	subi	r22, 0xFE	; 254
    3f10:	7f 4f       	sbci	r23, 0xFF	; 255
    3f12:	80 91 9f 3e 	lds	r24, 0x3E9F
    3f16:	90 91 a0 3e 	lds	r25, 0x3EA0
    3f1a:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <xQueueGenericReceive>
    3f1e:	88 23       	and	r24, r24
    3f20:	09 f4       	brne	.+2      	; 0x3f24 <mainTask+0x36>
    3f22:	7d c0       	rjmp	.+250    	; 0x401e <__stack+0x1f>
			
			switch (xReceivedEvent.eEventType) {
    3f24:	8a 81       	ldd	r24, Y+2	; 0x02
    3f26:	81 30       	cpi	r24, 0x01	; 1
    3f28:	19 f0       	breq	.+6      	; 0x3f30 <mainTask+0x42>
    3f2a:	82 30       	cpi	r24, 0x02	; 2
    3f2c:	f1 f0       	breq	.+60     	; 0x3f6a <mainTask+0x7c>
    3f2e:	77 c0       	rjmp	.+238    	; 0x401e <__stack+0x1f>
			
				case generalCommEvent:
			
					// send its content to the uart
					for (i = 0; i < ((csp_packet_t *) xReceivedEvent.pvData)->length; i++) {
    3f30:	eb 81       	ldd	r30, Y+3	; 0x03
    3f32:	fc 81       	ldd	r31, Y+4	; 0x04
    3f34:	80 85       	ldd	r24, Z+8	; 0x08
    3f36:	91 85       	ldd	r25, Z+9	; 0x09
    3f38:	89 2b       	or	r24, r25
    3f3a:	09 f4       	brne	.+2      	; 0x3f3e <mainTask+0x50>
    3f3c:	70 c0       	rjmp	.+224    	; 0x401e <__stack+0x1f>
    3f3e:	00 e0       	ldi	r16, 0x00	; 0
    3f40:	10 e0       	ldi	r17, 0x00	; 0
						usartBufferPutByte(pc_usart_buffer, ((csp_packet_t *) xReceivedEvent.pvData)->data[i], 10);
    3f42:	e0 0f       	add	r30, r16
    3f44:	f1 1f       	adc	r31, r17
    3f46:	4a e0       	ldi	r20, 0x0A	; 10
    3f48:	50 e0       	ldi	r21, 0x00	; 0
    3f4a:	66 85       	ldd	r22, Z+14	; 0x0e
    3f4c:	80 91 62 3f 	lds	r24, 0x3F62
    3f50:	90 91 63 3f 	lds	r25, 0x3F63
    3f54:	40 d6       	rcall	.+3200   	; 0x4bd6 <usartBufferPutByte>
			switch (xReceivedEvent.eEventType) {
			
				case generalCommEvent:
			
					// send its content to the uart
					for (i = 0; i < ((csp_packet_t *) xReceivedEvent.pvData)->length; i++) {
    3f56:	0f 5f       	subi	r16, 0xFF	; 255
    3f58:	1f 4f       	sbci	r17, 0xFF	; 255
    3f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f5e:	80 85       	ldd	r24, Z+8	; 0x08
    3f60:	91 85       	ldd	r25, Z+9	; 0x09
    3f62:	08 17       	cp	r16, r24
    3f64:	19 07       	cpc	r17, r25
    3f66:	68 f3       	brcs	.-38     	; 0x3f42 <mainTask+0x54>
    3f68:	5a c0       	rjmp	.+180    	; 0x401e <__stack+0x1f>
			
				break;
				case pingReceivedEvent:
			
					// calculate the ping return time
					if ((int16_t) milisecondsTimer - (int16_t) pingSent > 0)
    3f6a:	40 91 5a 3f 	lds	r20, 0x3F5A
    3f6e:	50 91 5b 3f 	lds	r21, 0x3F5B
    3f72:	60 91 5c 3f 	lds	r22, 0x3F5C
    3f76:	70 91 5d 3f 	lds	r23, 0x3F5D
    3f7a:	80 91 4a 3f 	lds	r24, 0x3F4A
    3f7e:	90 91 4b 3f 	lds	r25, 0x3F4B
    3f82:	a0 91 4c 3f 	lds	r26, 0x3F4C
    3f86:	b0 91 4d 3f 	lds	r27, 0x3F4D
    3f8a:	48 1b       	sub	r20, r24
    3f8c:	59 0b       	sbc	r21, r25
    3f8e:	14 16       	cp	r1, r20
    3f90:	15 06       	cpc	r1, r21
    3f92:	7c f4       	brge	.+30     	; 0x3fb2 <mainTask+0xc4>
						timediff = milisecondsTimer - pingSent;
    3f94:	40 91 5a 3f 	lds	r20, 0x3F5A
    3f98:	50 91 5b 3f 	lds	r21, 0x3F5B
    3f9c:	60 91 5c 3f 	lds	r22, 0x3F5C
    3fa0:	70 91 5d 3f 	lds	r23, 0x3F5D
    3fa4:	48 1b       	sub	r20, r24
    3fa6:	59 0b       	sbc	r21, r25
    3fa8:	40 93 48 3f 	sts	0x3F48, r20
    3fac:	50 93 49 3f 	sts	0x3F49, r21
    3fb0:	10 c0       	rjmp	.+32     	; 0x3fd2 <mainTask+0xe4>
					else
						timediff = (int16_t) milisecondsTimer - (int16_t) pingSent + (int16_t) 1000;
    3fb2:	40 91 5a 3f 	lds	r20, 0x3F5A
    3fb6:	50 91 5b 3f 	lds	r21, 0x3F5B
    3fba:	60 91 5c 3f 	lds	r22, 0x3F5C
    3fbe:	70 91 5d 3f 	lds	r23, 0x3F5D
    3fc2:	48 1b       	sub	r20, r24
    3fc4:	59 0b       	sbc	r21, r25
    3fc6:	48 51       	subi	r20, 0x18	; 24
    3fc8:	5c 4f       	sbci	r21, 0xFC	; 252
    3fca:	40 93 48 3f 	sts	0x3F48, r20
    3fce:	50 93 49 3f 	sts	0x3F49, r21
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3fd2:	4a e0       	ldi	r20, 0x0A	; 10
    3fd4:	be 01       	movw	r22, r28
    3fd6:	6b 5f       	subi	r22, 0xFB	; 251
    3fd8:	7f 4f       	sbci	r23, 0xFF	; 255
    3fda:	80 91 48 3f 	lds	r24, 0x3F48
    3fde:	90 91 49 3f 	lds	r25, 0x3F49
    3fe2:	0e 94 7f 2c 	call	0x58fe	; 0x58fe <__itoa_ncheck>

					itoa(timediff, text, 10);
					usartBufferPutString(pc_usart_buffer, "ping received in ", 10);
    3fe6:	4a e0       	ldi	r20, 0x0A	; 10
    3fe8:	50 e0       	ldi	r21, 0x00	; 0
    3fea:	6f ec       	ldi	r22, 0xCF	; 207
    3fec:	70 e2       	ldi	r23, 0x20	; 32
    3fee:	80 91 62 3f 	lds	r24, 0x3F62
    3ff2:	90 91 63 3f 	lds	r25, 0x3F63
    3ff6:	1c d6       	rcall	.+3128   	; 0x4c30 <usartBufferPutString>
					usartBufferPutString(pc_usart_buffer, text, 10);
    3ff8:	4a e0       	ldi	r20, 0x0A	; 10
    3ffa:	50 e0       	ldi	r21, 0x00	; 0
    3ffc:	be 01       	movw	r22, r28
    3ffe:	6b 5f       	subi	r22, 0xFB	; 251
    4000:	7f 4f       	sbci	r23, 0xFF	; 255
    4002:	80 91 62 3f 	lds	r24, 0x3F62
    4006:	90 91 63 3f 	lds	r25, 0x3F63
    400a:	12 d6       	rcall	.+3108   	; 0x4c30 <usartBufferPutString>
					usartBufferPutString(pc_usart_buffer, "ms\n\r", 10);
    400c:	4a e0       	ldi	r20, 0x0A	; 10
    400e:	50 e0       	ldi	r21, 0x00	; 0
    4010:	61 ee       	ldi	r22, 0xE1	; 225
    4012:	70 e2       	ldi	r23, 0x20	; 32
    4014:	80 91 62 3f 	lds	r24, 0x3F62
    4018:	90 91 63 3f 	lds	r25, 0x3F63
    401c:	09 d6       	rcall	.+3090   	; 0x4c30 <usartBufferPutString>
				break;
			}
		}
		
		// if there is something from the uart
		if (usartBufferGetByte(pc_usart_buffer, &inChar, 0)) {
    401e:	40 e0       	ldi	r20, 0x00	; 0
    4020:	50 e0       	ldi	r21, 0x00	; 0
    4022:	be 01       	movw	r22, r28
    4024:	6f 5f       	subi	r22, 0xFF	; 255
    4026:	7f 4f       	sbci	r23, 0xFF	; 255
    4028:	80 91 62 3f 	lds	r24, 0x3F62
    402c:	90 91 63 3f 	lds	r25, 0x3F63
    4030:	f8 d5       	rcall	.+3056   	; 0x4c22 <usartBufferGetByte>
    4032:	88 23       	and	r24, r24
    4034:	09 f4       	brne	.+2      	; 0x4038 <__stack+0x39>
    4036:	67 cf       	rjmp	.-306    	; 0x3f06 <mainTask+0x18>
		
			outcomingPacket->data[0] = inChar;
    4038:	29 81       	ldd	r18, Y+1	; 0x01
    403a:	f3 01       	movw	r30, r6
    403c:	26 87       	std	Z+14, r18	; 0x0e
			outcomingPacket->length = 1;
    403e:	81 e0       	ldi	r24, 0x01	; 1
    4040:	90 e0       	ldi	r25, 0x00	; 0
    4042:	80 87       	std	Z+8, r24	; 0x08
    4044:	91 87       	std	Z+9, r25	; 0x09
		
			switch (inChar) {
    4046:	28 36       	cpi	r18, 0x68	; 104
    4048:	d1 f0       	breq	.+52     	; 0x407e <__stack+0x7f>
    404a:	18 f4       	brcc	.+6      	; 0x4052 <__stack+0x53>
    404c:	21 36       	cpi	r18, 0x61	; 97
    404e:	49 f1       	breq	.+82     	; 0x40a2 <__stack+0xa3>
    4050:	5e c0       	rjmp	.+188    	; 0x410e <__stack+0x10f>
    4052:	2d 36       	cpi	r18, 0x6D	; 109
    4054:	19 f0       	breq	.+6      	; 0x405c <__stack+0x5d>
    4056:	20 37       	cpi	r18, 0x70	; 112
    4058:	b1 f1       	breq	.+108    	; 0x40c6 <__stack+0xc7>
    405a:	59 c0       	rjmp	.+178    	; 0x410e <__stack+0x10f>
			
				// ask board for free memory heap
				case 'm':
					csp_sendto(CSP_PRIO_NORM, CSP_BOARD_ADDRESS, 16, 15, CSP_O_NONE, outcomingPacket, 10);
    405c:	0f 2e       	mov	r0, r31
    405e:	fa e0       	ldi	r31, 0x0A	; 10
    4060:	8f 2e       	mov	r8, r31
    4062:	91 2c       	mov	r9, r1
    4064:	a1 2c       	mov	r10, r1
    4066:	b1 2c       	mov	r11, r1
    4068:	f0 2d       	mov	r31, r0
    406a:	63 01       	movw	r12, r6
    406c:	e1 2c       	mov	r14, r1
    406e:	f1 2c       	mov	r15, r1
    4070:	87 01       	movw	r16, r14
    4072:	2f e0       	ldi	r18, 0x0F	; 15
    4074:	40 e1       	ldi	r20, 0x10	; 16
    4076:	63 e0       	ldi	r22, 0x03	; 3
    4078:	82 e0       	ldi	r24, 0x02	; 2
    407a:	03 d8       	rcall	.-4090   	; 0x3082 <csp_sendto>
				break;
    407c:	44 cf       	rjmp	.-376    	; 0x3f06 <mainTask+0x18>
			
				// ask board for status
				case 'h':
					csp_sendto(CSP_PRIO_NORM, CSP_BOARD_ADDRESS, 17, 15, CSP_O_NONE,  outcomingPacket, 10);
    407e:	0f 2e       	mov	r0, r31
    4080:	fa e0       	ldi	r31, 0x0A	; 10
    4082:	8f 2e       	mov	r8, r31
    4084:	91 2c       	mov	r9, r1
    4086:	a1 2c       	mov	r10, r1
    4088:	b1 2c       	mov	r11, r1
    408a:	f0 2d       	mov	r31, r0
    408c:	63 01       	movw	r12, r6
    408e:	e1 2c       	mov	r14, r1
    4090:	f1 2c       	mov	r15, r1
    4092:	87 01       	movw	r16, r14
    4094:	2f e0       	ldi	r18, 0x0F	; 15
    4096:	41 e1       	ldi	r20, 0x11	; 17
    4098:	63 e0       	ldi	r22, 0x03	; 3
    409a:	82 e0       	ldi	r24, 0x02	; 2
    409c:	0e 94 41 18 	call	0x3082	; 0x3082 <csp_sendto>
				break;
    40a0:	32 cf       	rjmp	.-412    	; 0x3f06 <mainTask+0x18>
				
				// ask board for status
				case 'a':
				csp_sendto(CSP_PRIO_NORM, CSP_BOARD_ADDRESS, 18, 15, CSP_O_NONE,  outcomingPacket, 10);
    40a2:	0f 2e       	mov	r0, r31
    40a4:	fa e0       	ldi	r31, 0x0A	; 10
    40a6:	8f 2e       	mov	r8, r31
    40a8:	91 2c       	mov	r9, r1
    40aa:	a1 2c       	mov	r10, r1
    40ac:	b1 2c       	mov	r11, r1
    40ae:	f0 2d       	mov	r31, r0
    40b0:	63 01       	movw	r12, r6
    40b2:	e1 2c       	mov	r14, r1
    40b4:	f1 2c       	mov	r15, r1
    40b6:	87 01       	movw	r16, r14
    40b8:	2f e0       	ldi	r18, 0x0F	; 15
    40ba:	42 e1       	ldi	r20, 0x12	; 18
    40bc:	63 e0       	ldi	r22, 0x03	; 3
    40be:	82 e0       	ldi	r24, 0x02	; 2
    40c0:	0e 94 41 18 	call	0x3082	; 0x3082 <csp_sendto>
				break;
    40c4:	20 cf       	rjmp	.-448    	; 0x3f06 <mainTask+0x18>
			
				// ask board for status
				case 'p':	
					outcomingPacket->data[0] = 0;
    40c6:	f3 01       	movw	r30, r6
    40c8:	16 86       	std	Z+14, r1	; 0x0e
					outcomingPacket->length = 1;
					pingSent = milisecondsTimer;
    40ca:	80 91 5a 3f 	lds	r24, 0x3F5A
    40ce:	90 91 5b 3f 	lds	r25, 0x3F5B
    40d2:	a0 91 5c 3f 	lds	r26, 0x3F5C
    40d6:	b0 91 5d 3f 	lds	r27, 0x3F5D
    40da:	80 93 4a 3f 	sts	0x3F4A, r24
    40de:	90 93 4b 3f 	sts	0x3F4B, r25
    40e2:	a0 93 4c 3f 	sts	0x3F4C, r26
    40e6:	b0 93 4d 3f 	sts	0x3F4D, r27
					csp_sendto(CSP_PRIO_NORM, CSP_BOARD_ADDRESS, 1, 32, CSP_O_NONE, outcomingPacket, 10);
    40ea:	0f 2e       	mov	r0, r31
    40ec:	fa e0       	ldi	r31, 0x0A	; 10
    40ee:	8f 2e       	mov	r8, r31
    40f0:	91 2c       	mov	r9, r1
    40f2:	a1 2c       	mov	r10, r1
    40f4:	b1 2c       	mov	r11, r1
    40f6:	f0 2d       	mov	r31, r0
    40f8:	63 01       	movw	r12, r6
    40fa:	e1 2c       	mov	r14, r1
    40fc:	f1 2c       	mov	r15, r1
    40fe:	87 01       	movw	r16, r14
    4100:	20 e2       	ldi	r18, 0x20	; 32
    4102:	41 e0       	ldi	r20, 0x01	; 1
    4104:	63 e0       	ldi	r22, 0x03	; 3
    4106:	82 e0       	ldi	r24, 0x02	; 2
    4108:	0e 94 41 18 	call	0x3082	; 0x3082 <csp_sendto>
				break;
    410c:	fc ce       	rjmp	.-520    	; 0x3f06 <mainTask+0x18>
			
				// sends the char and is supposed to receive it back
				default:
					csp_sendto(CSP_PRIO_NORM, CSP_BOARD_ADDRESS, 15, 15, CSP_O_NONE,  outcomingPacket, 10);
    410e:	0f 2e       	mov	r0, r31
    4110:	fa e0       	ldi	r31, 0x0A	; 10
    4112:	8f 2e       	mov	r8, r31
    4114:	91 2c       	mov	r9, r1
    4116:	a1 2c       	mov	r10, r1
    4118:	b1 2c       	mov	r11, r1
    411a:	f0 2d       	mov	r31, r0
    411c:	63 01       	movw	r12, r6
    411e:	e1 2c       	mov	r14, r1
    4120:	f1 2c       	mov	r15, r1
    4122:	87 01       	movw	r16, r14
    4124:	2f e0       	ldi	r18, 0x0F	; 15
    4126:	4f e0       	ldi	r20, 0x0F	; 15
    4128:	63 e0       	ldi	r22, 0x03	; 3
    412a:	82 e0       	ldi	r24, 0x02	; 2
    412c:	0e 94 41 18 	call	0x3082	; 0x3082 <csp_sendto>
				break;
    4130:	ea ce       	rjmp	.-556    	; 0x3f06 <mainTask+0x18>

00004132 <PORT_ConfigurePins>:
                         uint8_t pinMask,
                         uint8_t slewRateEnable,
                         uint8_t invertEnable,
                         PORT_OPC_t opc,
                         PORT_ISC_t isc)
{
    4132:	ef 92       	push	r14
    4134:	0f 93       	push	r16
	/* Build pin control register value. */
	uint8_t temp = (uint8_t) opc |
    4136:	0e 29       	or	r16, r14
    4138:	44 23       	and	r20, r20
    413a:	11 f0       	breq	.+4      	; 0x4140 <PORT_ConfigurePins+0xe>
    413c:	30 e8       	ldi	r19, 0x80	; 128
    413e:	01 c0       	rjmp	.+2      	; 0x4142 <PORT_ConfigurePins+0x10>
    4140:	30 e0       	ldi	r19, 0x00	; 0
    4142:	03 2b       	or	r16, r19
    4144:	22 23       	and	r18, r18
    4146:	11 f0       	breq	.+4      	; 0x414c <PORT_ConfigurePins+0x1a>
    4148:	20 e4       	ldi	r18, 0x40	; 64
    414a:	01 c0       	rjmp	.+2      	; 0x414e <PORT_ConfigurePins+0x1c>
    414c:	20 e0       	ldi	r18, 0x00	; 0
    414e:	02 2b       	or	r16, r18
	               (invertEnable ? PORT_INVEN_bm : 0);

	/* Configure the pins in one atomic operation. */

	/* Save status register. */
	uint8_t sreg = SREG;
    4150:	2f b7       	in	r18, 0x3f	; 63

	cli();
    4152:	f8 94       	cli
	PORTCFG.MPCMASK = pinMask;
    4154:	60 93 b0 00 	sts	0x00B0, r22
	port->PIN0CTRL = temp;
    4158:	fc 01       	movw	r30, r24
    415a:	00 8b       	std	Z+16, r16	; 0x10

	/* Restore status register. */
	SREG = sreg;
    415c:	2f bf       	out	0x3f, r18	; 63
}
    415e:	0f 91       	pop	r16
    4160:	ef 90       	pop	r14
    4162:	08 95       	ret

00004164 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    4164:	fc 01       	movw	r30, r24
    4166:	20 81       	ld	r18, Z
    4168:	20 7f       	andi	r18, 0xF0	; 240
    416a:	62 2b       	or	r22, r18
    416c:	60 83       	st	Z, r22
    416e:	08 95       	ret

00004170 <TC1_ConfigClockSource>:
    4170:	fc 01       	movw	r30, r24
    4172:	20 81       	ld	r18, Z
    4174:	20 7f       	andi	r18, 0xF0	; 240
    4176:	62 2b       	or	r22, r18
    4178:	60 83       	st	Z, r22
    417a:	08 95       	ret

0000417c <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    417c:	fc 01       	movw	r30, r24
    417e:	26 81       	ldd	r18, Z+6	; 0x06
    4180:	2c 7f       	andi	r18, 0xFC	; 252
    4182:	62 2b       	or	r22, r18
    4184:	66 83       	std	Z+6, r22	; 0x06
    4186:	08 95       	ret

00004188 <TC1_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC1_SetOverflowIntLevel( volatile TC1_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_OVFINTLVL_gm ) | intLevel;
    4188:	fc 01       	movw	r30, r24
    418a:	26 81       	ldd	r18, Z+6	; 0x06
    418c:	2c 7f       	andi	r18, 0xFC	; 252
    418e:	62 2b       	or	r22, r18
    4190:	66 83       	std	Z+6, r22	; 0x06
    4192:	08 95       	ret

00004194 <TWI_MasterInit>:
                    uint8_t address,
                    uint8_t bytesToRead)
{
	bool twi_status = TWI_MasterWriteRead(twi, address, 0, 0, bytesToRead);
	return twi_status;
}
    4194:	fc 01       	movw	r30, r24
    4196:	60 83       	st	Z, r22
    4198:	71 83       	std	Z+1, r23	; 0x01
    419a:	48 63       	ori	r20, 0x38	; 56
    419c:	db 01       	movw	r26, r22
    419e:	11 96       	adiw	r26, 0x01	; 1
    41a0:	4c 93       	st	X, r20
    41a2:	a0 81       	ld	r26, Z
    41a4:	b1 81       	ldd	r27, Z+1	; 0x01
    41a6:	15 96       	adiw	r26, 0x05	; 5
    41a8:	2c 93       	st	X, r18
    41aa:	01 90       	ld	r0, Z+
    41ac:	f0 81       	ld	r31, Z
    41ae:	e0 2d       	mov	r30, r0
    41b0:	81 e0       	ldi	r24, 0x01	; 1
    41b2:	84 83       	std	Z+4, r24	; 0x04
    41b4:	08 95       	ret

000041b6 <TWI_MasterWriteRead>:
    41b6:	0f 93       	push	r16
    41b8:	cf 93       	push	r28
    41ba:	df 93       	push	r29
    41bc:	29 34       	cpi	r18, 0x49	; 73
    41be:	08 f0       	brcs	.+2      	; 0x41c2 <TWI_MasterWriteRead+0xc>
    41c0:	4f c0       	rjmp	.+158    	; 0x4260 <TWI_MasterWriteRead+0xaa>
    41c2:	02 30       	cpi	r16, 0x02	; 2
    41c4:	08 f0       	brcs	.+2      	; 0x41c8 <TWI_MasterWriteRead+0x12>
    41c6:	4e c0       	rjmp	.+156    	; 0x4264 <TWI_MasterWriteRead+0xae>
    41c8:	fc 01       	movw	r30, r24
    41ca:	e0 5b       	subi	r30, 0xB0	; 176
    41cc:	ff 4f       	sbci	r31, 0xFF	; 255
    41ce:	30 81       	ld	r19, Z
    41d0:	31 11       	cpse	r19, r1
    41d2:	4a c0       	rjmp	.+148    	; 0x4268 <TWI_MasterWriteRead+0xb2>
    41d4:	31 e0       	ldi	r19, 0x01	; 1
    41d6:	30 83       	st	Z, r19
    41d8:	31 96       	adiw	r30, 0x01	; 1
    41da:	10 82       	st	Z, r1
    41dc:	66 0f       	add	r22, r22
    41de:	dc 01       	movw	r26, r24
    41e0:	12 96       	adiw	r26, 0x02	; 2
    41e2:	6c 93       	st	X, r22
    41e4:	22 23       	and	r18, r18
    41e6:	a1 f0       	breq	.+40     	; 0x4210 <TWI_MasterWriteRead+0x5a>
    41e8:	ea 01       	movw	r28, r20
    41ea:	ba 01       	movw	r22, r20
    41ec:	6f 5f       	subi	r22, 0xFF	; 255
    41ee:	7f 4f       	sbci	r23, 0xFF	; 255
    41f0:	3f ef       	ldi	r19, 0xFF	; 255
    41f2:	32 0f       	add	r19, r18
    41f4:	63 0f       	add	r22, r19
    41f6:	71 1d       	adc	r23, r1
    41f8:	fa 01       	movw	r30, r20
    41fa:	df 01       	movw	r26, r30
    41fc:	ac 1b       	sub	r26, r28
    41fe:	bd 0b       	sbc	r27, r29
    4200:	31 91       	ld	r19, Z+
    4202:	a8 0f       	add	r26, r24
    4204:	b9 1f       	adc	r27, r25
    4206:	13 96       	adiw	r26, 0x03	; 3
    4208:	3c 93       	st	X, r19
    420a:	e6 17       	cp	r30, r22
    420c:	f7 07       	cpc	r31, r23
    420e:	a9 f7       	brne	.-22     	; 0x41fa <TWI_MasterWriteRead+0x44>
    4210:	fc 01       	movw	r30, r24
    4212:	e4 5b       	subi	r30, 0xB4	; 180
    4214:	ff 4f       	sbci	r31, 0xFF	; 255
    4216:	20 83       	st	Z, r18
    4218:	dc 01       	movw	r26, r24
    421a:	a3 5b       	subi	r26, 0xB3	; 179
    421c:	bf 4f       	sbci	r27, 0xFF	; 255
    421e:	0c 93       	st	X, r16
    4220:	11 96       	adiw	r26, 0x01	; 1
    4222:	1c 92       	st	X, r1
    4224:	11 96       	adiw	r26, 0x01	; 1
    4226:	1c 92       	st	X, r1
    4228:	20 81       	ld	r18, Z
    422a:	22 23       	and	r18, r18
    422c:	49 f0       	breq	.+18     	; 0x4240 <TWI_MasterWriteRead+0x8a>
    422e:	fc 01       	movw	r30, r24
    4230:	22 81       	ldd	r18, Z+2	; 0x02
    4232:	2e 7f       	andi	r18, 0xFE	; 254
    4234:	01 90       	ld	r0, Z+
    4236:	f0 81       	ld	r31, Z
    4238:	e0 2d       	mov	r30, r0
    423a:	26 83       	std	Z+6, r18	; 0x06
    423c:	81 e0       	ldi	r24, 0x01	; 1
    423e:	17 c0       	rjmp	.+46     	; 0x426e <TWI_MasterWriteRead+0xb8>
    4240:	fc 01       	movw	r30, r24
    4242:	e3 5b       	subi	r30, 0xB3	; 179
    4244:	ff 4f       	sbci	r31, 0xFF	; 255
    4246:	20 81       	ld	r18, Z
    4248:	22 23       	and	r18, r18
    424a:	81 f0       	breq	.+32     	; 0x426c <TWI_MasterWriteRead+0xb6>
    424c:	dc 01       	movw	r26, r24
    424e:	12 96       	adiw	r26, 0x02	; 2
    4250:	2c 91       	ld	r18, X
    4252:	12 97       	sbiw	r26, 0x02	; 2
    4254:	21 60       	ori	r18, 0x01	; 1
    4256:	ed 91       	ld	r30, X+
    4258:	fc 91       	ld	r31, X
    425a:	26 83       	std	Z+6, r18	; 0x06
    425c:	81 e0       	ldi	r24, 0x01	; 1
    425e:	07 c0       	rjmp	.+14     	; 0x426e <TWI_MasterWriteRead+0xb8>
    4260:	80 e0       	ldi	r24, 0x00	; 0
    4262:	05 c0       	rjmp	.+10     	; 0x426e <TWI_MasterWriteRead+0xb8>
    4264:	80 e0       	ldi	r24, 0x00	; 0
    4266:	03 c0       	rjmp	.+6      	; 0x426e <TWI_MasterWriteRead+0xb8>
    4268:	80 e0       	ldi	r24, 0x00	; 0
    426a:	01 c0       	rjmp	.+2      	; 0x426e <TWI_MasterWriteRead+0xb8>
    426c:	81 e0       	ldi	r24, 0x01	; 1
    426e:	df 91       	pop	r29
    4270:	cf 91       	pop	r28
    4272:	0f 91       	pop	r16
    4274:	08 95       	ret

00004276 <TWI_MasterWrite>:
    4276:	0f 93       	push	r16
    4278:	00 e0       	ldi	r16, 0x00	; 0
    427a:	9d df       	rcall	.-198    	; 0x41b6 <TWI_MasterWriteRead>
    427c:	0f 91       	pop	r16
    427e:	08 95       	ret

00004280 <TWI_MasterArbitrationLostBusErrorHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    4280:	dc 01       	movw	r26, r24
    4282:	ed 91       	ld	r30, X+
    4284:	fc 91       	ld	r31, X
    4286:	11 97       	sbiw	r26, 0x01	; 1
    4288:	24 81       	ldd	r18, Z+4	; 0x04

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    428a:	22 ff       	sbrs	r18, 2
    428c:	05 c0       	rjmp	.+10     	; 0x4298 <TWI_MasterArbitrationLostBusErrorHandler+0x18>
		twi->result = TWIM_RESULT_BUS_ERROR;
    428e:	34 e0       	ldi	r19, 0x04	; 4
    4290:	af 5a       	subi	r26, 0xAF	; 175
    4292:	bf 4f       	sbci	r27, 0xFF	; 255
    4294:	3c 93       	st	X, r19
    4296:	05 c0       	rjmp	.+10     	; 0x42a2 <TWI_MasterArbitrationLostBusErrorHandler+0x22>
	}
	/* If arbitration lost. */
	else {
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
    4298:	33 e0       	ldi	r19, 0x03	; 3
    429a:	dc 01       	movw	r26, r24
    429c:	af 5a       	subi	r26, 0xAF	; 175
    429e:	bf 4f       	sbci	r27, 0xFF	; 255
    42a0:	3c 93       	st	X, r19
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    42a2:	28 60       	ori	r18, 0x08	; 8
    42a4:	24 83       	std	Z+4, r18	; 0x04

	twi->status = TWIM_STATUS_READY;
    42a6:	fc 01       	movw	r30, r24
    42a8:	e0 5b       	subi	r30, 0xB0	; 176
    42aa:	ff 4f       	sbci	r31, 0xFF	; 255
    42ac:	10 82       	st	Z, r1
    42ae:	08 95       	ret

000042b0 <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
    42b0:	cf 93       	push	r28
    42b2:	df 93       	push	r29
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
    42b4:	fc 01       	movw	r30, r24
    42b6:	e4 5b       	subi	r30, 0xB4	; 180
    42b8:	ff 4f       	sbci	r31, 0xFF	; 255
    42ba:	30 81       	ld	r19, Z
	uint8_t bytesToRead   = twi->bytesToRead;
    42bc:	31 96       	adiw	r30, 0x01	; 1
    42be:	40 81       	ld	r20, Z

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
    42c0:	dc 01       	movw	r26, r24
    42c2:	ed 91       	ld	r30, X+
    42c4:	fc 91       	ld	r31, X
    42c6:	24 81       	ldd	r18, Z+4	; 0x04
    42c8:	24 ff       	sbrs	r18, 4
    42ca:	0a c0       	rjmp	.+20     	; 0x42e0 <TWI_MasterWriteHandler+0x30>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    42cc:	23 e0       	ldi	r18, 0x03	; 3
    42ce:	23 83       	std	Z+3, r18	; 0x03
		twi->result = TWIM_RESULT_NACK_RECEIVED;
    42d0:	fc 01       	movw	r30, r24
    42d2:	ef 5a       	subi	r30, 0xAF	; 175
    42d4:	ff 4f       	sbci	r31, 0xFF	; 255
    42d6:	25 e0       	ldi	r18, 0x05	; 5
    42d8:	20 83       	st	Z, r18
		twi->status = TWIM_STATUS_READY;
    42da:	31 97       	sbiw	r30, 0x01	; 1
    42dc:	10 82       	st	Z, r1
    42de:	25 c0       	rjmp	.+74     	; 0x432a <TWI_MasterWriteHandler+0x7a>
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
    42e0:	dc 01       	movw	r26, r24
    42e2:	a2 5b       	subi	r26, 0xB2	; 178
    42e4:	bf 4f       	sbci	r27, 0xFF	; 255
    42e6:	2c 91       	ld	r18, X
    42e8:	23 17       	cp	r18, r19
    42ea:	50 f4       	brcc	.+20     	; 0x4300 <TWI_MasterWriteHandler+0x50>
		uint8_t data = twi->writeData[twi->bytesWritten];
    42ec:	2c 91       	ld	r18, X
    42ee:	ec 01       	movw	r28, r24
    42f0:	c2 0f       	add	r28, r18
    42f2:	d1 1d       	adc	r29, r1
    42f4:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
    42f6:	87 83       	std	Z+7, r24	; 0x07
		++twi->bytesWritten;
    42f8:	8c 91       	ld	r24, X
    42fa:	8f 5f       	subi	r24, 0xFF	; 255
    42fc:	8c 93       	st	X, r24
    42fe:	15 c0       	rjmp	.+42     	; 0x432a <TWI_MasterWriteHandler+0x7a>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
    4300:	dc 01       	movw	r26, r24
    4302:	a1 5b       	subi	r26, 0xB1	; 177
    4304:	bf 4f       	sbci	r27, 0xFF	; 255
    4306:	2c 91       	ld	r18, X
    4308:	24 17       	cp	r18, r20
    430a:	30 f4       	brcc	.+12     	; 0x4318 <TWI_MasterWriteHandler+0x68>
		uint8_t readAddress = twi->address | 0x01;
    430c:	dc 01       	movw	r26, r24
    430e:	12 96       	adiw	r26, 0x02	; 2
    4310:	8c 91       	ld	r24, X
    4312:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
    4314:	86 83       	std	Z+6, r24	; 0x06
    4316:	09 c0       	rjmp	.+18     	; 0x432a <TWI_MasterWriteHandler+0x7a>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    4318:	23 e0       	ldi	r18, 0x03	; 3
    431a:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    431c:	fc 01       	movw	r30, r24
    431e:	ef 5a       	subi	r30, 0xAF	; 175
    4320:	ff 4f       	sbci	r31, 0xFF	; 255
    4322:	21 e0       	ldi	r18, 0x01	; 1
    4324:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    4326:	31 97       	sbiw	r30, 0x01	; 1
    4328:	10 82       	st	Z, r1
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
    432a:	df 91       	pop	r29
    432c:	cf 91       	pop	r28
    432e:	08 95       	ret

00004330 <TWI_MasterReadHandler>:
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) {
    4330:	fc 01       	movw	r30, r24
    4332:	e1 5b       	subi	r30, 0xB1	; 177
    4334:	ff 4f       	sbci	r31, 0xFF	; 255
    4336:	20 81       	ld	r18, Z
    4338:	21 11       	cpse	r18, r1
    433a:	12 c0       	rjmp	.+36     	; 0x4360 <TWI_MasterReadHandler+0x30>
		uint8_t data = twi->interface->MASTER.DATA;
    433c:	dc 01       	movw	r26, r24
    433e:	ed 91       	ld	r30, X+
    4340:	fc 91       	ld	r31, X
    4342:	11 97       	sbiw	r26, 0x01	; 1
    4344:	27 81       	ldd	r18, Z+7	; 0x07
		twi->readData[twi->bytesRead] = data;
    4346:	fc 01       	movw	r30, r24
    4348:	e1 5b       	subi	r30, 0xB1	; 177
    434a:	ff 4f       	sbci	r31, 0xFF	; 255
    434c:	30 81       	ld	r19, Z
    434e:	a3 0f       	add	r26, r19
    4350:	b1 1d       	adc	r27, r1
    4352:	a5 5b       	subi	r26, 0xB5	; 181
    4354:	bf 4f       	sbci	r27, 0xFF	; 255
    4356:	2c 93       	st	X, r18
		twi->bytesRead++;
    4358:	20 81       	ld	r18, Z
    435a:	2f 5f       	subi	r18, 0xFF	; 255
    435c:	20 83       	st	Z, r18
    435e:	0c c0       	rjmp	.+24     	; 0x4378 <TWI_MasterReadHandler+0x48>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    4360:	dc 01       	movw	r26, r24
    4362:	ed 91       	ld	r30, X+
    4364:	fc 91       	ld	r31, X
    4366:	23 e0       	ldi	r18, 0x03	; 3
    4368:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    436a:	22 e0       	ldi	r18, 0x02	; 2
    436c:	fc 01       	movw	r30, r24
    436e:	ef 5a       	subi	r30, 0xAF	; 175
    4370:	ff 4f       	sbci	r31, 0xFF	; 255
    4372:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    4374:	31 97       	sbiw	r30, 0x01	; 1
    4376:	10 82       	st	Z, r1
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
    4378:	fc 01       	movw	r30, r24
    437a:	e3 5b       	subi	r30, 0xB3	; 179
    437c:	ff 4f       	sbci	r31, 0xFF	; 255
    437e:	30 81       	ld	r19, Z

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) {
    4380:	32 96       	adiw	r30, 0x02	; 2
    4382:	20 81       	ld	r18, Z
    4384:	23 17       	cp	r18, r19
    4386:	30 f4       	brcc	.+12     	; 0x4394 <TWI_MasterReadHandler+0x64>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    4388:	dc 01       	movw	r26, r24
    438a:	ed 91       	ld	r30, X+
    438c:	fc 91       	ld	r31, X
    438e:	82 e0       	ldi	r24, 0x02	; 2
    4390:	83 83       	std	Z+3, r24	; 0x03
    4392:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
    4394:	dc 01       	movw	r26, r24
    4396:	ed 91       	ld	r30, X+
    4398:	fc 91       	ld	r31, X
    439a:	27 e0       	ldi	r18, 0x07	; 7
    439c:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    439e:	fc 01       	movw	r30, r24
    43a0:	ef 5a       	subi	r30, 0xAF	; 175
    43a2:	ff 4f       	sbci	r31, 0xFF	; 255
    43a4:	21 e0       	ldi	r18, 0x01	; 1
    43a6:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    43a8:	31 97       	sbiw	r30, 0x01	; 1
    43aa:	10 82       	st	Z, r1
    43ac:	08 95       	ret

000043ae <TWI_MasterInterruptHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    43ae:	dc 01       	movw	r26, r24
    43b0:	ed 91       	ld	r30, X+
    43b2:	fc 91       	ld	r31, X
    43b4:	24 81       	ldd	r18, Z+4	; 0x04
    43b6:	32 2f       	mov	r19, r18
    43b8:	3c 70       	andi	r19, 0x0C	; 12

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    43ba:	11 f0       	breq	.+4      	; 0x43c0 <TWI_MasterInterruptHandler+0x12>
	    (currentStatus & TWI_MASTER_BUSERR_bm)) {

		TWI_MasterArbitrationLostBusErrorHandler(twi);
    43bc:	61 cf       	rjmp	.-318    	; 0x4280 <TWI_MasterArbitrationLostBusErrorHandler>
    43be:	08 95       	ret
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    43c0:	26 ff       	sbrs	r18, 6
    43c2:	02 c0       	rjmp	.+4      	; 0x43c8 <TWI_MasterInterruptHandler+0x1a>
		TWI_MasterWriteHandler(twi);
    43c4:	75 cf       	rjmp	.-278    	; 0x42b0 <TWI_MasterWriteHandler>
    43c6:	08 95       	ret
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    43c8:	22 23       	and	r18, r18
    43ca:	14 f4       	brge	.+4      	; 0x43d0 <TWI_MasterInterruptHandler+0x22>
		TWI_MasterReadHandler(twi);
    43cc:	b1 cf       	rjmp	.-158    	; 0x4330 <TWI_MasterReadHandler>
    43ce:	08 95       	ret
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    43d0:	fc 01       	movw	r30, r24
    43d2:	ef 5a       	subi	r30, 0xAF	; 175
    43d4:	ff 4f       	sbci	r31, 0xFF	; 255
    43d6:	26 e0       	ldi	r18, 0x06	; 6
    43d8:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    43da:	31 97       	sbiw	r30, 0x01	; 1
    43dc:	10 82       	st	Z, r1
    43de:	08 95       	ret

000043e0 <TWI_SlaveInitializeDriver>:
 */
void TWI_SlaveInitializeDriver(TWI_Slave_t *twi,
                               TWI_t *module,
                               void (*processDataFunction) (void))
{
	twi->interface = module;
    43e0:	fc 01       	movw	r30, r24
    43e2:	60 83       	st	Z, r22
    43e4:	71 83       	std	Z+1, r23	; 0x01
	twi->Process_Data = processDataFunction;
    43e6:	42 83       	std	Z+2, r20	; 0x02
    43e8:	53 83       	std	Z+3, r21	; 0x03
	twi->bytesReceived = 0;
    43ea:	e3 5b       	subi	r30, 0xB3	; 179
    43ec:	ff 4f       	sbci	r31, 0xFF	; 255
    43ee:	10 82       	st	Z, r1
	twi->bytesSent = 0;
    43f0:	31 96       	adiw	r30, 0x01	; 1
    43f2:	10 82       	st	Z, r1
	twi->status = TWIS_STATUS_READY;
    43f4:	31 96       	adiw	r30, 0x01	; 1
    43f6:	10 82       	st	Z, r1
	twi->result = TWIS_RESULT_UNKNOWN;
    43f8:	31 96       	adiw	r30, 0x01	; 1
    43fa:	10 82       	st	Z, r1
	twi->abort = false;
    43fc:	31 96       	adiw	r30, 0x01	; 1
    43fe:	10 82       	st	Z, r1
    4400:	08 95       	ret

00004402 <TWI_SlaveInitializeModule>:
 */
void TWI_SlaveInitializeModule(TWI_Slave_t *twi,
                               uint8_t address,
                               TWI_SLAVE_INTLVL_t intLevel)
{
	twi->interface->SLAVE.CTRLA = intLevel |
    4402:	dc 01       	movw	r26, r24
    4404:	ed 91       	ld	r30, X+
    4406:	fc 91       	ld	r31, X
    4408:	11 97       	sbiw	r26, 0x01	; 1
    440a:	48 63       	ori	r20, 0x38	; 56
    440c:	40 87       	std	Z+8, r20	; 0x08
	                              TWI_SLAVE_DIEN_bm |
	                              TWI_SLAVE_APIEN_bm |
	                              TWI_SLAVE_ENABLE_bm;
	twi->interface->SLAVE.ADDR = (address<<1);
    440e:	ed 91       	ld	r30, X+
    4410:	fc 91       	ld	r31, X
    4412:	66 0f       	add	r22, r22
    4414:	63 87       	std	Z+11, r22	; 0x0b
    4416:	08 95       	ret

00004418 <TWI_SlaveTransactionFinished>:
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
    4418:	fc 01       	movw	r30, r24
    441a:	e0 5b       	subi	r30, 0xB0	; 176
    441c:	ff 4f       	sbci	r31, 0xFF	; 255
    441e:	60 83       	st	Z, r22
	twi->status = TWIS_STATUS_READY;
    4420:	31 97       	sbiw	r30, 0x01	; 1
    4422:	10 82       	st	Z, r1
	

	/* Process data. */
	twi->Process_Data();
    4424:	dc 01       	movw	r26, r24
    4426:	12 96       	adiw	r26, 0x02	; 2
    4428:	ed 91       	ld	r30, X+
    442a:	fc 91       	ld	r31, X
    442c:	13 97       	sbiw	r26, 0x03	; 3
    442e:	19 95       	eicall
    4430:	08 95       	ret

00004432 <TWI_SlaveAddressMatchHandler>:
 *  Prepares TWI module for transaction when an address match occures.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveAddressMatchHandler(TWI_Slave_t *twi)
{
    4432:	cf 93       	push	r28
    4434:	df 93       	push	r29
    4436:	ec 01       	movw	r28, r24
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
    4438:	fc 01       	movw	r30, r24
    443a:	ef 5a       	subi	r30, 0xAF	; 175
    443c:	ff 4f       	sbci	r31, 0xFF	; 255
    443e:	80 81       	ld	r24, Z
    4440:	88 23       	and	r24, r24
    4442:	59 f0       	breq	.+22     	; 0x445a <TWI_SlaveAddressMatchHandler+0x28>
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    4444:	e8 81       	ld	r30, Y
    4446:	f9 81       	ldd	r31, Y+1	; 0x01
    4448:	82 e0       	ldi	r24, 0x02	; 2
    444a:	81 87       	std	Z+9, r24	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    444c:	66 e0       	ldi	r22, 0x06	; 6
    444e:	ce 01       	movw	r24, r28
    4450:	e3 df       	rcall	.-58     	; 0x4418 <TWI_SlaveTransactionFinished>
		twi->abort = false;
    4452:	cf 5a       	subi	r28, 0xAF	; 175
    4454:	df 4f       	sbci	r29, 0xFF	; 255
    4456:	18 82       	st	Y, r1
    4458:	16 c0       	rjmp	.+44     	; 0x4486 <TWI_SlaveAddressMatchHandler+0x54>
	} else {
		twi->status = TWIS_STATUS_BUSY;
    445a:	fe 01       	movw	r30, r28
    445c:	e1 5b       	subi	r30, 0xB1	; 177
    445e:	ff 4f       	sbci	r31, 0xFF	; 255
    4460:	81 e0       	ldi	r24, 0x01	; 1
    4462:	80 83       	st	Z, r24
		twi->result = TWIS_RESULT_UNKNOWN;
    4464:	31 96       	adiw	r30, 0x01	; 1
    4466:	10 82       	st	Z, r1

		/* Disable stop interrupt. */
		uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    4468:	e8 81       	ld	r30, Y
    446a:	f9 81       	ldd	r31, Y+1	; 0x01
    446c:	80 85       	ldd	r24, Z+8	; 0x08
		twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    446e:	8b 7f       	andi	r24, 0xFB	; 251
    4470:	80 87       	std	Z+8, r24	; 0x08

		twi->bytesReceived = 0;
    4472:	fe 01       	movw	r30, r28
    4474:	e3 5b       	subi	r30, 0xB3	; 179
    4476:	ff 4f       	sbci	r31, 0xFF	; 255
    4478:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    447a:	31 96       	adiw	r30, 0x01	; 1
    447c:	10 82       	st	Z, r1

		/* Send ACK, wait for data interrupt. */
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    447e:	e8 81       	ld	r30, Y
    4480:	f9 81       	ldd	r31, Y+1	; 0x01
    4482:	83 e0       	ldi	r24, 0x03	; 3
    4484:	81 87       	std	Z+9, r24	; 0x09
	}
}
    4486:	df 91       	pop	r29
    4488:	cf 91       	pop	r28
    448a:	08 95       	ret

0000448c <TWI_SlaveStopHandler>:
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveStopHandler(TWI_Slave_t *twi)
{
	/* Disable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    448c:	dc 01       	movw	r26, r24
    448e:	ed 91       	ld	r30, X+
    4490:	fc 91       	ld	r31, X
    4492:	11 97       	sbiw	r26, 0x01	; 1
    4494:	20 85       	ldd	r18, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    4496:	2b 7f       	andi	r18, 0xFB	; 251
    4498:	20 87       	std	Z+8, r18	; 0x08
	
	/* Clear APIF, according to flowchart don't ACK or NACK */
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    449a:	ed 91       	ld	r30, X+
    449c:	fc 91       	ld	r31, X
    449e:	22 85       	ldd	r18, Z+10	; 0x0a
	twi->interface->SLAVE.STATUS = currentStatus | TWI_SLAVE_APIF_bm;
    44a0:	20 64       	ori	r18, 0x40	; 64
    44a2:	22 87       	std	Z+10, r18	; 0x0a

	TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    44a4:	61 e0       	ldi	r22, 0x01	; 1
    44a6:	b8 cf       	rjmp	.-144    	; 0x4418 <TWI_SlaveTransactionFinished>
    44a8:	08 95       	ret

000044aa <TWI_SlaveReadHandler>:
 *  Handles TWI slave read transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveReadHandler(TWI_Slave_t *twi)
{
    44aa:	cf 93       	push	r28
    44ac:	df 93       	push	r29
    44ae:	ec 01       	movw	r28, r24
	/* Enable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    44b0:	e8 81       	ld	r30, Y
    44b2:	f9 81       	ldd	r31, Y+1	; 0x01
    44b4:	80 85       	ldd	r24, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
    44b6:	84 60       	ori	r24, 0x04	; 4
    44b8:	80 87       	std	Z+8, r24	; 0x08

	/* If free space in buffer. */
	if (twi->bytesReceived < TWIS_RECEIVE_BUFFER_SIZE) {
    44ba:	fe 01       	movw	r30, r28
    44bc:	e3 5b       	subi	r30, 0xB3	; 179
    44be:	ff 4f       	sbci	r31, 0xFF	; 255
    44c0:	80 81       	ld	r24, Z
    44c2:	88 34       	cpi	r24, 0x48	; 72
    44c4:	10 f5       	brcc	.+68     	; 0x450a <TWI_SlaveReadHandler+0x60>
		/* Fetch data */
		uint8_t data = twi->interface->SLAVE.DATA;
    44c6:	68 81       	ld	r22, Y
    44c8:	79 81       	ldd	r23, Y+1	; 0x01
    44ca:	db 01       	movw	r26, r22
    44cc:	1c 96       	adiw	r26, 0x0c	; 12
    44ce:	2c 91       	ld	r18, X
		twi->receivedData[twi->bytesReceived] = data;
    44d0:	80 81       	ld	r24, Z
    44d2:	ae 01       	movw	r20, r28
    44d4:	48 0f       	add	r20, r24
    44d6:	51 1d       	adc	r21, r1
    44d8:	da 01       	movw	r26, r20
    44da:	14 96       	adiw	r26, 0x04	; 4
    44dc:	2c 93       	st	X, r18

		twi->bytesReceived++;
    44de:	80 81       	ld	r24, Z
    44e0:	8f 5f       	subi	r24, 0xFF	; 255
    44e2:	80 83       	st	Z, r24

		/* If application signalling need to abort (error occured),
		 * complete transaction and wait for next START. Otherwise
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
    44e4:	34 96       	adiw	r30, 0x04	; 4
    44e6:	80 81       	ld	r24, Z
    44e8:	88 23       	and	r24, r24
    44ea:	51 f0       	breq	.+20     	; 0x4500 <TWI_SlaveReadHandler+0x56>
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    44ec:	82 e0       	ldi	r24, 0x02	; 2
    44ee:	fb 01       	movw	r30, r22
    44f0:	81 87       	std	Z+9, r24	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    44f2:	66 e0       	ldi	r22, 0x06	; 6
    44f4:	ce 01       	movw	r24, r28
    44f6:	90 df       	rcall	.-224    	; 0x4418 <TWI_SlaveTransactionFinished>
			twi->abort = false;
    44f8:	cf 5a       	subi	r28, 0xAF	; 175
    44fa:	df 4f       	sbci	r29, 0xFF	; 255
    44fc:	18 82       	st	Y, r1
    44fe:	0c c0       	rjmp	.+24     	; 0x4518 <TWI_SlaveReadHandler+0x6e>
		} else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    4500:	83 e0       	ldi	r24, 0x03	; 3
    4502:	db 01       	movw	r26, r22
    4504:	19 96       	adiw	r26, 0x09	; 9
    4506:	8c 93       	st	X, r24
    4508:	07 c0       	rjmp	.+14     	; 0x4518 <TWI_SlaveReadHandler+0x6e>
	}
	/* If buffer overflow, send NACK and wait for next START. Set
	 * result buffer overflow.
	 */
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
    450a:	e8 81       	ld	r30, Y
    450c:	f9 81       	ldd	r31, Y+1	; 0x01
    450e:	86 e0       	ldi	r24, 0x06	; 6
    4510:	81 87       	std	Z+9, r24	; 0x09
		                              TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    4512:	62 e0       	ldi	r22, 0x02	; 2
    4514:	ce 01       	movw	r24, r28
    4516:	80 df       	rcall	.-256    	; 0x4418 <TWI_SlaveTransactionFinished>
	}
}
    4518:	df 91       	pop	r29
    451a:	cf 91       	pop	r28
    451c:	08 95       	ret

0000451e <TWI_SlaveWriteHandler>:
 *  Handles TWI slave write transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
{
    451e:	cf 93       	push	r28
    4520:	df 93       	push	r29
	/* If NACK, slave write transaction finished. */
	if ((twi->bytesSent > 0) && (twi->interface->SLAVE.STATUS &
    4522:	fc 01       	movw	r30, r24
    4524:	e2 5b       	subi	r30, 0xB2	; 178
    4526:	ff 4f       	sbci	r31, 0xFF	; 255
    4528:	20 81       	ld	r18, Z
    452a:	22 23       	and	r18, r18
    452c:	59 f0       	breq	.+22     	; 0x4544 <TWI_SlaveWriteHandler+0x26>
    452e:	dc 01       	movw	r26, r24
    4530:	ed 91       	ld	r30, X+
    4532:	fc 91       	ld	r31, X
    4534:	22 85       	ldd	r18, Z+10	; 0x0a
    4536:	24 ff       	sbrs	r18, 4
    4538:	05 c0       	rjmp	.+10     	; 0x4544 <TWI_SlaveWriteHandler+0x26>
	                             TWI_SLAVE_RXACK_bm)) {

		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    453a:	22 e0       	ldi	r18, 0x02	; 2
    453c:	21 87       	std	Z+9, r18	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    453e:	61 e0       	ldi	r22, 0x01	; 1
    4540:	6b df       	rcall	.-298    	; 0x4418 <TWI_SlaveTransactionFinished>
    4542:	21 c0       	rjmp	.+66     	; 0x4586 <TWI_SlaveWriteHandler+0x68>
	}
	/* If ACK, master expects more data. */
	else {
		if (twi->bytesSent < TWIS_SEND_BUFFER_SIZE) {
    4544:	fc 01       	movw	r30, r24
    4546:	e2 5b       	subi	r30, 0xB2	; 178
    4548:	ff 4f       	sbci	r31, 0xFF	; 255
    454a:	20 81       	ld	r18, Z
    454c:	21 11       	cpse	r18, r1
    454e:	14 c0       	rjmp	.+40     	; 0x4578 <TWI_SlaveWriteHandler+0x5a>
			uint8_t data = twi->sendData[twi->bytesSent];
    4550:	20 81       	ld	r18, Z
    4552:	dc 01       	movw	r26, r24
    4554:	a2 0f       	add	r26, r18
    4556:	b1 1d       	adc	r27, r1
    4558:	a4 5b       	subi	r26, 0xB4	; 180
    455a:	bf 4f       	sbci	r27, 0xFF	; 255
    455c:	2c 91       	ld	r18, X
			twi->interface->SLAVE.DATA = data;
    455e:	ec 01       	movw	r28, r24
    4560:	a8 81       	ld	r26, Y
    4562:	b9 81       	ldd	r27, Y+1	; 0x01
    4564:	1c 96       	adiw	r26, 0x0c	; 12
    4566:	2c 93       	st	X, r18
			twi->bytesSent++;
    4568:	20 81       	ld	r18, Z
    456a:	2f 5f       	subi	r18, 0xFF	; 255
    456c:	20 83       	st	Z, r18

			/* Send data, wait for data interrupt. */
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    456e:	e8 81       	ld	r30, Y
    4570:	f9 81       	ldd	r31, Y+1	; 0x01
    4572:	83 e0       	ldi	r24, 0x03	; 3
    4574:	81 87       	std	Z+9, r24	; 0x09
    4576:	07 c0       	rjmp	.+14     	; 0x4586 <TWI_SlaveWriteHandler+0x68>
		}
		/* If buffer overflow. */
		else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    4578:	dc 01       	movw	r26, r24
    457a:	ed 91       	ld	r30, X+
    457c:	fc 91       	ld	r31, X
    457e:	22 e0       	ldi	r18, 0x02	; 2
    4580:	21 87       	std	Z+9, r18	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    4582:	62 e0       	ldi	r22, 0x02	; 2
    4584:	49 df       	rcall	.-366    	; 0x4418 <TWI_SlaveTransactionFinished>
		}
	}
}
    4586:	df 91       	pop	r29
    4588:	cf 91       	pop	r28
    458a:	08 95       	ret

0000458c <TWI_SlaveDataHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveDataHandler(TWI_Slave_t *twi)
{
	if (twi->interface->SLAVE.STATUS & TWI_SLAVE_DIR_bm) {
    458c:	dc 01       	movw	r26, r24
    458e:	ed 91       	ld	r30, X+
    4590:	fc 91       	ld	r31, X
    4592:	22 85       	ldd	r18, Z+10	; 0x0a
    4594:	21 ff       	sbrs	r18, 1
    4596:	02 c0       	rjmp	.+4      	; 0x459c <TWI_SlaveDataHandler+0x10>
		TWI_SlaveWriteHandler(twi);
    4598:	c2 cf       	rjmp	.-124    	; 0x451e <TWI_SlaveWriteHandler>
    459a:	08 95       	ret
	} else {
		TWI_SlaveReadHandler(twi);
    459c:	86 cf       	rjmp	.-244    	; 0x44aa <TWI_SlaveReadHandler>
    459e:	08 95       	ret

000045a0 <TWI_SlaveInterruptHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveInterruptHandler(TWI_Slave_t *twi)
{
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    45a0:	dc 01       	movw	r26, r24
    45a2:	ed 91       	ld	r30, X+
    45a4:	fc 91       	ld	r31, X
    45a6:	22 85       	ldd	r18, Z+10	; 0x0a

	/* If bus error. */
	if (currentStatus & TWI_SLAVE_BUSERR_bm) {
    45a8:	22 ff       	sbrs	r18, 2
    45aa:	0c c0       	rjmp	.+24     	; 0x45c4 <TWI_SlaveInterruptHandler+0x24>
		twi->bytesReceived = 0;
    45ac:	fc 01       	movw	r30, r24
    45ae:	e3 5b       	subi	r30, 0xB3	; 179
    45b0:	ff 4f       	sbci	r31, 0xFF	; 255
    45b2:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    45b4:	31 96       	adiw	r30, 0x01	; 1
    45b6:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_BUS_ERROR;
    45b8:	32 96       	adiw	r30, 0x02	; 2
    45ba:	24 e0       	ldi	r18, 0x04	; 4
    45bc:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    45be:	31 97       	sbiw	r30, 0x01	; 1
    45c0:	10 82       	st	Z, r1
    45c2:	08 95       	ret
	}

	/* If transmit collision. */
	else if (currentStatus & TWI_SLAVE_COLL_bm) {
    45c4:	23 ff       	sbrs	r18, 3
    45c6:	0c c0       	rjmp	.+24     	; 0x45e0 <TWI_SlaveInterruptHandler+0x40>
		twi->bytesReceived = 0;
    45c8:	fc 01       	movw	r30, r24
    45ca:	e3 5b       	subi	r30, 0xB3	; 179
    45cc:	ff 4f       	sbci	r31, 0xFF	; 255
    45ce:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    45d0:	31 96       	adiw	r30, 0x01	; 1
    45d2:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_TRANSMIT_COLLISION;
    45d4:	32 96       	adiw	r30, 0x02	; 2
    45d6:	23 e0       	ldi	r18, 0x03	; 3
    45d8:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    45da:	31 97       	sbiw	r30, 0x01	; 1
    45dc:	10 82       	st	Z, r1
    45de:	08 95       	ret
	}

	/* If address match. */
	else if ((currentStatus & TWI_SLAVE_APIF_bm) &&
    45e0:	42 2f       	mov	r20, r18
    45e2:	40 74       	andi	r20, 0x40	; 64
    45e4:	32 2f       	mov	r19, r18
    45e6:	31 74       	andi	r19, 0x41	; 65
    45e8:	31 34       	cpi	r19, 0x41	; 65
    45ea:	11 f4       	brne	.+4      	; 0x45f0 <TWI_SlaveInterruptHandler+0x50>
	        (currentStatus & TWI_SLAVE_AP_bm)) {

		TWI_SlaveAddressMatchHandler(twi);
    45ec:	22 cf       	rjmp	.-444    	; 0x4432 <TWI_SlaveAddressMatchHandler>
    45ee:	08 95       	ret
	}

	/* If stop (only enabled through slave read transaction). */
	else if (currentStatus & TWI_SLAVE_APIF_bm) {
    45f0:	44 23       	and	r20, r20
    45f2:	11 f0       	breq	.+4      	; 0x45f8 <TWI_SlaveInterruptHandler+0x58>
		TWI_SlaveStopHandler(twi);
    45f4:	4b cf       	rjmp	.-362    	; 0x448c <TWI_SlaveStopHandler>
    45f6:	08 95       	ret
	}

	/* If data interrupt. */
	else if (currentStatus & TWI_SLAVE_DIF_bm) {
    45f8:	22 23       	and	r18, r18
    45fa:	14 f4       	brge	.+4      	; 0x4600 <TWI_SlaveInterruptHandler+0x60>
		TWI_SlaveDataHandler(twi);
    45fc:	c7 cf       	rjmp	.-114    	; 0x458c <TWI_SlaveDataHandler>
    45fe:	08 95       	ret
	}

	/* If unexpected state. */
	else {
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_FAIL);
    4600:	65 e0       	ldi	r22, 0x05	; 5
    4602:	0a cf       	rjmp	.-492    	; 0x4418 <TWI_SlaveTransactionFinished>
    4604:	08 95       	ret

00004606 <__vector_25>:
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
ISR(USARTF0_DRE_vect){USART_DataRegEmpty(usartBufferF);}
    4606:	1f 92       	push	r1
    4608:	0f 92       	push	r0
    460a:	0f b6       	in	r0, 0x3f	; 63
    460c:	0f 92       	push	r0
    460e:	11 24       	eor	r1, r1
    4610:	08 b6       	in	r0, 0x38	; 56
    4612:	0f 92       	push	r0
    4614:	18 be       	out	0x38, r1	; 56
    4616:	09 b6       	in	r0, 0x39	; 57
    4618:	0f 92       	push	r0
    461a:	19 be       	out	0x39, r1	; 57
    461c:	0a b6       	in	r0, 0x3a	; 58
    461e:	0f 92       	push	r0
    4620:	1a be       	out	0x3a, r1	; 58
    4622:	0b b6       	in	r0, 0x3b	; 59
    4624:	0f 92       	push	r0
    4626:	1b be       	out	0x3b, r1	; 59
    4628:	2f 93       	push	r18
    462a:	3f 93       	push	r19
    462c:	4f 93       	push	r20
    462e:	5f 93       	push	r21
    4630:	6f 93       	push	r22
    4632:	7f 93       	push	r23
    4634:	8f 93       	push	r24
    4636:	9f 93       	push	r25
    4638:	af 93       	push	r26
    463a:	bf 93       	push	r27
    463c:	ef 93       	push	r30
    463e:	ff 93       	push	r31
    4640:	cf 93       	push	r28
    4642:	df 93       	push	r29
    4644:	1f 92       	push	r1
    4646:	1f 92       	push	r1
    4648:	cd b7       	in	r28, 0x3d	; 61
    464a:	de b7       	in	r29, 0x3e	; 62
    464c:	e0 91 54 3f 	lds	r30, 0x3F54
    4650:	f0 91 55 3f 	lds	r31, 0x3F55
    4654:	1a 82       	std	Y+2, r1	; 0x02
    4656:	a0 81       	ld	r26, Z
    4658:	b1 81       	ldd	r27, Z+1	; 0x01
    465a:	8c 91       	ld	r24, X
    465c:	89 83       	std	Y+1, r24	; 0x01
    465e:	20 e0       	ldi	r18, 0x00	; 0
    4660:	ae 01       	movw	r20, r28
    4662:	4e 5f       	subi	r20, 0xFE	; 254
    4664:	5f 4f       	sbci	r21, 0xFF	; 255
    4666:	be 01       	movw	r22, r28
    4668:	6f 5f       	subi	r22, 0xFF	; 255
    466a:	7f 4f       	sbci	r23, 0xFF	; 255
    466c:	83 81       	ldd	r24, Z+3	; 0x03
    466e:	94 81       	ldd	r25, Z+4	; 0x04
    4670:	0e 94 b6 08 	call	0x116c	; 0x116c <xQueueGenericSendFromISR>
    4674:	8a 81       	ldd	r24, Y+2	; 0x02
    4676:	81 11       	cpse	r24, r1
    4678:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vPortYield>
    467c:	0f 90       	pop	r0
    467e:	0f 90       	pop	r0
    4680:	df 91       	pop	r29
    4682:	cf 91       	pop	r28
    4684:	ff 91       	pop	r31
    4686:	ef 91       	pop	r30
    4688:	bf 91       	pop	r27
    468a:	af 91       	pop	r26
    468c:	9f 91       	pop	r25
    468e:	8f 91       	pop	r24
    4690:	7f 91       	pop	r23
    4692:	6f 91       	pop	r22
    4694:	5f 91       	pop	r21
    4696:	4f 91       	pop	r20
    4698:	3f 91       	pop	r19
    469a:	2f 91       	pop	r18
    469c:	0f 90       	pop	r0
    469e:	0b be       	out	0x3b, r0	; 59
    46a0:	0f 90       	pop	r0
    46a2:	0a be       	out	0x3a, r0	; 58
    46a4:	0f 90       	pop	r0
    46a6:	09 be       	out	0x39, r0	; 57
    46a8:	0f 90       	pop	r0
    46aa:	08 be       	out	0x38, r0	; 56
    46ac:	0f 90       	pop	r0
    46ae:	0f be       	out	0x3f, r0	; 63
    46b0:	0f 90       	pop	r0
    46b2:	1f 90       	pop	r1
    46b4:	18 95       	reti

000046b6 <__vector_88>:
    46b6:	1f 92       	push	r1
    46b8:	0f 92       	push	r0
    46ba:	0f b6       	in	r0, 0x3f	; 63
    46bc:	0f 92       	push	r0
    46be:	11 24       	eor	r1, r1
    46c0:	08 b6       	in	r0, 0x38	; 56
    46c2:	0f 92       	push	r0
    46c4:	18 be       	out	0x38, r1	; 56
    46c6:	09 b6       	in	r0, 0x39	; 57
    46c8:	0f 92       	push	r0
    46ca:	19 be       	out	0x39, r1	; 57
    46cc:	0a b6       	in	r0, 0x3a	; 58
    46ce:	0f 92       	push	r0
    46d0:	1a be       	out	0x3a, r1	; 58
    46d2:	0b b6       	in	r0, 0x3b	; 59
    46d4:	0f 92       	push	r0
    46d6:	1b be       	out	0x3b, r1	; 59
    46d8:	2f 93       	push	r18
    46da:	3f 93       	push	r19
    46dc:	4f 93       	push	r20
    46de:	5f 93       	push	r21
    46e0:	6f 93       	push	r22
    46e2:	7f 93       	push	r23
    46e4:	8f 93       	push	r24
    46e6:	9f 93       	push	r25
    46e8:	af 93       	push	r26
    46ea:	bf 93       	push	r27
    46ec:	ef 93       	push	r30
    46ee:	ff 93       	push	r31
    46f0:	cf 93       	push	r28
    46f2:	df 93       	push	r29
    46f4:	1f 92       	push	r1
    46f6:	1f 92       	push	r1
    46f8:	cd b7       	in	r28, 0x3d	; 61
    46fa:	de b7       	in	r29, 0x3e	; 62
    46fc:	e0 91 52 3f 	lds	r30, 0x3F52
    4700:	f0 91 53 3f 	lds	r31, 0x3F53
    4704:	1a 82       	std	Y+2, r1	; 0x02
    4706:	a0 81       	ld	r26, Z
    4708:	b1 81       	ldd	r27, Z+1	; 0x01
    470a:	8c 91       	ld	r24, X
    470c:	89 83       	std	Y+1, r24	; 0x01
    470e:	20 e0       	ldi	r18, 0x00	; 0
    4710:	ae 01       	movw	r20, r28
    4712:	4e 5f       	subi	r20, 0xFE	; 254
    4714:	5f 4f       	sbci	r21, 0xFF	; 255
    4716:	be 01       	movw	r22, r28
    4718:	6f 5f       	subi	r22, 0xFF	; 255
    471a:	7f 4f       	sbci	r23, 0xFF	; 255
    471c:	83 81       	ldd	r24, Z+3	; 0x03
    471e:	94 81       	ldd	r25, Z+4	; 0x04
    4720:	0e 94 b6 08 	call	0x116c	; 0x116c <xQueueGenericSendFromISR>
    4724:	8a 81       	ldd	r24, Y+2	; 0x02
    4726:	81 11       	cpse	r24, r1
    4728:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vPortYield>
    472c:	0f 90       	pop	r0
    472e:	0f 90       	pop	r0
    4730:	df 91       	pop	r29
    4732:	cf 91       	pop	r28
    4734:	ff 91       	pop	r31
    4736:	ef 91       	pop	r30
    4738:	bf 91       	pop	r27
    473a:	af 91       	pop	r26
    473c:	9f 91       	pop	r25
    473e:	8f 91       	pop	r24
    4740:	7f 91       	pop	r23
    4742:	6f 91       	pop	r22
    4744:	5f 91       	pop	r21
    4746:	4f 91       	pop	r20
    4748:	3f 91       	pop	r19
    474a:	2f 91       	pop	r18
    474c:	0f 90       	pop	r0
    474e:	0b be       	out	0x3b, r0	; 59
    4750:	0f 90       	pop	r0
    4752:	0a be       	out	0x3a, r0	; 58
    4754:	0f 90       	pop	r0
    4756:	09 be       	out	0x39, r0	; 57
    4758:	0f 90       	pop	r0
    475a:	08 be       	out	0x38, r0	; 56
    475c:	0f 90       	pop	r0
    475e:	0f be       	out	0x3f, r0	; 63
    4760:	0f 90       	pop	r0
    4762:	1f 90       	pop	r1
    4764:	18 95       	reti

00004766 <__vector_58>:
    4766:	1f 92       	push	r1
    4768:	0f 92       	push	r0
    476a:	0f b6       	in	r0, 0x3f	; 63
    476c:	0f 92       	push	r0
    476e:	11 24       	eor	r1, r1
    4770:	08 b6       	in	r0, 0x38	; 56
    4772:	0f 92       	push	r0
    4774:	18 be       	out	0x38, r1	; 56
    4776:	09 b6       	in	r0, 0x39	; 57
    4778:	0f 92       	push	r0
    477a:	19 be       	out	0x39, r1	; 57
    477c:	0a b6       	in	r0, 0x3a	; 58
    477e:	0f 92       	push	r0
    4780:	1a be       	out	0x3a, r1	; 58
    4782:	0b b6       	in	r0, 0x3b	; 59
    4784:	0f 92       	push	r0
    4786:	1b be       	out	0x3b, r1	; 59
    4788:	2f 93       	push	r18
    478a:	3f 93       	push	r19
    478c:	4f 93       	push	r20
    478e:	5f 93       	push	r21
    4790:	6f 93       	push	r22
    4792:	7f 93       	push	r23
    4794:	8f 93       	push	r24
    4796:	9f 93       	push	r25
    4798:	af 93       	push	r26
    479a:	bf 93       	push	r27
    479c:	ef 93       	push	r30
    479e:	ff 93       	push	r31
    47a0:	cf 93       	push	r28
    47a2:	df 93       	push	r29
    47a4:	1f 92       	push	r1
    47a6:	1f 92       	push	r1
    47a8:	cd b7       	in	r28, 0x3d	; 61
    47aa:	de b7       	in	r29, 0x3e	; 62
    47ac:	e0 91 50 3f 	lds	r30, 0x3F50
    47b0:	f0 91 51 3f 	lds	r31, 0x3F51
    47b4:	1a 82       	std	Y+2, r1	; 0x02
    47b6:	a0 81       	ld	r26, Z
    47b8:	b1 81       	ldd	r27, Z+1	; 0x01
    47ba:	8c 91       	ld	r24, X
    47bc:	89 83       	std	Y+1, r24	; 0x01
    47be:	20 e0       	ldi	r18, 0x00	; 0
    47c0:	ae 01       	movw	r20, r28
    47c2:	4e 5f       	subi	r20, 0xFE	; 254
    47c4:	5f 4f       	sbci	r21, 0xFF	; 255
    47c6:	be 01       	movw	r22, r28
    47c8:	6f 5f       	subi	r22, 0xFF	; 255
    47ca:	7f 4f       	sbci	r23, 0xFF	; 255
    47cc:	83 81       	ldd	r24, Z+3	; 0x03
    47ce:	94 81       	ldd	r25, Z+4	; 0x04
    47d0:	0e 94 b6 08 	call	0x116c	; 0x116c <xQueueGenericSendFromISR>
    47d4:	8a 81       	ldd	r24, Y+2	; 0x02
    47d6:	81 11       	cpse	r24, r1
    47d8:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vPortYield>
    47dc:	0f 90       	pop	r0
    47de:	0f 90       	pop	r0
    47e0:	df 91       	pop	r29
    47e2:	cf 91       	pop	r28
    47e4:	ff 91       	pop	r31
    47e6:	ef 91       	pop	r30
    47e8:	bf 91       	pop	r27
    47ea:	af 91       	pop	r26
    47ec:	9f 91       	pop	r25
    47ee:	8f 91       	pop	r24
    47f0:	7f 91       	pop	r23
    47f2:	6f 91       	pop	r22
    47f4:	5f 91       	pop	r21
    47f6:	4f 91       	pop	r20
    47f8:	3f 91       	pop	r19
    47fa:	2f 91       	pop	r18
    47fc:	0f 90       	pop	r0
    47fe:	0b be       	out	0x3b, r0	; 59
    4800:	0f 90       	pop	r0
    4802:	0a be       	out	0x3a, r0	; 58
    4804:	0f 90       	pop	r0
    4806:	09 be       	out	0x39, r0	; 57
    4808:	0f 90       	pop	r0
    480a:	08 be       	out	0x38, r0	; 56
    480c:	0f 90       	pop	r0
    480e:	0f be       	out	0x3f, r0	; 63
    4810:	0f 90       	pop	r0
    4812:	1f 90       	pop	r1
    4814:	18 95       	reti

00004816 <__vector_26>:
    4816:	1f 92       	push	r1
    4818:	0f 92       	push	r0
    481a:	0f b6       	in	r0, 0x3f	; 63
    481c:	0f 92       	push	r0
    481e:	11 24       	eor	r1, r1
    4820:	08 b6       	in	r0, 0x38	; 56
    4822:	0f 92       	push	r0
    4824:	18 be       	out	0x38, r1	; 56
    4826:	09 b6       	in	r0, 0x39	; 57
    4828:	0f 92       	push	r0
    482a:	19 be       	out	0x39, r1	; 57
    482c:	0a b6       	in	r0, 0x3a	; 58
    482e:	0f 92       	push	r0
    4830:	1a be       	out	0x3a, r1	; 58
    4832:	0b b6       	in	r0, 0x3b	; 59
    4834:	0f 92       	push	r0
    4836:	1b be       	out	0x3b, r1	; 59
    4838:	0f 93       	push	r16
    483a:	1f 93       	push	r17
    483c:	2f 93       	push	r18
    483e:	3f 93       	push	r19
    4840:	4f 93       	push	r20
    4842:	5f 93       	push	r21
    4844:	6f 93       	push	r22
    4846:	7f 93       	push	r23
    4848:	8f 93       	push	r24
    484a:	9f 93       	push	r25
    484c:	af 93       	push	r26
    484e:	bf 93       	push	r27
    4850:	ef 93       	push	r30
    4852:	ff 93       	push	r31
    4854:	cf 93       	push	r28
    4856:	df 93       	push	r29
    4858:	1f 92       	push	r1
    485a:	1f 92       	push	r1
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	00 91 54 3f 	lds	r16, 0x3F54
    4864:	10 91 55 3f 	lds	r17, 0x3F55
    4868:	ae 01       	movw	r20, r28
    486a:	4f 5f       	subi	r20, 0xFF	; 255
    486c:	5f 4f       	sbci	r21, 0xFF	; 255
    486e:	be 01       	movw	r22, r28
    4870:	6e 5f       	subi	r22, 0xFE	; 254
    4872:	7f 4f       	sbci	r23, 0xFF	; 255
    4874:	d8 01       	movw	r26, r16
    4876:	15 96       	adiw	r26, 0x05	; 5
    4878:	8d 91       	ld	r24, X+
    487a:	9c 91       	ld	r25, X
    487c:	16 97       	sbiw	r26, 0x06	; 6
    487e:	0e 94 8e 09 	call	0x131c	; 0x131c <xQueueReceiveFromISR>
    4882:	81 30       	cpi	r24, 0x01	; 1
    4884:	31 f4       	brne	.+12     	; 0x4892 <__vector_26+0x7c>
    4886:	d8 01       	movw	r26, r16
    4888:	ed 91       	ld	r30, X+
    488a:	fc 91       	ld	r31, X
    488c:	8a 81       	ldd	r24, Y+2	; 0x02
    488e:	80 83       	st	Z, r24
    4890:	06 c0       	rjmp	.+12     	; 0x489e <__vector_26+0x88>
    4892:	d8 01       	movw	r26, r16
    4894:	ed 91       	ld	r30, X+
    4896:	fc 91       	ld	r31, X
    4898:	83 81       	ldd	r24, Z+3	; 0x03
    489a:	8c 7f       	andi	r24, 0xFC	; 252
    489c:	83 83       	std	Z+3, r24	; 0x03
    489e:	0f 90       	pop	r0
    48a0:	0f 90       	pop	r0
    48a2:	df 91       	pop	r29
    48a4:	cf 91       	pop	r28
    48a6:	ff 91       	pop	r31
    48a8:	ef 91       	pop	r30
    48aa:	bf 91       	pop	r27
    48ac:	af 91       	pop	r26
    48ae:	9f 91       	pop	r25
    48b0:	8f 91       	pop	r24
    48b2:	7f 91       	pop	r23
    48b4:	6f 91       	pop	r22
    48b6:	5f 91       	pop	r21
    48b8:	4f 91       	pop	r20
    48ba:	3f 91       	pop	r19
    48bc:	2f 91       	pop	r18
    48be:	1f 91       	pop	r17
    48c0:	0f 91       	pop	r16
    48c2:	0f 90       	pop	r0
    48c4:	0b be       	out	0x3b, r0	; 59
    48c6:	0f 90       	pop	r0
    48c8:	0a be       	out	0x3a, r0	; 58
    48ca:	0f 90       	pop	r0
    48cc:	09 be       	out	0x39, r0	; 57
    48ce:	0f 90       	pop	r0
    48d0:	08 be       	out	0x38, r0	; 56
    48d2:	0f 90       	pop	r0
    48d4:	0f be       	out	0x3f, r0	; 63
    48d6:	0f 90       	pop	r0
    48d8:	1f 90       	pop	r1
    48da:	18 95       	reti

000048dc <__vector_89>:
    48dc:	1f 92       	push	r1
    48de:	0f 92       	push	r0
    48e0:	0f b6       	in	r0, 0x3f	; 63
    48e2:	0f 92       	push	r0
    48e4:	11 24       	eor	r1, r1
    48e6:	08 b6       	in	r0, 0x38	; 56
    48e8:	0f 92       	push	r0
    48ea:	18 be       	out	0x38, r1	; 56
    48ec:	09 b6       	in	r0, 0x39	; 57
    48ee:	0f 92       	push	r0
    48f0:	19 be       	out	0x39, r1	; 57
    48f2:	0a b6       	in	r0, 0x3a	; 58
    48f4:	0f 92       	push	r0
    48f6:	1a be       	out	0x3a, r1	; 58
    48f8:	0b b6       	in	r0, 0x3b	; 59
    48fa:	0f 92       	push	r0
    48fc:	1b be       	out	0x3b, r1	; 59
    48fe:	0f 93       	push	r16
    4900:	1f 93       	push	r17
    4902:	2f 93       	push	r18
    4904:	3f 93       	push	r19
    4906:	4f 93       	push	r20
    4908:	5f 93       	push	r21
    490a:	6f 93       	push	r22
    490c:	7f 93       	push	r23
    490e:	8f 93       	push	r24
    4910:	9f 93       	push	r25
    4912:	af 93       	push	r26
    4914:	bf 93       	push	r27
    4916:	ef 93       	push	r30
    4918:	ff 93       	push	r31
    491a:	cf 93       	push	r28
    491c:	df 93       	push	r29
    491e:	1f 92       	push	r1
    4920:	1f 92       	push	r1
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
    4926:	00 91 52 3f 	lds	r16, 0x3F52
    492a:	10 91 53 3f 	lds	r17, 0x3F53
    492e:	ae 01       	movw	r20, r28
    4930:	4f 5f       	subi	r20, 0xFF	; 255
    4932:	5f 4f       	sbci	r21, 0xFF	; 255
    4934:	be 01       	movw	r22, r28
    4936:	6e 5f       	subi	r22, 0xFE	; 254
    4938:	7f 4f       	sbci	r23, 0xFF	; 255
    493a:	d8 01       	movw	r26, r16
    493c:	15 96       	adiw	r26, 0x05	; 5
    493e:	8d 91       	ld	r24, X+
    4940:	9c 91       	ld	r25, X
    4942:	16 97       	sbiw	r26, 0x06	; 6
    4944:	0e 94 8e 09 	call	0x131c	; 0x131c <xQueueReceiveFromISR>
    4948:	81 30       	cpi	r24, 0x01	; 1
    494a:	31 f4       	brne	.+12     	; 0x4958 <__vector_89+0x7c>
    494c:	d8 01       	movw	r26, r16
    494e:	ed 91       	ld	r30, X+
    4950:	fc 91       	ld	r31, X
    4952:	8a 81       	ldd	r24, Y+2	; 0x02
    4954:	80 83       	st	Z, r24
    4956:	06 c0       	rjmp	.+12     	; 0x4964 <__vector_89+0x88>
    4958:	d8 01       	movw	r26, r16
    495a:	ed 91       	ld	r30, X+
    495c:	fc 91       	ld	r31, X
    495e:	83 81       	ldd	r24, Z+3	; 0x03
    4960:	8c 7f       	andi	r24, 0xFC	; 252
    4962:	83 83       	std	Z+3, r24	; 0x03
    4964:	0f 90       	pop	r0
    4966:	0f 90       	pop	r0
    4968:	df 91       	pop	r29
    496a:	cf 91       	pop	r28
    496c:	ff 91       	pop	r31
    496e:	ef 91       	pop	r30
    4970:	bf 91       	pop	r27
    4972:	af 91       	pop	r26
    4974:	9f 91       	pop	r25
    4976:	8f 91       	pop	r24
    4978:	7f 91       	pop	r23
    497a:	6f 91       	pop	r22
    497c:	5f 91       	pop	r21
    497e:	4f 91       	pop	r20
    4980:	3f 91       	pop	r19
    4982:	2f 91       	pop	r18
    4984:	1f 91       	pop	r17
    4986:	0f 91       	pop	r16
    4988:	0f 90       	pop	r0
    498a:	0b be       	out	0x3b, r0	; 59
    498c:	0f 90       	pop	r0
    498e:	0a be       	out	0x3a, r0	; 58
    4990:	0f 90       	pop	r0
    4992:	09 be       	out	0x39, r0	; 57
    4994:	0f 90       	pop	r0
    4996:	08 be       	out	0x38, r0	; 56
    4998:	0f 90       	pop	r0
    499a:	0f be       	out	0x3f, r0	; 63
    499c:	0f 90       	pop	r0
    499e:	1f 90       	pop	r1
    49a0:	18 95       	reti

000049a2 <__vector_59>:
    49a2:	1f 92       	push	r1
    49a4:	0f 92       	push	r0
    49a6:	0f b6       	in	r0, 0x3f	; 63
    49a8:	0f 92       	push	r0
    49aa:	11 24       	eor	r1, r1
    49ac:	08 b6       	in	r0, 0x38	; 56
    49ae:	0f 92       	push	r0
    49b0:	18 be       	out	0x38, r1	; 56
    49b2:	09 b6       	in	r0, 0x39	; 57
    49b4:	0f 92       	push	r0
    49b6:	19 be       	out	0x39, r1	; 57
    49b8:	0a b6       	in	r0, 0x3a	; 58
    49ba:	0f 92       	push	r0
    49bc:	1a be       	out	0x3a, r1	; 58
    49be:	0b b6       	in	r0, 0x3b	; 59
    49c0:	0f 92       	push	r0
    49c2:	1b be       	out	0x3b, r1	; 59
    49c4:	0f 93       	push	r16
    49c6:	1f 93       	push	r17
    49c8:	2f 93       	push	r18
    49ca:	3f 93       	push	r19
    49cc:	4f 93       	push	r20
    49ce:	5f 93       	push	r21
    49d0:	6f 93       	push	r22
    49d2:	7f 93       	push	r23
    49d4:	8f 93       	push	r24
    49d6:	9f 93       	push	r25
    49d8:	af 93       	push	r26
    49da:	bf 93       	push	r27
    49dc:	ef 93       	push	r30
    49de:	ff 93       	push	r31
    49e0:	cf 93       	push	r28
    49e2:	df 93       	push	r29
    49e4:	1f 92       	push	r1
    49e6:	1f 92       	push	r1
    49e8:	cd b7       	in	r28, 0x3d	; 61
    49ea:	de b7       	in	r29, 0x3e	; 62
    49ec:	00 91 50 3f 	lds	r16, 0x3F50
    49f0:	10 91 51 3f 	lds	r17, 0x3F51
    49f4:	ae 01       	movw	r20, r28
    49f6:	4f 5f       	subi	r20, 0xFF	; 255
    49f8:	5f 4f       	sbci	r21, 0xFF	; 255
    49fa:	be 01       	movw	r22, r28
    49fc:	6e 5f       	subi	r22, 0xFE	; 254
    49fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4a00:	d8 01       	movw	r26, r16
    4a02:	15 96       	adiw	r26, 0x05	; 5
    4a04:	8d 91       	ld	r24, X+
    4a06:	9c 91       	ld	r25, X
    4a08:	16 97       	sbiw	r26, 0x06	; 6
    4a0a:	0e 94 8e 09 	call	0x131c	; 0x131c <xQueueReceiveFromISR>
    4a0e:	81 30       	cpi	r24, 0x01	; 1
    4a10:	31 f4       	brne	.+12     	; 0x4a1e <__vector_59+0x7c>
    4a12:	d8 01       	movw	r26, r16
    4a14:	ed 91       	ld	r30, X+
    4a16:	fc 91       	ld	r31, X
    4a18:	8a 81       	ldd	r24, Y+2	; 0x02
    4a1a:	80 83       	st	Z, r24
    4a1c:	06 c0       	rjmp	.+12     	; 0x4a2a <__vector_59+0x88>
    4a1e:	d8 01       	movw	r26, r16
    4a20:	ed 91       	ld	r30, X+
    4a22:	fc 91       	ld	r31, X
    4a24:	83 81       	ldd	r24, Z+3	; 0x03
    4a26:	8c 7f       	andi	r24, 0xFC	; 252
    4a28:	83 83       	std	Z+3, r24	; 0x03
    4a2a:	0f 90       	pop	r0
    4a2c:	0f 90       	pop	r0
    4a2e:	df 91       	pop	r29
    4a30:	cf 91       	pop	r28
    4a32:	ff 91       	pop	r31
    4a34:	ef 91       	pop	r30
    4a36:	bf 91       	pop	r27
    4a38:	af 91       	pop	r26
    4a3a:	9f 91       	pop	r25
    4a3c:	8f 91       	pop	r24
    4a3e:	7f 91       	pop	r23
    4a40:	6f 91       	pop	r22
    4a42:	5f 91       	pop	r21
    4a44:	4f 91       	pop	r20
    4a46:	3f 91       	pop	r19
    4a48:	2f 91       	pop	r18
    4a4a:	1f 91       	pop	r17
    4a4c:	0f 91       	pop	r16
    4a4e:	0f 90       	pop	r0
    4a50:	0b be       	out	0x3b, r0	; 59
    4a52:	0f 90       	pop	r0
    4a54:	0a be       	out	0x3a, r0	; 58
    4a56:	0f 90       	pop	r0
    4a58:	09 be       	out	0x39, r0	; 57
    4a5a:	0f 90       	pop	r0
    4a5c:	08 be       	out	0x38, r0	; 56
    4a5e:	0f 90       	pop	r0
    4a60:	0f be       	out	0x3f, r0	; 63
    4a62:	0f 90       	pop	r0
    4a64:	1f 90       	pop	r1
    4a66:	18 95       	reti

00004a68 <usartBufferInitialize>:
 *
 *  \param usart                Pointer to the USART module to use.
 *  \return usart_buffer        The USART_buffer_struct_t instance which can be used to read and write.
 */
UsartBuffer * usartBufferInitialize(USART_t * usart, Baudrate_enum baudrate ,char bufferSize)
{
    4a68:	cf 92       	push	r12
    4a6a:	df 92       	push	r13
    4a6c:	ef 92       	push	r14
    4a6e:	ff 92       	push	r15
    4a70:	0f 93       	push	r16
    4a72:	1f 93       	push	r17
    4a74:	cf 93       	push	r28
    4a76:	df 93       	push	r29
    4a78:	6c 01       	movw	r12, r24
    4a7a:	16 2f       	mov	r17, r22
    4a7c:	f4 2e       	mov	r15, r20
	USART_DREINTLVL_t dreIntLevel = USART_DREINTLVL_LO_gc;
	PORT_t * port;
	UsartBuffer * usartBuffer;
	//switch by pointer to usart structure, which will be used. Usually it is not a good idea to
	//switch by pointer, but in our case pointers are defined by hardware
	switch ((int)usart) {
    4a7e:	80 ea       	ldi	r24, 0xA0	; 160
    4a80:	c8 16       	cp	r12, r24
    4a82:	89 e0       	ldi	r24, 0x09	; 9
    4a84:	d8 06       	cpc	r13, r24
    4a86:	b1 f0       	breq	.+44     	; 0x4ab4 <usartBufferInitialize+0x4c>
    4a88:	80 ea       	ldi	r24, 0xA0	; 160
    4a8a:	c8 16       	cp	r12, r24
    4a8c:	8a e0       	ldi	r24, 0x0A	; 10
    4a8e:	d8 06       	cpc	r13, r24
    4a90:	e9 f0       	breq	.+58     	; 0x4acc <usartBufferInitialize+0x64>
    4a92:	80 ea       	ldi	r24, 0xA0	; 160
    4a94:	c8 16       	cp	r12, r24
    4a96:	88 e0       	ldi	r24, 0x08	; 8
    4a98:	d8 06       	cpc	r13, r24
    4a9a:	19 f5       	brne	.+70     	; 0x4ae2 <usartBufferInitialize+0x7a>
		case (int)&USARTC0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    4a9c:	87 e0       	ldi	r24, 0x07	; 7
    4a9e:	90 e0       	ldi	r25, 0x00	; 0
    4aa0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <pvPortMalloc>
    4aa4:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferC, which is use to handle interrupts
			usartBufferC = usartBuffer;
    4aa6:	80 93 54 3f 	sts	0x3F54, r24
    4aaa:	90 93 55 3f 	sts	0x3F55, r25
			//Since usart is on the port C, we will need to use PORTC
			port = &PORTC;
    4aae:	e0 e4       	ldi	r30, 0x40	; 64
    4ab0:	f6 e0       	ldi	r31, 0x06	; 6
			break;
    4ab2:	17 c0       	rjmp	.+46     	; 0x4ae2 <usartBufferInitialize+0x7a>
		case (int)&USARTD0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    4ab4:	87 e0       	ldi	r24, 0x07	; 7
    4ab6:	90 e0       	ldi	r25, 0x00	; 0
    4ab8:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <pvPortMalloc>
    4abc:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferD, which is use to handle interrupts
			usartBufferD = usartBuffer;
    4abe:	80 93 52 3f 	sts	0x3F52, r24
    4ac2:	90 93 53 3f 	sts	0x3F53, r25
			//Since usart is on the port D, we will need to use PORTD
			port = &PORTD;
    4ac6:	e0 e6       	ldi	r30, 0x60	; 96
    4ac8:	f6 e0       	ldi	r31, 0x06	; 6
			break;
    4aca:	0b c0       	rjmp	.+22     	; 0x4ae2 <usartBufferInitialize+0x7a>
		case (int)&USARTE0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    4acc:	87 e0       	ldi	r24, 0x07	; 7
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <pvPortMalloc>
    4ad4:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferE, which is use to handle interrupts
			usartBufferE = usartBuffer;
    4ad6:	80 93 50 3f 	sts	0x3F50, r24
    4ada:	90 93 51 3f 	sts	0x3F51, r25
			//Since usart is on the port E, we will need to use PORTE
			port = &PORTE;
    4ade:	e0 e8       	ldi	r30, 0x80	; 128
    4ae0:	f6 e0       	ldi	r31, 0x06	; 6
			//use default, TODO: report error here with LED
			break;
	}

	/* (TX0) as output. */
	port->DIRSET = PIN3_bm;
    4ae2:	88 e0       	ldi	r24, 0x08	; 8
    4ae4:	81 83       	std	Z+1, r24	; 0x01
	/* (RX0) as input. */
	port->DIRCLR = PIN2_bm;
    4ae6:	84 e0       	ldi	r24, 0x04	; 4
    4ae8:	82 83       	std	Z+2, r24	; 0x02
	//totempole and pullup
	PORT_ConfigurePins( port,PIN3_bm,false,false,PORT_OPC_PULLUP_gc,PORT_ISC_BOTHEDGES_gc );
    4aea:	e1 2c       	mov	r14, r1
    4aec:	08 e1       	ldi	r16, 0x18	; 24
    4aee:	20 e0       	ldi	r18, 0x00	; 0
    4af0:	40 e0       	ldi	r20, 0x00	; 0
    4af2:	68 e0       	ldi	r22, 0x08	; 8
    4af4:	cf 01       	movw	r24, r30
    4af6:	1d db       	rcall	.-2502   	; 0x4132 <PORT_ConfigurePins>
	/* Initialize buffers. Create a queue (allocate memory) and store queue handle in usart_struct
	 * On XMEGA port create all queues before vStartTaskScheduler() to ensure that heap size is enough */
	/* Store pointer to USART module */
	usartBuffer->usart = usart;
    4af8:	c8 82       	st	Y, r12
    4afa:	d9 82       	std	Y+1, r13	; 0x01
	/*Store DRE level so we will know which level to enable when we put data and want it to be sent. */
	usartBuffer->dreIntLevel = dreIntLevel;
    4afc:	81 e0       	ldi	r24, 0x01	; 1
    4afe:	8a 83       	std	Y+2, r24	; 0x02
	/* \brief  Receive buffer size: 2,4,8,16,32,64,128 bytes. */
	usartBuffer->xQueueRX = xQueueCreate(bufferSize,sizeof(char));
    4b00:	61 e0       	ldi	r22, 0x01	; 1
    4b02:	8f 2d       	mov	r24, r15
    4b04:	0e 94 ba 07 	call	0xf74	; 0xf74 <xQueueCreate>
    4b08:	8b 83       	std	Y+3, r24	; 0x03
    4b0a:	9c 83       	std	Y+4, r25	; 0x04
	usartBuffer->xQueueTX = xQueueCreate(bufferSize,sizeof(char));
    4b0c:	61 e0       	ldi	r22, 0x01	; 1
    4b0e:	8f 2d       	mov	r24, r15
    4b10:	0e 94 ba 07 	call	0xf74	; 0xf74 <xQueueCreate>
    4b14:	8d 83       	std	Y+5, r24	; 0x05
    4b16:	9e 83       	std	Y+6, r25	; 0x06

	/* USARTD0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(usartBuffer->usart, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, true);
    4b18:	e8 81       	ld	r30, Y
    4b1a:	f9 81       	ldd	r31, Y+1	; 0x01
    4b1c:	8b e0       	ldi	r24, 0x0B	; 11
    4b1e:	85 83       	std	Z+5, r24	; 0x05
	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(usartBuffer->usart, USART_RXCINTLVL_LO_gc);
    4b20:	e8 81       	ld	r30, Y
    4b22:	f9 81       	ldd	r31, Y+1	; 0x01
    4b24:	83 81       	ldd	r24, Z+3	; 0x03
    4b26:	8f 7c       	andi	r24, 0xCF	; 207
    4b28:	80 61       	ori	r24, 0x10	; 16
    4b2a:	83 83       	std	Z+3, r24	; 0x03

	//http://prototalk.net/forums/showthread.php?t=188
	switch (baudrate) {
    4b2c:	13 30       	cpi	r17, 0x03	; 3
    4b2e:	e1 f0       	breq	.+56     	; 0x4b68 <usartBufferInitialize+0x100>
    4b30:	28 f4       	brcc	.+10     	; 0x4b3c <usartBufferInitialize+0xd4>
    4b32:	11 30       	cpi	r17, 0x01	; 1
    4b34:	59 f1       	breq	.+86     	; 0x4b8c <usartBufferInitialize+0x124>
    4b36:	12 30       	cpi	r17, 0x02	; 2
    4b38:	01 f1       	breq	.+64     	; 0x4b7a <usartBufferInitialize+0x112>
    4b3a:	31 c0       	rjmp	.+98     	; 0x4b9e <usartBufferInitialize+0x136>
    4b3c:	14 30       	cpi	r17, 0x04	; 4
    4b3e:	59 f0       	breq	.+22     	; 0x4b56 <usartBufferInitialize+0xee>
    4b40:	15 30       	cpi	r17, 0x05	; 5
    4b42:	69 f5       	brne	.+90     	; 0x4b9e <usartBufferInitialize+0x136>
			case BAUD115200:
			USART_Baudrate_Set(usartBuffer->usart, 2094 , -7);
    4b44:	e8 81       	ld	r30, Y
    4b46:	f9 81       	ldd	r31, Y+1	; 0x01
    4b48:	8e e2       	ldi	r24, 0x2E	; 46
    4b4a:	86 83       	std	Z+6, r24	; 0x06
    4b4c:	e8 81       	ld	r30, Y
    4b4e:	f9 81       	ldd	r31, Y+1	; 0x01
    4b50:	88 e9       	ldi	r24, 0x98	; 152
    4b52:	87 83       	std	Z+7, r24	; 0x07
		break;
    4b54:	2c c0       	rjmp	.+88     	; 0x4bae <usartBufferInitialize+0x146>
			case BAUD57600:
			USART_Baudrate_Set(usartBuffer->usart, 2158 , -6);
    4b56:	e8 81       	ld	r30, Y
    4b58:	f9 81       	ldd	r31, Y+1	; 0x01
    4b5a:	8e e6       	ldi	r24, 0x6E	; 110
    4b5c:	86 83       	std	Z+6, r24	; 0x06
    4b5e:	e8 81       	ld	r30, Y
    4b60:	f9 81       	ldd	r31, Y+1	; 0x01
    4b62:	88 ea       	ldi	r24, 0xA8	; 168
    4b64:	87 83       	std	Z+7, r24	; 0x07
		break;
    4b66:	23 c0       	rjmp	.+70     	; 0x4bae <usartBufferInitialize+0x146>
			case BAUD38400:
			USART_Baudrate_Set(usartBuffer->usart, 3269 , -6);
    4b68:	e8 81       	ld	r30, Y
    4b6a:	f9 81       	ldd	r31, Y+1	; 0x01
    4b6c:	85 ec       	ldi	r24, 0xC5	; 197
    4b6e:	86 83       	std	Z+6, r24	; 0x06
    4b70:	e8 81       	ld	r30, Y
    4b72:	f9 81       	ldd	r31, Y+1	; 0x01
    4b74:	8c ea       	ldi	r24, 0xAC	; 172
    4b76:	87 83       	std	Z+7, r24	; 0x07
		break;
    4b78:	1a c0       	rjmp	.+52     	; 0x4bae <usartBufferInitialize+0x146>
		case BAUD19200:
			USART_Baudrate_Set(usartBuffer->usart, 3301 , -5);
    4b7a:	e8 81       	ld	r30, Y
    4b7c:	f9 81       	ldd	r31, Y+1	; 0x01
    4b7e:	85 ee       	ldi	r24, 0xE5	; 229
    4b80:	86 83       	std	Z+6, r24	; 0x06
    4b82:	e8 81       	ld	r30, Y
    4b84:	f9 81       	ldd	r31, Y+1	; 0x01
    4b86:	8c eb       	ldi	r24, 0xBC	; 188
    4b88:	87 83       	std	Z+7, r24	; 0x07
			break;
    4b8a:	11 c0       	rjmp	.+34     	; 0x4bae <usartBufferInitialize+0x146>
		case BAUD9600:
			USART_Baudrate_Set(usartBuffer->usart, 3317 , -4);
    4b8c:	e8 81       	ld	r30, Y
    4b8e:	f9 81       	ldd	r31, Y+1	; 0x01
    4b90:	85 ef       	ldi	r24, 0xF5	; 245
    4b92:	86 83       	std	Z+6, r24	; 0x06
    4b94:	e8 81       	ld	r30, Y
    4b96:	f9 81       	ldd	r31, Y+1	; 0x01
    4b98:	8c ec       	ldi	r24, 0xCC	; 204
    4b9a:	87 83       	std	Z+7, r24	; 0x07
			break;
    4b9c:	08 c0       	rjmp	.+16     	; 0x4bae <usartBufferInitialize+0x146>
		default:
			//9600
			USART_Baudrate_Set(usartBuffer->usart, 3317 , -4);
    4b9e:	e8 81       	ld	r30, Y
    4ba0:	f9 81       	ldd	r31, Y+1	; 0x01
    4ba2:	85 ef       	ldi	r24, 0xF5	; 245
    4ba4:	86 83       	std	Z+6, r24	; 0x06
    4ba6:	e8 81       	ld	r30, Y
    4ba8:	f9 81       	ldd	r31, Y+1	; 0x01
    4baa:	8c ec       	ldi	r24, 0xCC	; 204
    4bac:	87 83       	std	Z+7, r24	; 0x07
			break;
	}

	/* Enable both RX and TX. */
	USART_Rx_Enable(usartBuffer->usart);
    4bae:	e8 81       	ld	r30, Y
    4bb0:	f9 81       	ldd	r31, Y+1	; 0x01
    4bb2:	84 81       	ldd	r24, Z+4	; 0x04
    4bb4:	80 61       	ori	r24, 0x10	; 16
    4bb6:	84 83       	std	Z+4, r24	; 0x04
	USART_Tx_Enable(usartBuffer->usart);
    4bb8:	e8 81       	ld	r30, Y
    4bba:	f9 81       	ldd	r31, Y+1	; 0x01
    4bbc:	84 81       	ldd	r24, Z+4	; 0x04
    4bbe:	88 60       	ori	r24, 0x08	; 8
    4bc0:	84 83       	std	Z+4, r24	; 0x04
	//return the buffer struct, to be used for reading and writing
	return usartBuffer;
}
    4bc2:	ce 01       	movw	r24, r28
    4bc4:	df 91       	pop	r29
    4bc6:	cf 91       	pop	r28
    4bc8:	1f 91       	pop	r17
    4bca:	0f 91       	pop	r16
    4bcc:	ff 90       	pop	r15
    4bce:	ef 90       	pop	r14
    4bd0:	df 90       	pop	r13
    4bd2:	cf 90       	pop	r12
    4bd4:	08 95       	ret

00004bd6 <usartBufferPutByte>:
 *  \param usart_struct The USART_buffer_struct_t struct instance.
 *  \param data       The data to send.
 *  \param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is space in queue.
 */
void usartBufferPutByte(UsartBuffer * usart_buffer_t, uint8_t data, int ticksToWait )
{
    4bd6:	0f 93       	push	r16
    4bd8:	1f 93       	push	r17
    4bda:	cf 93       	push	r28
    4bdc:	df 93       	push	r29
    4bde:	1f 92       	push	r1
    4be0:	cd b7       	in	r28, 0x3d	; 61
    4be2:	de b7       	in	r29, 0x3e	; 62
    4be4:	8c 01       	movw	r16, r24
    4be6:	69 83       	std	Y+1, r22	; 0x01
	uint8_t tempCTRLA;
	/* If we successfully loaded byte to queue */
	if (xQueueSendToBack(usart_buffer_t->xQueueTX,&data,ticksToWait))
    4be8:	20 e0       	ldi	r18, 0x00	; 0
    4bea:	be 01       	movw	r22, r28
    4bec:	6f 5f       	subi	r22, 0xFF	; 255
    4bee:	7f 4f       	sbci	r23, 0xFF	; 255
    4bf0:	dc 01       	movw	r26, r24
    4bf2:	15 96       	adiw	r26, 0x05	; 5
    4bf4:	8d 91       	ld	r24, X+
    4bf6:	9c 91       	ld	r25, X
    4bf8:	16 97       	sbiw	r26, 0x06	; 6
    4bfa:	0e 94 06 08 	call	0x100c	; 0x100c <xQueueGenericSend>
    4bfe:	88 23       	and	r24, r24
    4c00:	51 f0       	breq	.+20     	; 0x4c16 <usartBufferPutByte+0x40>
	{
		/* Enable DRE interrupt. */
		tempCTRLA = usart_buffer_t->usart->CTRLA;
    4c02:	d8 01       	movw	r26, r16
    4c04:	ed 91       	ld	r30, X+
    4c06:	fc 91       	ld	r31, X
    4c08:	11 97       	sbiw	r26, 0x01	; 1
    4c0a:	83 81       	ldd	r24, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_buffer_t->dreIntLevel;
    4c0c:	8c 7f       	andi	r24, 0xFC	; 252
    4c0e:	12 96       	adiw	r26, 0x02	; 2
    4c10:	9c 91       	ld	r25, X
    4c12:	89 2b       	or	r24, r25
		usart_buffer_t->usart->CTRLA = tempCTRLA;
    4c14:	83 83       	std	Z+3, r24	; 0x03
	}
}
    4c16:	0f 90       	pop	r0
    4c18:	df 91       	pop	r29
    4c1a:	cf 91       	pop	r28
    4c1c:	1f 91       	pop	r17
    4c1e:	0f 91       	pop	r16
    4c20:	08 95       	ret

00004c22 <usartBufferGetByte>:
 *	\param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is data in queue.
 *  \return					  Success.
 */
inline int8_t usartBufferGetByte(UsartBuffer * usartBuffer, char * receivedChar, int ticksToWait )
{
	return xQueueReceive(usartBuffer->xQueueRX, receivedChar, ticksToWait);
    4c22:	20 e0       	ldi	r18, 0x00	; 0
    4c24:	fc 01       	movw	r30, r24
    4c26:	83 81       	ldd	r24, Z+3	; 0x03
    4c28:	94 81       	ldd	r25, Z+4	; 0x04
    4c2a:	0c 94 e0 08 	jmp	0x11c0	; 0x11c0 <xQueueGenericReceive>
}
    4c2e:	08 95       	ret

00004c30 <usartBufferPutString>:
 *  \param usart_struct The USART_struct_t struct instance.
 *  \param string       The string to send.
 *  \param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is space in queue.
 */
inline void usartBufferPutString(UsartBuffer * usartBuffer, const char *string, int ticksToWait )
{
    4c30:	ef 92       	push	r14
    4c32:	ff 92       	push	r15
    4c34:	0f 93       	push	r16
    4c36:	1f 93       	push	r17
    4c38:	cf 93       	push	r28
    4c3a:	df 93       	push	r29
    4c3c:	8c 01       	movw	r16, r24
    4c3e:	eb 01       	movw	r28, r22
    4c40:	7a 01       	movw	r14, r20
	//send the whole string. Note that if buffer is full, USART_TXBuffer_PutByte will do nothing
	while (*string) usartBufferPutByte(usartBuffer,*string++, ticksToWait );
    4c42:	68 81       	ld	r22, Y
    4c44:	66 23       	and	r22, r22
    4c46:	39 f0       	breq	.+14     	; 0x4c56 <usartBufferPutString+0x26>
    4c48:	21 96       	adiw	r28, 0x01	; 1
    4c4a:	a7 01       	movw	r20, r14
    4c4c:	c8 01       	movw	r24, r16
    4c4e:	c3 df       	rcall	.-122    	; 0x4bd6 <usartBufferPutByte>
    4c50:	69 91       	ld	r22, Y+
    4c52:	61 11       	cpse	r22, r1
    4c54:	fa cf       	rjmp	.-12     	; 0x4c4a <usartBufferPutString+0x1a>
}
    4c56:	df 91       	pop	r29
    4c58:	cf 91       	pop	r28
    4c5a:	1f 91       	pop	r17
    4c5c:	0f 91       	pop	r16
    4c5e:	ff 90       	pop	r15
    4c60:	ef 90       	pop	r14
    4c62:	08 95       	ret

00004c64 <boardInit>:
	
	// prepare the i/o for LEDs
	ioport_init();
	
	// clock init & enable system clock to all peripheral modules
	sysclk_init();
    4c64:	cc d0       	rcall	.+408    	; 0x4dfe <sysclk_init>
	sysclk_enable_module(SYSCLK_PORT_GEN, 0xff);
    4c66:	6f ef       	ldi	r22, 0xFF	; 255
    4c68:	80 e0       	ldi	r24, 0x00	; 0
    4c6a:	f0 d0       	rcall	.+480    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_A, 0xff);
    4c6c:	6f ef       	ldi	r22, 0xFF	; 255
    4c6e:	81 e0       	ldi	r24, 0x01	; 1
    4c70:	ed d0       	rcall	.+474    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_B, 0xff);
    4c72:	6f ef       	ldi	r22, 0xFF	; 255
    4c74:	82 e0       	ldi	r24, 0x02	; 2
    4c76:	ea d0       	rcall	.+468    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_C, 0xff);
    4c78:	6f ef       	ldi	r22, 0xFF	; 255
    4c7a:	83 e0       	ldi	r24, 0x03	; 3
    4c7c:	e7 d0       	rcall	.+462    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_D, 0xff);
    4c7e:	6f ef       	ldi	r22, 0xFF	; 255
    4c80:	84 e0       	ldi	r24, 0x04	; 4
    4c82:	e4 d0       	rcall	.+456    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_E, 0xff);
    4c84:	6f ef       	ldi	r22, 0xFF	; 255
    4c86:	85 e0       	ldi	r24, 0x05	; 5
    4c88:	e1 d0       	rcall	.+450    	; 0x4e4c <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_F, 0xff);
    4c8a:	6f ef       	ldi	r22, 0xFF	; 255
    4c8c:	86 e0       	ldi	r24, 0x06	; 6
    4c8e:	de d0       	rcall	.+444    	; 0x4e4c <sysclk_enable_module>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    4c90:	e0 e6       	ldi	r30, 0x60	; 96
    4c92:	f6 e0       	ldi	r31, 0x06	; 6
    4c94:	81 e0       	ldi	r24, 0x01	; 1
    4c96:	81 83       	std	Z+1, r24	; 0x01
    4c98:	90 e1       	ldi	r25, 0x10	; 16
    4c9a:	91 83       	std	Z+1, r25	; 0x01
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    4c9c:	95 83       	std	Z+5, r25	; 0x05
    4c9e:	85 83       	std	Z+5, r24	; 0x05
	/* -------------------------------------------------------------------- */
	/*	Timer for RTC														*/
	/* -------------------------------------------------------------------- */
	
	// select the clock source and pre-scaler by 8
	TC1_ConfigClockSource(&TCC1, TC_CLKSEL_DIV64_gc);
    4ca0:	65 e0       	ldi	r22, 0x05	; 5
    4ca2:	80 e4       	ldi	r24, 0x40	; 64
    4ca4:	98 e0       	ldi	r25, 0x08	; 8
    4ca6:	64 da       	rcall	.-2872   	; 0x4170 <TC1_ConfigClockSource>
	
	TC1_SetOverflowIntLevel(&TCC1, TC_OVFINTLVL_LO_gc);
    4ca8:	61 e0       	ldi	r22, 0x01	; 1
    4caa:	80 e4       	ldi	r24, 0x40	; 64
    4cac:	98 e0       	ldi	r25, 0x08	; 8
    4cae:	6c da       	rcall	.-2856   	; 0x4188 <TC1_SetOverflowIntLevel>
	
	TC_SetPeriod(&TCC1, 499);
    4cb0:	83 ef       	ldi	r24, 0xF3	; 243
    4cb2:	91 e0       	ldi	r25, 0x01	; 1
    4cb4:	e0 e4       	ldi	r30, 0x40	; 64
    4cb6:	f8 e0       	ldi	r31, 0x08	; 8
    4cb8:	86 a3       	std	Z+38, r24	; 0x26
    4cba:	97 a3       	std	Z+39, r25	; 0x27
	
	milisecondsTimer = 0;
    4cbc:	10 92 5a 3f 	sts	0x3F5A, r1
    4cc0:	10 92 5b 3f 	sts	0x3F5B, r1
    4cc4:	10 92 5c 3f 	sts	0x3F5C, r1
    4cc8:	10 92 5d 3f 	sts	0x3F5D, r1
	secondsTimer = 0;
    4ccc:	10 92 5e 3f 	sts	0x3F5E, r1
    4cd0:	10 92 5f 3f 	sts	0x3F5F, r1
    4cd4:	10 92 60 3f 	sts	0x3F60, r1
    4cd8:	10 92 61 3f 	sts	0x3F61, r1
	hoursTimer = 0;
    4cdc:	10 92 56 3f 	sts	0x3F56, r1
    4ce0:	10 92 57 3f 	sts	0x3F57, r1
    4ce4:	10 92 58 3f 	sts	0x3F58, r1
    4ce8:	10 92 59 3f 	sts	0x3F59, r1
	
	pc_usart_buffer = usartBufferInitialize(&PC_USART, PC_USART_BAUDRATE, PC_USART_BUFFERSIZE);
    4cec:	40 e8       	ldi	r20, 0x80	; 128
    4cee:	64 e0       	ldi	r22, 0x04	; 4
    4cf0:	80 ea       	ldi	r24, 0xA0	; 160
    4cf2:	99 e0       	ldi	r25, 0x09	; 9
    4cf4:	b9 de       	rcall	.-654    	; 0x4a68 <usartBufferInitialize>
    4cf6:	80 93 62 3f 	sts	0x3F62, r24
    4cfa:	90 93 63 3f 	sts	0x3F63, r25
    4cfe:	08 95       	ret

00004d00 <__vector_20>:
}

/* -------------------------------------------------------------------- */
/*	Interrupt for timing the RTC										*/
/* -------------------------------------------------------------------- */
ISR(TCC1_OVF_vect) {
    4d00:	1f 92       	push	r1
    4d02:	0f 92       	push	r0
    4d04:	0f b6       	in	r0, 0x3f	; 63
    4d06:	0f 92       	push	r0
    4d08:	11 24       	eor	r1, r1
    4d0a:	08 b6       	in	r0, 0x38	; 56
    4d0c:	0f 92       	push	r0
    4d0e:	18 be       	out	0x38, r1	; 56
    4d10:	09 b6       	in	r0, 0x39	; 57
    4d12:	0f 92       	push	r0
    4d14:	19 be       	out	0x39, r1	; 57
    4d16:	2f 93       	push	r18
    4d18:	4f 93       	push	r20
    4d1a:	5f 93       	push	r21
    4d1c:	6f 93       	push	r22
    4d1e:	7f 93       	push	r23
    4d20:	8f 93       	push	r24
    4d22:	9f 93       	push	r25
    4d24:	af 93       	push	r26
    4d26:	bf 93       	push	r27
	
	// shut down the output PPM pulse
	
	if (milisecondsTimer++ == 1000) { // overflow to seconds
    4d28:	80 91 5a 3f 	lds	r24, 0x3F5A
    4d2c:	90 91 5b 3f 	lds	r25, 0x3F5B
    4d30:	a0 91 5c 3f 	lds	r26, 0x3F5C
    4d34:	b0 91 5d 3f 	lds	r27, 0x3F5D
    4d38:	ac 01       	movw	r20, r24
    4d3a:	bd 01       	movw	r22, r26
    4d3c:	4f 5f       	subi	r20, 0xFF	; 255
    4d3e:	5f 4f       	sbci	r21, 0xFF	; 255
    4d40:	6f 4f       	sbci	r22, 0xFF	; 255
    4d42:	7f 4f       	sbci	r23, 0xFF	; 255
    4d44:	40 93 5a 3f 	sts	0x3F5A, r20
    4d48:	50 93 5b 3f 	sts	0x3F5B, r21
    4d4c:	60 93 5c 3f 	sts	0x3F5C, r22
    4d50:	70 93 5d 3f 	sts	0x3F5D, r23
    4d54:	88 3e       	cpi	r24, 0xE8	; 232
    4d56:	93 40       	sbci	r25, 0x03	; 3
    4d58:	a1 05       	cpc	r26, r1
    4d5a:	b1 05       	cpc	r27, r1
    4d5c:	f1 f5       	brne	.+124    	; 0x4dda <__vector_20+0xda>
		
		milisecondsTimer = 0;
    4d5e:	10 92 5a 3f 	sts	0x3F5A, r1
    4d62:	10 92 5b 3f 	sts	0x3F5B, r1
    4d66:	10 92 5c 3f 	sts	0x3F5C, r1
    4d6a:	10 92 5d 3f 	sts	0x3F5D, r1
		
		if (secondsTimer++ == 3600) { // overflow to hours
    4d6e:	80 91 5e 3f 	lds	r24, 0x3F5E
    4d72:	90 91 5f 3f 	lds	r25, 0x3F5F
    4d76:	a0 91 60 3f 	lds	r26, 0x3F60
    4d7a:	b0 91 61 3f 	lds	r27, 0x3F61
    4d7e:	ac 01       	movw	r20, r24
    4d80:	bd 01       	movw	r22, r26
    4d82:	4f 5f       	subi	r20, 0xFF	; 255
    4d84:	5f 4f       	sbci	r21, 0xFF	; 255
    4d86:	6f 4f       	sbci	r22, 0xFF	; 255
    4d88:	7f 4f       	sbci	r23, 0xFF	; 255
    4d8a:	40 93 5e 3f 	sts	0x3F5E, r20
    4d8e:	50 93 5f 3f 	sts	0x3F5F, r21
    4d92:	60 93 60 3f 	sts	0x3F60, r22
    4d96:	70 93 61 3f 	sts	0x3F61, r23
    4d9a:	80 31       	cpi	r24, 0x10	; 16
    4d9c:	9e 40       	sbci	r25, 0x0E	; 14
    4d9e:	a1 05       	cpc	r26, r1
    4da0:	b1 05       	cpc	r27, r1
    4da2:	d9 f4       	brne	.+54     	; 0x4dda <__vector_20+0xda>
			
			secondsTimer = 0;
    4da4:	10 92 5e 3f 	sts	0x3F5E, r1
    4da8:	10 92 5f 3f 	sts	0x3F5F, r1
    4dac:	10 92 60 3f 	sts	0x3F60, r1
    4db0:	10 92 61 3f 	sts	0x3F61, r1
			hoursTimer++;
    4db4:	80 91 56 3f 	lds	r24, 0x3F56
    4db8:	90 91 57 3f 	lds	r25, 0x3F57
    4dbc:	a0 91 58 3f 	lds	r26, 0x3F58
    4dc0:	b0 91 59 3f 	lds	r27, 0x3F59
    4dc4:	01 96       	adiw	r24, 0x01	; 1
    4dc6:	a1 1d       	adc	r26, r1
    4dc8:	b1 1d       	adc	r27, r1
    4dca:	80 93 56 3f 	sts	0x3F56, r24
    4dce:	90 93 57 3f 	sts	0x3F57, r25
    4dd2:	a0 93 58 3f 	sts	0x3F58, r26
    4dd6:	b0 93 59 3f 	sts	0x3F59, r27
		}
	}
    4dda:	bf 91       	pop	r27
    4ddc:	af 91       	pop	r26
    4dde:	9f 91       	pop	r25
    4de0:	8f 91       	pop	r24
    4de2:	7f 91       	pop	r23
    4de4:	6f 91       	pop	r22
    4de6:	5f 91       	pop	r21
    4de8:	4f 91       	pop	r20
    4dea:	2f 91       	pop	r18
    4dec:	0f 90       	pop	r0
    4dee:	09 be       	out	0x39, r0	; 57
    4df0:	0f 90       	pop	r0
    4df2:	08 be       	out	0x38, r0	; 56
    4df4:	0f 90       	pop	r0
    4df6:	0f be       	out	0x3f, r0	; 63
    4df8:	0f 90       	pop	r0
    4dfa:	1f 90       	pop	r1
    4dfc:	18 95       	reti

00004dfe <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    4dfe:	8f ef       	ldi	r24, 0xFF	; 255
    4e00:	80 93 70 00 	sts	0x0070, r24
    4e04:	80 93 71 00 	sts	0x0071, r24
    4e08:	80 93 72 00 	sts	0x0072, r24
    4e0c:	80 93 73 00 	sts	0x0073, r24
    4e10:	80 93 74 00 	sts	0x0074, r24
    4e14:	80 93 75 00 	sts	0x0075, r24
    4e18:	80 93 76 00 	sts	0x0076, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e1c:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    4e1e:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
    4e20:	e0 e5       	ldi	r30, 0x50	; 80
    4e22:	f0 e0       	ldi	r31, 0x00	; 0
    4e24:	90 81       	ld	r25, Z
    4e26:	92 60       	ori	r25, 0x02	; 2
    4e28:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4e2a:	8f bf       	out	0x3f, r24	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
    4e2c:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
    4e2e:	81 ff       	sbrs	r24, 1
    4e30:	fd cf       	rjmp	.-6      	; 0x4e2c <sysclk_init+0x2e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
    4e32:	61 e0       	ldi	r22, 0x01	; 1
    4e34:	80 e4       	ldi	r24, 0x40	; 64
    4e36:	90 e0       	ldi	r25, 0x00	; 0
    4e38:	15 d0       	rcall	.+42     	; 0x4e64 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e3a:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    4e3c:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
    4e3e:	e0 e5       	ldi	r30, 0x50	; 80
    4e40:	f0 e0       	ldi	r31, 0x00	; 0
    4e42:	90 81       	ld	r25, Z
    4e44:	9e 7f       	andi	r25, 0xFE	; 254
    4e46:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4e48:	8f bf       	out	0x3f, r24	; 63
    4e4a:	08 95       	ret

00004e4c <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e4c:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    4e4e:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    4e50:	e8 2f       	mov	r30, r24
    4e52:	f0 e0       	ldi	r31, 0x00	; 0
    4e54:	e0 59       	subi	r30, 0x90	; 144
    4e56:	ff 4f       	sbci	r31, 0xFF	; 255
    4e58:	60 95       	com	r22
    4e5a:	80 81       	ld	r24, Z
    4e5c:	68 23       	and	r22, r24
    4e5e:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4e60:	9f bf       	out	0x3f, r25	; 63
    4e62:	08 95       	ret

00004e64 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    4e64:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    4e66:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    4e68:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    4e6a:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    4e6c:	60 83       	st	Z, r22
	ret                             // Return to caller
    4e6e:	08 95       	ret

00004e70 <vfprintf>:
    4e70:	2f 92       	push	r2
    4e72:	3f 92       	push	r3
    4e74:	4f 92       	push	r4
    4e76:	5f 92       	push	r5
    4e78:	6f 92       	push	r6
    4e7a:	7f 92       	push	r7
    4e7c:	8f 92       	push	r8
    4e7e:	9f 92       	push	r9
    4e80:	af 92       	push	r10
    4e82:	bf 92       	push	r11
    4e84:	cf 92       	push	r12
    4e86:	df 92       	push	r13
    4e88:	ef 92       	push	r14
    4e8a:	ff 92       	push	r15
    4e8c:	0f 93       	push	r16
    4e8e:	1f 93       	push	r17
    4e90:	cf 93       	push	r28
    4e92:	df 93       	push	r29
    4e94:	cd b7       	in	r28, 0x3d	; 61
    4e96:	de b7       	in	r29, 0x3e	; 62
    4e98:	63 97       	sbiw	r28, 0x13	; 19
    4e9a:	cd bf       	out	0x3d, r28	; 61
    4e9c:	de bf       	out	0x3e, r29	; 62
    4e9e:	7c 01       	movw	r14, r24
    4ea0:	1b 01       	movw	r2, r22
    4ea2:	6a 01       	movw	r12, r20
    4ea4:	fc 01       	movw	r30, r24
    4ea6:	16 82       	std	Z+6, r1	; 0x06
    4ea8:	17 82       	std	Z+7, r1	; 0x07
    4eaa:	83 81       	ldd	r24, Z+3	; 0x03
    4eac:	81 ff       	sbrs	r24, 1
    4eae:	49 c3       	rjmp	.+1682   	; 0x5542 <vfprintf+0x6d2>
    4eb0:	be 01       	movw	r22, r28
    4eb2:	6f 5f       	subi	r22, 0xFF	; 255
    4eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    4eb6:	4b 01       	movw	r8, r22
    4eb8:	f7 01       	movw	r30, r14
    4eba:	93 81       	ldd	r25, Z+3	; 0x03
    4ebc:	f1 01       	movw	r30, r2
    4ebe:	93 fd       	sbrc	r25, 3
    4ec0:	85 91       	lpm	r24, Z+
    4ec2:	93 ff       	sbrs	r25, 3
    4ec4:	81 91       	ld	r24, Z+
    4ec6:	1f 01       	movw	r2, r30
    4ec8:	88 23       	and	r24, r24
    4eca:	09 f4       	brne	.+2      	; 0x4ece <vfprintf+0x5e>
    4ecc:	36 c3       	rjmp	.+1644   	; 0x553a <vfprintf+0x6ca>
    4ece:	85 32       	cpi	r24, 0x25	; 37
    4ed0:	39 f4       	brne	.+14     	; 0x4ee0 <vfprintf+0x70>
    4ed2:	93 fd       	sbrc	r25, 3
    4ed4:	85 91       	lpm	r24, Z+
    4ed6:	93 ff       	sbrs	r25, 3
    4ed8:	81 91       	ld	r24, Z+
    4eda:	1f 01       	movw	r2, r30
    4edc:	85 32       	cpi	r24, 0x25	; 37
    4ede:	31 f4       	brne	.+12     	; 0x4eec <vfprintf+0x7c>
    4ee0:	b7 01       	movw	r22, r14
    4ee2:	90 e0       	ldi	r25, 0x00	; 0
    4ee4:	2f d5       	rcall	.+2654   	; 0x5944 <fputc>
    4ee6:	56 01       	movw	r10, r12
    4ee8:	65 01       	movw	r12, r10
    4eea:	e6 cf       	rjmp	.-52     	; 0x4eb8 <vfprintf+0x48>
    4eec:	10 e0       	ldi	r17, 0x00	; 0
    4eee:	51 2c       	mov	r5, r1
    4ef0:	20 e0       	ldi	r18, 0x00	; 0
    4ef2:	20 32       	cpi	r18, 0x20	; 32
    4ef4:	a0 f4       	brcc	.+40     	; 0x4f1e <vfprintf+0xae>
    4ef6:	8b 32       	cpi	r24, 0x2B	; 43
    4ef8:	69 f0       	breq	.+26     	; 0x4f14 <vfprintf+0xa4>
    4efa:	30 f4       	brcc	.+12     	; 0x4f08 <vfprintf+0x98>
    4efc:	80 32       	cpi	r24, 0x20	; 32
    4efe:	59 f0       	breq	.+22     	; 0x4f16 <vfprintf+0xa6>
    4f00:	83 32       	cpi	r24, 0x23	; 35
    4f02:	69 f4       	brne	.+26     	; 0x4f1e <vfprintf+0xae>
    4f04:	20 61       	ori	r18, 0x10	; 16
    4f06:	2c c0       	rjmp	.+88     	; 0x4f60 <vfprintf+0xf0>
    4f08:	8d 32       	cpi	r24, 0x2D	; 45
    4f0a:	39 f0       	breq	.+14     	; 0x4f1a <vfprintf+0xaa>
    4f0c:	80 33       	cpi	r24, 0x30	; 48
    4f0e:	39 f4       	brne	.+14     	; 0x4f1e <vfprintf+0xae>
    4f10:	21 60       	ori	r18, 0x01	; 1
    4f12:	26 c0       	rjmp	.+76     	; 0x4f60 <vfprintf+0xf0>
    4f14:	22 60       	ori	r18, 0x02	; 2
    4f16:	24 60       	ori	r18, 0x04	; 4
    4f18:	23 c0       	rjmp	.+70     	; 0x4f60 <vfprintf+0xf0>
    4f1a:	28 60       	ori	r18, 0x08	; 8
    4f1c:	21 c0       	rjmp	.+66     	; 0x4f60 <vfprintf+0xf0>
    4f1e:	27 fd       	sbrc	r18, 7
    4f20:	27 c0       	rjmp	.+78     	; 0x4f70 <vfprintf+0x100>
    4f22:	30 ed       	ldi	r19, 0xD0	; 208
    4f24:	38 0f       	add	r19, r24
    4f26:	3a 30       	cpi	r19, 0x0A	; 10
    4f28:	78 f4       	brcc	.+30     	; 0x4f48 <vfprintf+0xd8>
    4f2a:	26 ff       	sbrs	r18, 6
    4f2c:	06 c0       	rjmp	.+12     	; 0x4f3a <vfprintf+0xca>
    4f2e:	fa e0       	ldi	r31, 0x0A	; 10
    4f30:	1f 9f       	mul	r17, r31
    4f32:	30 0d       	add	r19, r0
    4f34:	11 24       	eor	r1, r1
    4f36:	13 2f       	mov	r17, r19
    4f38:	13 c0       	rjmp	.+38     	; 0x4f60 <vfprintf+0xf0>
    4f3a:	6a e0       	ldi	r22, 0x0A	; 10
    4f3c:	56 9e       	mul	r5, r22
    4f3e:	30 0d       	add	r19, r0
    4f40:	11 24       	eor	r1, r1
    4f42:	53 2e       	mov	r5, r19
    4f44:	20 62       	ori	r18, 0x20	; 32
    4f46:	0c c0       	rjmp	.+24     	; 0x4f60 <vfprintf+0xf0>
    4f48:	8e 32       	cpi	r24, 0x2E	; 46
    4f4a:	21 f4       	brne	.+8      	; 0x4f54 <vfprintf+0xe4>
    4f4c:	26 fd       	sbrc	r18, 6
    4f4e:	f5 c2       	rjmp	.+1514   	; 0x553a <vfprintf+0x6ca>
    4f50:	20 64       	ori	r18, 0x40	; 64
    4f52:	06 c0       	rjmp	.+12     	; 0x4f60 <vfprintf+0xf0>
    4f54:	8c 36       	cpi	r24, 0x6C	; 108
    4f56:	11 f4       	brne	.+4      	; 0x4f5c <vfprintf+0xec>
    4f58:	20 68       	ori	r18, 0x80	; 128
    4f5a:	02 c0       	rjmp	.+4      	; 0x4f60 <vfprintf+0xf0>
    4f5c:	88 36       	cpi	r24, 0x68	; 104
    4f5e:	41 f4       	brne	.+16     	; 0x4f70 <vfprintf+0x100>
    4f60:	f1 01       	movw	r30, r2
    4f62:	93 fd       	sbrc	r25, 3
    4f64:	85 91       	lpm	r24, Z+
    4f66:	93 ff       	sbrs	r25, 3
    4f68:	81 91       	ld	r24, Z+
    4f6a:	1f 01       	movw	r2, r30
    4f6c:	81 11       	cpse	r24, r1
    4f6e:	c1 cf       	rjmp	.-126    	; 0x4ef2 <vfprintf+0x82>
    4f70:	9b eb       	ldi	r25, 0xBB	; 187
    4f72:	98 0f       	add	r25, r24
    4f74:	93 30       	cpi	r25, 0x03	; 3
    4f76:	18 f4       	brcc	.+6      	; 0x4f7e <vfprintf+0x10e>
    4f78:	20 61       	ori	r18, 0x10	; 16
    4f7a:	80 5e       	subi	r24, 0xE0	; 224
    4f7c:	06 c0       	rjmp	.+12     	; 0x4f8a <vfprintf+0x11a>
    4f7e:	9b e9       	ldi	r25, 0x9B	; 155
    4f80:	98 0f       	add	r25, r24
    4f82:	93 30       	cpi	r25, 0x03	; 3
    4f84:	08 f0       	brcs	.+2      	; 0x4f88 <vfprintf+0x118>
    4f86:	9a c1       	rjmp	.+820    	; 0x52bc <vfprintf+0x44c>
    4f88:	2f 7e       	andi	r18, 0xEF	; 239
    4f8a:	26 ff       	sbrs	r18, 6
    4f8c:	16 e0       	ldi	r17, 0x06	; 6
    4f8e:	2f 73       	andi	r18, 0x3F	; 63
    4f90:	72 2e       	mov	r7, r18
    4f92:	85 36       	cpi	r24, 0x65	; 101
    4f94:	21 f4       	brne	.+8      	; 0x4f9e <vfprintf+0x12e>
    4f96:	f2 2f       	mov	r31, r18
    4f98:	f0 64       	ori	r31, 0x40	; 64
    4f9a:	7f 2e       	mov	r7, r31
    4f9c:	08 c0       	rjmp	.+16     	; 0x4fae <vfprintf+0x13e>
    4f9e:	86 36       	cpi	r24, 0x66	; 102
    4fa0:	21 f4       	brne	.+8      	; 0x4faa <vfprintf+0x13a>
    4fa2:	62 2f       	mov	r22, r18
    4fa4:	60 68       	ori	r22, 0x80	; 128
    4fa6:	76 2e       	mov	r7, r22
    4fa8:	02 c0       	rjmp	.+4      	; 0x4fae <vfprintf+0x13e>
    4faa:	11 11       	cpse	r17, r1
    4fac:	11 50       	subi	r17, 0x01	; 1
    4fae:	77 fe       	sbrs	r7, 7
    4fb0:	07 c0       	rjmp	.+14     	; 0x4fc0 <vfprintf+0x150>
    4fb2:	1c 33       	cpi	r17, 0x3C	; 60
    4fb4:	48 f4       	brcc	.+18     	; 0x4fc8 <vfprintf+0x158>
    4fb6:	44 24       	eor	r4, r4
    4fb8:	43 94       	inc	r4
    4fba:	41 0e       	add	r4, r17
    4fbc:	27 e0       	ldi	r18, 0x07	; 7
    4fbe:	0b c0       	rjmp	.+22     	; 0x4fd6 <vfprintf+0x166>
    4fc0:	18 30       	cpi	r17, 0x08	; 8
    4fc2:	30 f4       	brcc	.+12     	; 0x4fd0 <vfprintf+0x160>
    4fc4:	21 2f       	mov	r18, r17
    4fc6:	06 c0       	rjmp	.+12     	; 0x4fd4 <vfprintf+0x164>
    4fc8:	27 e0       	ldi	r18, 0x07	; 7
    4fca:	4c e3       	ldi	r20, 0x3C	; 60
    4fcc:	44 2e       	mov	r4, r20
    4fce:	03 c0       	rjmp	.+6      	; 0x4fd6 <vfprintf+0x166>
    4fd0:	27 e0       	ldi	r18, 0x07	; 7
    4fd2:	17 e0       	ldi	r17, 0x07	; 7
    4fd4:	41 2c       	mov	r4, r1
    4fd6:	56 01       	movw	r10, r12
    4fd8:	74 e0       	ldi	r23, 0x04	; 4
    4fda:	a7 0e       	add	r10, r23
    4fdc:	b1 1c       	adc	r11, r1
    4fde:	f6 01       	movw	r30, r12
    4fe0:	60 81       	ld	r22, Z
    4fe2:	71 81       	ldd	r23, Z+1	; 0x01
    4fe4:	82 81       	ldd	r24, Z+2	; 0x02
    4fe6:	93 81       	ldd	r25, Z+3	; 0x03
    4fe8:	04 2d       	mov	r16, r4
    4fea:	a4 01       	movw	r20, r8
    4fec:	55 d3       	rcall	.+1706   	; 0x5698 <__ftoa_engine>
    4fee:	6c 01       	movw	r12, r24
    4ff0:	09 81       	ldd	r16, Y+1	; 0x01
    4ff2:	00 ff       	sbrs	r16, 0
    4ff4:	02 c0       	rjmp	.+4      	; 0x4ffa <vfprintf+0x18a>
    4ff6:	03 ff       	sbrs	r16, 3
    4ff8:	06 c0       	rjmp	.+12     	; 0x5006 <vfprintf+0x196>
    4ffa:	71 fc       	sbrc	r7, 1
    4ffc:	07 c0       	rjmp	.+14     	; 0x500c <vfprintf+0x19c>
    4ffe:	72 fc       	sbrc	r7, 2
    5000:	08 c0       	rjmp	.+16     	; 0x5012 <vfprintf+0x1a2>
    5002:	61 2c       	mov	r6, r1
    5004:	08 c0       	rjmp	.+16     	; 0x5016 <vfprintf+0x1a6>
    5006:	3d e2       	ldi	r19, 0x2D	; 45
    5008:	63 2e       	mov	r6, r19
    500a:	05 c0       	rjmp	.+10     	; 0x5016 <vfprintf+0x1a6>
    500c:	2b e2       	ldi	r18, 0x2B	; 43
    500e:	62 2e       	mov	r6, r18
    5010:	02 c0       	rjmp	.+4      	; 0x5016 <vfprintf+0x1a6>
    5012:	90 e2       	ldi	r25, 0x20	; 32
    5014:	69 2e       	mov	r6, r25
    5016:	80 2f       	mov	r24, r16
    5018:	8c 70       	andi	r24, 0x0C	; 12
    501a:	81 f1       	breq	.+96     	; 0x507c <vfprintf+0x20c>
    501c:	66 20       	and	r6, r6
    501e:	11 f0       	breq	.+4      	; 0x5024 <vfprintf+0x1b4>
    5020:	84 e0       	ldi	r24, 0x04	; 4
    5022:	01 c0       	rjmp	.+2      	; 0x5026 <vfprintf+0x1b6>
    5024:	83 e0       	ldi	r24, 0x03	; 3
    5026:	85 15       	cp	r24, r5
    5028:	10 f0       	brcs	.+4      	; 0x502e <vfprintf+0x1be>
    502a:	51 2c       	mov	r5, r1
    502c:	0a c0       	rjmp	.+20     	; 0x5042 <vfprintf+0x1d2>
    502e:	58 1a       	sub	r5, r24
    5030:	73 fc       	sbrc	r7, 3
    5032:	07 c0       	rjmp	.+14     	; 0x5042 <vfprintf+0x1d2>
    5034:	b7 01       	movw	r22, r14
    5036:	80 e2       	ldi	r24, 0x20	; 32
    5038:	90 e0       	ldi	r25, 0x00	; 0
    503a:	84 d4       	rcall	.+2312   	; 0x5944 <fputc>
    503c:	5a 94       	dec	r5
    503e:	d1 f7       	brne	.-12     	; 0x5034 <vfprintf+0x1c4>
    5040:	f4 cf       	rjmp	.-24     	; 0x502a <vfprintf+0x1ba>
    5042:	66 20       	and	r6, r6
    5044:	21 f0       	breq	.+8      	; 0x504e <vfprintf+0x1de>
    5046:	b7 01       	movw	r22, r14
    5048:	86 2d       	mov	r24, r6
    504a:	90 e0       	ldi	r25, 0x00	; 0
    504c:	7b d4       	rcall	.+2294   	; 0x5944 <fputc>
    504e:	03 fd       	sbrc	r16, 3
    5050:	03 c0       	rjmp	.+6      	; 0x5058 <vfprintf+0x1e8>
    5052:	0e e0       	ldi	r16, 0x0E	; 14
    5054:	16 e0       	ldi	r17, 0x06	; 6
    5056:	02 c0       	rjmp	.+4      	; 0x505c <vfprintf+0x1ec>
    5058:	0a e0       	ldi	r16, 0x0A	; 10
    505a:	16 e0       	ldi	r17, 0x06	; 6
    505c:	f7 2d       	mov	r31, r7
    505e:	f0 71       	andi	r31, 0x10	; 16
    5060:	7f 2e       	mov	r7, r31
    5062:	f8 01       	movw	r30, r16
    5064:	84 91       	lpm	r24, Z
    5066:	88 23       	and	r24, r24
    5068:	09 f4       	brne	.+2      	; 0x506c <vfprintf+0x1fc>
    506a:	5e c2       	rjmp	.+1212   	; 0x5528 <vfprintf+0x6b8>
    506c:	71 10       	cpse	r7, r1
    506e:	80 52       	subi	r24, 0x20	; 32
    5070:	b7 01       	movw	r22, r14
    5072:	90 e0       	ldi	r25, 0x00	; 0
    5074:	67 d4       	rcall	.+2254   	; 0x5944 <fputc>
    5076:	0f 5f       	subi	r16, 0xFF	; 255
    5078:	1f 4f       	sbci	r17, 0xFF	; 255
    507a:	f3 cf       	rjmp	.-26     	; 0x5062 <vfprintf+0x1f2>
    507c:	77 fe       	sbrs	r7, 7
    507e:	0f c0       	rjmp	.+30     	; 0x509e <vfprintf+0x22e>
    5080:	4c 0c       	add	r4, r12
    5082:	04 ff       	sbrs	r16, 4
    5084:	04 c0       	rjmp	.+8      	; 0x508e <vfprintf+0x21e>
    5086:	8a 81       	ldd	r24, Y+2	; 0x02
    5088:	81 33       	cpi	r24, 0x31	; 49
    508a:	09 f4       	brne	.+2      	; 0x508e <vfprintf+0x21e>
    508c:	4a 94       	dec	r4
    508e:	14 14       	cp	r1, r4
    5090:	74 f5       	brge	.+92     	; 0x50ee <vfprintf+0x27e>
    5092:	f8 e0       	ldi	r31, 0x08	; 8
    5094:	f4 15       	cp	r31, r4
    5096:	78 f5       	brcc	.+94     	; 0x50f6 <vfprintf+0x286>
    5098:	88 e0       	ldi	r24, 0x08	; 8
    509a:	48 2e       	mov	r4, r24
    509c:	2c c0       	rjmp	.+88     	; 0x50f6 <vfprintf+0x286>
    509e:	76 fc       	sbrc	r7, 6
    50a0:	2a c0       	rjmp	.+84     	; 0x50f6 <vfprintf+0x286>
    50a2:	81 2f       	mov	r24, r17
    50a4:	90 e0       	ldi	r25, 0x00	; 0
    50a6:	8c 15       	cp	r24, r12
    50a8:	9d 05       	cpc	r25, r13
    50aa:	9c f0       	brlt	.+38     	; 0x50d2 <vfprintf+0x262>
    50ac:	6c ef       	ldi	r22, 0xFC	; 252
    50ae:	c6 16       	cp	r12, r22
    50b0:	6f ef       	ldi	r22, 0xFF	; 255
    50b2:	d6 06       	cpc	r13, r22
    50b4:	74 f0       	brlt	.+28     	; 0x50d2 <vfprintf+0x262>
    50b6:	77 2d       	mov	r23, r7
    50b8:	70 68       	ori	r23, 0x80	; 128
    50ba:	77 2e       	mov	r7, r23
    50bc:	0a c0       	rjmp	.+20     	; 0x50d2 <vfprintf+0x262>
    50be:	e2 e0       	ldi	r30, 0x02	; 2
    50c0:	f0 e0       	ldi	r31, 0x00	; 0
    50c2:	ec 0f       	add	r30, r28
    50c4:	fd 1f       	adc	r31, r29
    50c6:	e1 0f       	add	r30, r17
    50c8:	f1 1d       	adc	r31, r1
    50ca:	80 81       	ld	r24, Z
    50cc:	80 33       	cpi	r24, 0x30	; 48
    50ce:	19 f4       	brne	.+6      	; 0x50d6 <vfprintf+0x266>
    50d0:	11 50       	subi	r17, 0x01	; 1
    50d2:	11 11       	cpse	r17, r1
    50d4:	f4 cf       	rjmp	.-24     	; 0x50be <vfprintf+0x24e>
    50d6:	77 fe       	sbrs	r7, 7
    50d8:	0e c0       	rjmp	.+28     	; 0x50f6 <vfprintf+0x286>
    50da:	44 24       	eor	r4, r4
    50dc:	43 94       	inc	r4
    50de:	41 0e       	add	r4, r17
    50e0:	81 2f       	mov	r24, r17
    50e2:	90 e0       	ldi	r25, 0x00	; 0
    50e4:	c8 16       	cp	r12, r24
    50e6:	d9 06       	cpc	r13, r25
    50e8:	2c f4       	brge	.+10     	; 0x50f4 <vfprintf+0x284>
    50ea:	1c 19       	sub	r17, r12
    50ec:	04 c0       	rjmp	.+8      	; 0x50f6 <vfprintf+0x286>
    50ee:	44 24       	eor	r4, r4
    50f0:	43 94       	inc	r4
    50f2:	01 c0       	rjmp	.+2      	; 0x50f6 <vfprintf+0x286>
    50f4:	10 e0       	ldi	r17, 0x00	; 0
    50f6:	77 fe       	sbrs	r7, 7
    50f8:	07 c0       	rjmp	.+14     	; 0x5108 <vfprintf+0x298>
    50fa:	1c 14       	cp	r1, r12
    50fc:	1d 04       	cpc	r1, r13
    50fe:	3c f4       	brge	.+14     	; 0x510e <vfprintf+0x29e>
    5100:	96 01       	movw	r18, r12
    5102:	2f 5f       	subi	r18, 0xFF	; 255
    5104:	3f 4f       	sbci	r19, 0xFF	; 255
    5106:	05 c0       	rjmp	.+10     	; 0x5112 <vfprintf+0x2a2>
    5108:	25 e0       	ldi	r18, 0x05	; 5
    510a:	30 e0       	ldi	r19, 0x00	; 0
    510c:	02 c0       	rjmp	.+4      	; 0x5112 <vfprintf+0x2a2>
    510e:	21 e0       	ldi	r18, 0x01	; 1
    5110:	30 e0       	ldi	r19, 0x00	; 0
    5112:	66 20       	and	r6, r6
    5114:	11 f0       	breq	.+4      	; 0x511a <vfprintf+0x2aa>
    5116:	2f 5f       	subi	r18, 0xFF	; 255
    5118:	3f 4f       	sbci	r19, 0xFF	; 255
    511a:	11 23       	and	r17, r17
    511c:	31 f0       	breq	.+12     	; 0x512a <vfprintf+0x2ba>
    511e:	41 2f       	mov	r20, r17
    5120:	50 e0       	ldi	r21, 0x00	; 0
    5122:	4f 5f       	subi	r20, 0xFF	; 255
    5124:	5f 4f       	sbci	r21, 0xFF	; 255
    5126:	24 0f       	add	r18, r20
    5128:	35 1f       	adc	r19, r21
    512a:	45 2d       	mov	r20, r5
    512c:	50 e0       	ldi	r21, 0x00	; 0
    512e:	24 17       	cp	r18, r20
    5130:	35 07       	cpc	r19, r21
    5132:	14 f4       	brge	.+4      	; 0x5138 <vfprintf+0x2c8>
    5134:	52 1a       	sub	r5, r18
    5136:	01 c0       	rjmp	.+2      	; 0x513a <vfprintf+0x2ca>
    5138:	51 2c       	mov	r5, r1
    513a:	87 2d       	mov	r24, r7
    513c:	89 70       	andi	r24, 0x09	; 9
    513e:	41 f4       	brne	.+16     	; 0x5150 <vfprintf+0x2e0>
    5140:	55 20       	and	r5, r5
    5142:	31 f0       	breq	.+12     	; 0x5150 <vfprintf+0x2e0>
    5144:	b7 01       	movw	r22, r14
    5146:	80 e2       	ldi	r24, 0x20	; 32
    5148:	90 e0       	ldi	r25, 0x00	; 0
    514a:	fc d3       	rcall	.+2040   	; 0x5944 <fputc>
    514c:	5a 94       	dec	r5
    514e:	f8 cf       	rjmp	.-16     	; 0x5140 <vfprintf+0x2d0>
    5150:	66 20       	and	r6, r6
    5152:	21 f0       	breq	.+8      	; 0x515c <vfprintf+0x2ec>
    5154:	b7 01       	movw	r22, r14
    5156:	86 2d       	mov	r24, r6
    5158:	90 e0       	ldi	r25, 0x00	; 0
    515a:	f4 d3       	rcall	.+2024   	; 0x5944 <fputc>
    515c:	73 fc       	sbrc	r7, 3
    515e:	08 c0       	rjmp	.+16     	; 0x5170 <vfprintf+0x300>
    5160:	55 20       	and	r5, r5
    5162:	31 f0       	breq	.+12     	; 0x5170 <vfprintf+0x300>
    5164:	b7 01       	movw	r22, r14
    5166:	80 e3       	ldi	r24, 0x30	; 48
    5168:	90 e0       	ldi	r25, 0x00	; 0
    516a:	ec d3       	rcall	.+2008   	; 0x5944 <fputc>
    516c:	5a 94       	dec	r5
    516e:	f8 cf       	rjmp	.-16     	; 0x5160 <vfprintf+0x2f0>
    5170:	77 fe       	sbrs	r7, 7
    5172:	5d c0       	rjmp	.+186    	; 0x522e <vfprintf+0x3be>
    5174:	9c 2d       	mov	r25, r12
    5176:	8d 2d       	mov	r24, r13
    5178:	d7 fe       	sbrs	r13, 7
    517a:	02 c0       	rjmp	.+4      	; 0x5180 <vfprintf+0x310>
    517c:	90 e0       	ldi	r25, 0x00	; 0
    517e:	80 e0       	ldi	r24, 0x00	; 0
    5180:	69 2e       	mov	r6, r25
    5182:	78 2e       	mov	r7, r24
    5184:	40 e0       	ldi	r20, 0x00	; 0
    5186:	50 e0       	ldi	r21, 0x00	; 0
    5188:	c6 01       	movw	r24, r12
    518a:	84 19       	sub	r24, r4
    518c:	91 09       	sbc	r25, r1
    518e:	8c 87       	std	Y+12, r24	; 0x0c
    5190:	9d 87       	std	Y+13, r25	; 0x0d
    5192:	96 01       	movw	r18, r12
    5194:	26 19       	sub	r18, r6
    5196:	37 09       	sbc	r19, r7
    5198:	28 0d       	add	r18, r8
    519a:	39 1d       	adc	r19, r9
    519c:	81 2f       	mov	r24, r17
    519e:	90 e0       	ldi	r25, 0x00	; 0
    51a0:	ee 27       	eor	r30, r30
    51a2:	ff 27       	eor	r31, r31
    51a4:	e8 1b       	sub	r30, r24
    51a6:	f9 0b       	sbc	r31, r25
    51a8:	ee 87       	std	Y+14, r30	; 0x0e
    51aa:	ff 87       	std	Y+15, r31	; 0x0f
    51ac:	ff ef       	ldi	r31, 0xFF	; 255
    51ae:	6f 16       	cp	r6, r31
    51b0:	7f 06       	cpc	r7, r31
    51b2:	61 f4       	brne	.+24     	; 0x51cc <vfprintf+0x35c>
    51b4:	b7 01       	movw	r22, r14
    51b6:	8e e2       	ldi	r24, 0x2E	; 46
    51b8:	90 e0       	ldi	r25, 0x00	; 0
    51ba:	2b 8b       	std	Y+19, r18	; 0x13
    51bc:	3a 8b       	std	Y+18, r19	; 0x12
    51be:	48 8b       	std	Y+16, r20	; 0x10
    51c0:	59 8b       	std	Y+17, r21	; 0x11
    51c2:	c0 d3       	rcall	.+1920   	; 0x5944 <fputc>
    51c4:	59 89       	ldd	r21, Y+17	; 0x11
    51c6:	48 89       	ldd	r20, Y+16	; 0x10
    51c8:	3a 89       	ldd	r19, Y+18	; 0x12
    51ca:	2b 89       	ldd	r18, Y+19	; 0x13
    51cc:	c6 14       	cp	r12, r6
    51ce:	d7 04       	cpc	r13, r7
    51d0:	54 f0       	brlt	.+20     	; 0x51e6 <vfprintf+0x376>
    51d2:	6c 85       	ldd	r22, Y+12	; 0x0c
    51d4:	7d 85       	ldd	r23, Y+13	; 0x0d
    51d6:	66 15       	cp	r22, r6
    51d8:	77 05       	cpc	r23, r7
    51da:	2c f4       	brge	.+10     	; 0x51e6 <vfprintf+0x376>
    51dc:	f9 01       	movw	r30, r18
    51de:	e4 0f       	add	r30, r20
    51e0:	f5 1f       	adc	r31, r21
    51e2:	81 81       	ldd	r24, Z+1	; 0x01
    51e4:	01 c0       	rjmp	.+2      	; 0x51e8 <vfprintf+0x378>
    51e6:	80 e3       	ldi	r24, 0x30	; 48
    51e8:	71 e0       	ldi	r23, 0x01	; 1
    51ea:	67 1a       	sub	r6, r23
    51ec:	71 08       	sbc	r7, r1
    51ee:	4f 5f       	subi	r20, 0xFF	; 255
    51f0:	5f 4f       	sbci	r21, 0xFF	; 255
    51f2:	ee 85       	ldd	r30, Y+14	; 0x0e
    51f4:	ff 85       	ldd	r31, Y+15	; 0x0f
    51f6:	6e 16       	cp	r6, r30
    51f8:	7f 06       	cpc	r7, r31
    51fa:	64 f0       	brlt	.+24     	; 0x5214 <vfprintf+0x3a4>
    51fc:	b7 01       	movw	r22, r14
    51fe:	90 e0       	ldi	r25, 0x00	; 0
    5200:	2b 8b       	std	Y+19, r18	; 0x13
    5202:	3a 8b       	std	Y+18, r19	; 0x12
    5204:	48 8b       	std	Y+16, r20	; 0x10
    5206:	59 8b       	std	Y+17, r21	; 0x11
    5208:	9d d3       	rcall	.+1850   	; 0x5944 <fputc>
    520a:	2b 89       	ldd	r18, Y+19	; 0x13
    520c:	3a 89       	ldd	r19, Y+18	; 0x12
    520e:	48 89       	ldd	r20, Y+16	; 0x10
    5210:	59 89       	ldd	r21, Y+17	; 0x11
    5212:	cc cf       	rjmp	.-104    	; 0x51ac <vfprintf+0x33c>
    5214:	6c 14       	cp	r6, r12
    5216:	7d 04       	cpc	r7, r13
    5218:	39 f4       	brne	.+14     	; 0x5228 <vfprintf+0x3b8>
    521a:	9a 81       	ldd	r25, Y+2	; 0x02
    521c:	96 33       	cpi	r25, 0x36	; 54
    521e:	18 f4       	brcc	.+6      	; 0x5226 <vfprintf+0x3b6>
    5220:	95 33       	cpi	r25, 0x35	; 53
    5222:	11 f4       	brne	.+4      	; 0x5228 <vfprintf+0x3b8>
    5224:	04 ff       	sbrs	r16, 4
    5226:	81 e3       	ldi	r24, 0x31	; 49
    5228:	b7 01       	movw	r22, r14
    522a:	90 e0       	ldi	r25, 0x00	; 0
    522c:	45 c0       	rjmp	.+138    	; 0x52b8 <vfprintf+0x448>
    522e:	8a 81       	ldd	r24, Y+2	; 0x02
    5230:	81 33       	cpi	r24, 0x31	; 49
    5232:	09 f0       	breq	.+2      	; 0x5236 <vfprintf+0x3c6>
    5234:	0f 7e       	andi	r16, 0xEF	; 239
    5236:	b7 01       	movw	r22, r14
    5238:	90 e0       	ldi	r25, 0x00	; 0
    523a:	84 d3       	rcall	.+1800   	; 0x5944 <fputc>
    523c:	11 11       	cpse	r17, r1
    523e:	05 c0       	rjmp	.+10     	; 0x524a <vfprintf+0x3da>
    5240:	74 fe       	sbrs	r7, 4
    5242:	16 c0       	rjmp	.+44     	; 0x5270 <vfprintf+0x400>
    5244:	85 e4       	ldi	r24, 0x45	; 69
    5246:	90 e0       	ldi	r25, 0x00	; 0
    5248:	15 c0       	rjmp	.+42     	; 0x5274 <vfprintf+0x404>
    524a:	b7 01       	movw	r22, r14
    524c:	8e e2       	ldi	r24, 0x2E	; 46
    524e:	90 e0       	ldi	r25, 0x00	; 0
    5250:	79 d3       	rcall	.+1778   	; 0x5944 <fputc>
    5252:	82 e0       	ldi	r24, 0x02	; 2
    5254:	66 24       	eor	r6, r6
    5256:	63 94       	inc	r6
    5258:	68 0e       	add	r6, r24
    525a:	f4 01       	movw	r30, r8
    525c:	e8 0f       	add	r30, r24
    525e:	f1 1d       	adc	r31, r1
    5260:	80 81       	ld	r24, Z
    5262:	b7 01       	movw	r22, r14
    5264:	90 e0       	ldi	r25, 0x00	; 0
    5266:	6e d3       	rcall	.+1756   	; 0x5944 <fputc>
    5268:	11 50       	subi	r17, 0x01	; 1
    526a:	51 f3       	breq	.-44     	; 0x5240 <vfprintf+0x3d0>
    526c:	86 2d       	mov	r24, r6
    526e:	f2 cf       	rjmp	.-28     	; 0x5254 <vfprintf+0x3e4>
    5270:	85 e6       	ldi	r24, 0x65	; 101
    5272:	90 e0       	ldi	r25, 0x00	; 0
    5274:	b7 01       	movw	r22, r14
    5276:	66 d3       	rcall	.+1740   	; 0x5944 <fputc>
    5278:	d7 fc       	sbrc	r13, 7
    527a:	05 c0       	rjmp	.+10     	; 0x5286 <vfprintf+0x416>
    527c:	c1 14       	cp	r12, r1
    527e:	d1 04       	cpc	r13, r1
    5280:	39 f4       	brne	.+14     	; 0x5290 <vfprintf+0x420>
    5282:	04 ff       	sbrs	r16, 4
    5284:	05 c0       	rjmp	.+10     	; 0x5290 <vfprintf+0x420>
    5286:	d1 94       	neg	r13
    5288:	c1 94       	neg	r12
    528a:	d1 08       	sbc	r13, r1
    528c:	8d e2       	ldi	r24, 0x2D	; 45
    528e:	01 c0       	rjmp	.+2      	; 0x5292 <vfprintf+0x422>
    5290:	8b e2       	ldi	r24, 0x2B	; 43
    5292:	b7 01       	movw	r22, r14
    5294:	90 e0       	ldi	r25, 0x00	; 0
    5296:	56 d3       	rcall	.+1708   	; 0x5944 <fputc>
    5298:	80 e3       	ldi	r24, 0x30	; 48
    529a:	6a e0       	ldi	r22, 0x0A	; 10
    529c:	c6 16       	cp	r12, r22
    529e:	d1 04       	cpc	r13, r1
    52a0:	2c f0       	brlt	.+10     	; 0x52ac <vfprintf+0x43c>
    52a2:	8f 5f       	subi	r24, 0xFF	; 255
    52a4:	fa e0       	ldi	r31, 0x0A	; 10
    52a6:	cf 1a       	sub	r12, r31
    52a8:	d1 08       	sbc	r13, r1
    52aa:	f7 cf       	rjmp	.-18     	; 0x529a <vfprintf+0x42a>
    52ac:	b7 01       	movw	r22, r14
    52ae:	90 e0       	ldi	r25, 0x00	; 0
    52b0:	49 d3       	rcall	.+1682   	; 0x5944 <fputc>
    52b2:	b7 01       	movw	r22, r14
    52b4:	c6 01       	movw	r24, r12
    52b6:	c0 96       	adiw	r24, 0x30	; 48
    52b8:	45 d3       	rcall	.+1674   	; 0x5944 <fputc>
    52ba:	36 c1       	rjmp	.+620    	; 0x5528 <vfprintf+0x6b8>
    52bc:	83 36       	cpi	r24, 0x63	; 99
    52be:	31 f0       	breq	.+12     	; 0x52cc <vfprintf+0x45c>
    52c0:	83 37       	cpi	r24, 0x73	; 115
    52c2:	79 f0       	breq	.+30     	; 0x52e2 <vfprintf+0x472>
    52c4:	83 35       	cpi	r24, 0x53	; 83
    52c6:	09 f0       	breq	.+2      	; 0x52ca <vfprintf+0x45a>
    52c8:	54 c0       	rjmp	.+168    	; 0x5372 <vfprintf+0x502>
    52ca:	20 c0       	rjmp	.+64     	; 0x530c <vfprintf+0x49c>
    52cc:	56 01       	movw	r10, r12
    52ce:	72 e0       	ldi	r23, 0x02	; 2
    52d0:	a7 0e       	add	r10, r23
    52d2:	b1 1c       	adc	r11, r1
    52d4:	f6 01       	movw	r30, r12
    52d6:	80 81       	ld	r24, Z
    52d8:	89 83       	std	Y+1, r24	; 0x01
    52da:	01 e0       	ldi	r16, 0x01	; 1
    52dc:	10 e0       	ldi	r17, 0x00	; 0
    52de:	64 01       	movw	r12, r8
    52e0:	13 c0       	rjmp	.+38     	; 0x5308 <vfprintf+0x498>
    52e2:	56 01       	movw	r10, r12
    52e4:	f2 e0       	ldi	r31, 0x02	; 2
    52e6:	af 0e       	add	r10, r31
    52e8:	b1 1c       	adc	r11, r1
    52ea:	f6 01       	movw	r30, r12
    52ec:	c0 80       	ld	r12, Z
    52ee:	d1 80       	ldd	r13, Z+1	; 0x01
    52f0:	26 ff       	sbrs	r18, 6
    52f2:	03 c0       	rjmp	.+6      	; 0x52fa <vfprintf+0x48a>
    52f4:	61 2f       	mov	r22, r17
    52f6:	70 e0       	ldi	r23, 0x00	; 0
    52f8:	02 c0       	rjmp	.+4      	; 0x52fe <vfprintf+0x48e>
    52fa:	6f ef       	ldi	r22, 0xFF	; 255
    52fc:	7f ef       	ldi	r23, 0xFF	; 255
    52fe:	c6 01       	movw	r24, r12
    5300:	2b 8b       	std	Y+19, r18	; 0x13
    5302:	f2 d2       	rcall	.+1508   	; 0x58e8 <strnlen>
    5304:	8c 01       	movw	r16, r24
    5306:	2b 89       	ldd	r18, Y+19	; 0x13
    5308:	2f 77       	andi	r18, 0x7F	; 127
    530a:	14 c0       	rjmp	.+40     	; 0x5334 <vfprintf+0x4c4>
    530c:	56 01       	movw	r10, r12
    530e:	f2 e0       	ldi	r31, 0x02	; 2
    5310:	af 0e       	add	r10, r31
    5312:	b1 1c       	adc	r11, r1
    5314:	f6 01       	movw	r30, r12
    5316:	c0 80       	ld	r12, Z
    5318:	d1 80       	ldd	r13, Z+1	; 0x01
    531a:	26 ff       	sbrs	r18, 6
    531c:	03 c0       	rjmp	.+6      	; 0x5324 <vfprintf+0x4b4>
    531e:	61 2f       	mov	r22, r17
    5320:	70 e0       	ldi	r23, 0x00	; 0
    5322:	02 c0       	rjmp	.+4      	; 0x5328 <vfprintf+0x4b8>
    5324:	6f ef       	ldi	r22, 0xFF	; 255
    5326:	7f ef       	ldi	r23, 0xFF	; 255
    5328:	c6 01       	movw	r24, r12
    532a:	2b 8b       	std	Y+19, r18	; 0x13
    532c:	8d d2       	rcall	.+1306   	; 0x5848 <strnlen_P>
    532e:	8c 01       	movw	r16, r24
    5330:	2b 89       	ldd	r18, Y+19	; 0x13
    5332:	20 68       	ori	r18, 0x80	; 128
    5334:	72 2e       	mov	r7, r18
    5336:	23 fd       	sbrc	r18, 3
    5338:	18 c0       	rjmp	.+48     	; 0x536a <vfprintf+0x4fa>
    533a:	85 2d       	mov	r24, r5
    533c:	90 e0       	ldi	r25, 0x00	; 0
    533e:	08 17       	cp	r16, r24
    5340:	19 07       	cpc	r17, r25
    5342:	98 f4       	brcc	.+38     	; 0x536a <vfprintf+0x4fa>
    5344:	b7 01       	movw	r22, r14
    5346:	80 e2       	ldi	r24, 0x20	; 32
    5348:	90 e0       	ldi	r25, 0x00	; 0
    534a:	fc d2       	rcall	.+1528   	; 0x5944 <fputc>
    534c:	5a 94       	dec	r5
    534e:	f5 cf       	rjmp	.-22     	; 0x533a <vfprintf+0x4ca>
    5350:	f6 01       	movw	r30, r12
    5352:	77 fc       	sbrc	r7, 7
    5354:	85 91       	lpm	r24, Z+
    5356:	77 fe       	sbrs	r7, 7
    5358:	81 91       	ld	r24, Z+
    535a:	6f 01       	movw	r12, r30
    535c:	b7 01       	movw	r22, r14
    535e:	90 e0       	ldi	r25, 0x00	; 0
    5360:	f1 d2       	rcall	.+1506   	; 0x5944 <fputc>
    5362:	51 10       	cpse	r5, r1
    5364:	5a 94       	dec	r5
    5366:	01 50       	subi	r16, 0x01	; 1
    5368:	11 09       	sbc	r17, r1
    536a:	01 15       	cp	r16, r1
    536c:	11 05       	cpc	r17, r1
    536e:	81 f7       	brne	.-32     	; 0x5350 <vfprintf+0x4e0>
    5370:	db c0       	rjmp	.+438    	; 0x5528 <vfprintf+0x6b8>
    5372:	84 36       	cpi	r24, 0x64	; 100
    5374:	11 f0       	breq	.+4      	; 0x537a <vfprintf+0x50a>
    5376:	89 36       	cpi	r24, 0x69	; 105
    5378:	49 f5       	brne	.+82     	; 0x53cc <vfprintf+0x55c>
    537a:	56 01       	movw	r10, r12
    537c:	27 ff       	sbrs	r18, 7
    537e:	09 c0       	rjmp	.+18     	; 0x5392 <vfprintf+0x522>
    5380:	f4 e0       	ldi	r31, 0x04	; 4
    5382:	af 0e       	add	r10, r31
    5384:	b1 1c       	adc	r11, r1
    5386:	f6 01       	movw	r30, r12
    5388:	60 81       	ld	r22, Z
    538a:	71 81       	ldd	r23, Z+1	; 0x01
    538c:	82 81       	ldd	r24, Z+2	; 0x02
    538e:	93 81       	ldd	r25, Z+3	; 0x03
    5390:	0a c0       	rjmp	.+20     	; 0x53a6 <vfprintf+0x536>
    5392:	f2 e0       	ldi	r31, 0x02	; 2
    5394:	af 0e       	add	r10, r31
    5396:	b1 1c       	adc	r11, r1
    5398:	f6 01       	movw	r30, r12
    539a:	60 81       	ld	r22, Z
    539c:	71 81       	ldd	r23, Z+1	; 0x01
    539e:	88 27       	eor	r24, r24
    53a0:	77 fd       	sbrc	r23, 7
    53a2:	80 95       	com	r24
    53a4:	98 2f       	mov	r25, r24
    53a6:	02 2f       	mov	r16, r18
    53a8:	0f 76       	andi	r16, 0x6F	; 111
    53aa:	97 ff       	sbrs	r25, 7
    53ac:	08 c0       	rjmp	.+16     	; 0x53be <vfprintf+0x54e>
    53ae:	90 95       	com	r25
    53b0:	80 95       	com	r24
    53b2:	70 95       	com	r23
    53b4:	61 95       	neg	r22
    53b6:	7f 4f       	sbci	r23, 0xFF	; 255
    53b8:	8f 4f       	sbci	r24, 0xFF	; 255
    53ba:	9f 4f       	sbci	r25, 0xFF	; 255
    53bc:	00 68       	ori	r16, 0x80	; 128
    53be:	2a e0       	ldi	r18, 0x0A	; 10
    53c0:	30 e0       	ldi	r19, 0x00	; 0
    53c2:	a4 01       	movw	r20, r8
    53c4:	19 d3       	rcall	.+1586   	; 0x59f8 <__ultoa_invert>
    53c6:	c8 2e       	mov	r12, r24
    53c8:	c8 18       	sub	r12, r8
    53ca:	3d c0       	rjmp	.+122    	; 0x5446 <vfprintf+0x5d6>
    53cc:	02 2f       	mov	r16, r18
    53ce:	85 37       	cpi	r24, 0x75	; 117
    53d0:	21 f4       	brne	.+8      	; 0x53da <vfprintf+0x56a>
    53d2:	0f 7e       	andi	r16, 0xEF	; 239
    53d4:	2a e0       	ldi	r18, 0x0A	; 10
    53d6:	30 e0       	ldi	r19, 0x00	; 0
    53d8:	1d c0       	rjmp	.+58     	; 0x5414 <vfprintf+0x5a4>
    53da:	09 7f       	andi	r16, 0xF9	; 249
    53dc:	8f 36       	cpi	r24, 0x6F	; 111
    53de:	91 f0       	breq	.+36     	; 0x5404 <vfprintf+0x594>
    53e0:	18 f4       	brcc	.+6      	; 0x53e8 <vfprintf+0x578>
    53e2:	88 35       	cpi	r24, 0x58	; 88
    53e4:	59 f0       	breq	.+22     	; 0x53fc <vfprintf+0x58c>
    53e6:	a9 c0       	rjmp	.+338    	; 0x553a <vfprintf+0x6ca>
    53e8:	80 37       	cpi	r24, 0x70	; 112
    53ea:	19 f0       	breq	.+6      	; 0x53f2 <vfprintf+0x582>
    53ec:	88 37       	cpi	r24, 0x78	; 120
    53ee:	11 f0       	breq	.+4      	; 0x53f4 <vfprintf+0x584>
    53f0:	a4 c0       	rjmp	.+328    	; 0x553a <vfprintf+0x6ca>
    53f2:	00 61       	ori	r16, 0x10	; 16
    53f4:	04 ff       	sbrs	r16, 4
    53f6:	09 c0       	rjmp	.+18     	; 0x540a <vfprintf+0x59a>
    53f8:	04 60       	ori	r16, 0x04	; 4
    53fa:	07 c0       	rjmp	.+14     	; 0x540a <vfprintf+0x59a>
    53fc:	24 ff       	sbrs	r18, 4
    53fe:	08 c0       	rjmp	.+16     	; 0x5410 <vfprintf+0x5a0>
    5400:	06 60       	ori	r16, 0x06	; 6
    5402:	06 c0       	rjmp	.+12     	; 0x5410 <vfprintf+0x5a0>
    5404:	28 e0       	ldi	r18, 0x08	; 8
    5406:	30 e0       	ldi	r19, 0x00	; 0
    5408:	05 c0       	rjmp	.+10     	; 0x5414 <vfprintf+0x5a4>
    540a:	20 e1       	ldi	r18, 0x10	; 16
    540c:	30 e0       	ldi	r19, 0x00	; 0
    540e:	02 c0       	rjmp	.+4      	; 0x5414 <vfprintf+0x5a4>
    5410:	20 e1       	ldi	r18, 0x10	; 16
    5412:	32 e0       	ldi	r19, 0x02	; 2
    5414:	56 01       	movw	r10, r12
    5416:	07 ff       	sbrs	r16, 7
    5418:	09 c0       	rjmp	.+18     	; 0x542c <vfprintf+0x5bc>
    541a:	f4 e0       	ldi	r31, 0x04	; 4
    541c:	af 0e       	add	r10, r31
    541e:	b1 1c       	adc	r11, r1
    5420:	f6 01       	movw	r30, r12
    5422:	60 81       	ld	r22, Z
    5424:	71 81       	ldd	r23, Z+1	; 0x01
    5426:	82 81       	ldd	r24, Z+2	; 0x02
    5428:	93 81       	ldd	r25, Z+3	; 0x03
    542a:	08 c0       	rjmp	.+16     	; 0x543c <vfprintf+0x5cc>
    542c:	f2 e0       	ldi	r31, 0x02	; 2
    542e:	af 0e       	add	r10, r31
    5430:	b1 1c       	adc	r11, r1
    5432:	f6 01       	movw	r30, r12
    5434:	60 81       	ld	r22, Z
    5436:	71 81       	ldd	r23, Z+1	; 0x01
    5438:	80 e0       	ldi	r24, 0x00	; 0
    543a:	90 e0       	ldi	r25, 0x00	; 0
    543c:	a4 01       	movw	r20, r8
    543e:	dc d2       	rcall	.+1464   	; 0x59f8 <__ultoa_invert>
    5440:	c8 2e       	mov	r12, r24
    5442:	c8 18       	sub	r12, r8
    5444:	0f 77       	andi	r16, 0x7F	; 127
    5446:	06 ff       	sbrs	r16, 6
    5448:	0b c0       	rjmp	.+22     	; 0x5460 <vfprintf+0x5f0>
    544a:	20 2f       	mov	r18, r16
    544c:	2e 7f       	andi	r18, 0xFE	; 254
    544e:	c1 16       	cp	r12, r17
    5450:	50 f4       	brcc	.+20     	; 0x5466 <vfprintf+0x5f6>
    5452:	04 ff       	sbrs	r16, 4
    5454:	0a c0       	rjmp	.+20     	; 0x546a <vfprintf+0x5fa>
    5456:	02 fd       	sbrc	r16, 2
    5458:	08 c0       	rjmp	.+16     	; 0x546a <vfprintf+0x5fa>
    545a:	20 2f       	mov	r18, r16
    545c:	2e 7e       	andi	r18, 0xEE	; 238
    545e:	05 c0       	rjmp	.+10     	; 0x546a <vfprintf+0x5fa>
    5460:	dc 2c       	mov	r13, r12
    5462:	20 2f       	mov	r18, r16
    5464:	03 c0       	rjmp	.+6      	; 0x546c <vfprintf+0x5fc>
    5466:	dc 2c       	mov	r13, r12
    5468:	01 c0       	rjmp	.+2      	; 0x546c <vfprintf+0x5fc>
    546a:	d1 2e       	mov	r13, r17
    546c:	24 ff       	sbrs	r18, 4
    546e:	0d c0       	rjmp	.+26     	; 0x548a <vfprintf+0x61a>
    5470:	fe 01       	movw	r30, r28
    5472:	ec 0d       	add	r30, r12
    5474:	f1 1d       	adc	r31, r1
    5476:	80 81       	ld	r24, Z
    5478:	80 33       	cpi	r24, 0x30	; 48
    547a:	11 f4       	brne	.+4      	; 0x5480 <vfprintf+0x610>
    547c:	29 7e       	andi	r18, 0xE9	; 233
    547e:	09 c0       	rjmp	.+18     	; 0x5492 <vfprintf+0x622>
    5480:	22 ff       	sbrs	r18, 2
    5482:	06 c0       	rjmp	.+12     	; 0x5490 <vfprintf+0x620>
    5484:	d3 94       	inc	r13
    5486:	d3 94       	inc	r13
    5488:	04 c0       	rjmp	.+8      	; 0x5492 <vfprintf+0x622>
    548a:	82 2f       	mov	r24, r18
    548c:	86 78       	andi	r24, 0x86	; 134
    548e:	09 f0       	breq	.+2      	; 0x5492 <vfprintf+0x622>
    5490:	d3 94       	inc	r13
    5492:	23 fd       	sbrc	r18, 3
    5494:	12 c0       	rjmp	.+36     	; 0x54ba <vfprintf+0x64a>
    5496:	20 ff       	sbrs	r18, 0
    5498:	06 c0       	rjmp	.+12     	; 0x54a6 <vfprintf+0x636>
    549a:	1c 2d       	mov	r17, r12
    549c:	d5 14       	cp	r13, r5
    549e:	18 f4       	brcc	.+6      	; 0x54a6 <vfprintf+0x636>
    54a0:	15 0d       	add	r17, r5
    54a2:	1d 19       	sub	r17, r13
    54a4:	d5 2c       	mov	r13, r5
    54a6:	d5 14       	cp	r13, r5
    54a8:	60 f4       	brcc	.+24     	; 0x54c2 <vfprintf+0x652>
    54aa:	b7 01       	movw	r22, r14
    54ac:	80 e2       	ldi	r24, 0x20	; 32
    54ae:	90 e0       	ldi	r25, 0x00	; 0
    54b0:	2b 8b       	std	Y+19, r18	; 0x13
    54b2:	48 d2       	rcall	.+1168   	; 0x5944 <fputc>
    54b4:	d3 94       	inc	r13
    54b6:	2b 89       	ldd	r18, Y+19	; 0x13
    54b8:	f6 cf       	rjmp	.-20     	; 0x54a6 <vfprintf+0x636>
    54ba:	d5 14       	cp	r13, r5
    54bc:	10 f4       	brcc	.+4      	; 0x54c2 <vfprintf+0x652>
    54be:	5d 18       	sub	r5, r13
    54c0:	01 c0       	rjmp	.+2      	; 0x54c4 <vfprintf+0x654>
    54c2:	51 2c       	mov	r5, r1
    54c4:	24 ff       	sbrs	r18, 4
    54c6:	11 c0       	rjmp	.+34     	; 0x54ea <vfprintf+0x67a>
    54c8:	b7 01       	movw	r22, r14
    54ca:	80 e3       	ldi	r24, 0x30	; 48
    54cc:	90 e0       	ldi	r25, 0x00	; 0
    54ce:	2b 8b       	std	Y+19, r18	; 0x13
    54d0:	39 d2       	rcall	.+1138   	; 0x5944 <fputc>
    54d2:	2b 89       	ldd	r18, Y+19	; 0x13
    54d4:	22 ff       	sbrs	r18, 2
    54d6:	16 c0       	rjmp	.+44     	; 0x5504 <vfprintf+0x694>
    54d8:	21 ff       	sbrs	r18, 1
    54da:	03 c0       	rjmp	.+6      	; 0x54e2 <vfprintf+0x672>
    54dc:	88 e5       	ldi	r24, 0x58	; 88
    54de:	90 e0       	ldi	r25, 0x00	; 0
    54e0:	02 c0       	rjmp	.+4      	; 0x54e6 <vfprintf+0x676>
    54e2:	88 e7       	ldi	r24, 0x78	; 120
    54e4:	90 e0       	ldi	r25, 0x00	; 0
    54e6:	b7 01       	movw	r22, r14
    54e8:	0c c0       	rjmp	.+24     	; 0x5502 <vfprintf+0x692>
    54ea:	82 2f       	mov	r24, r18
    54ec:	86 78       	andi	r24, 0x86	; 134
    54ee:	51 f0       	breq	.+20     	; 0x5504 <vfprintf+0x694>
    54f0:	21 fd       	sbrc	r18, 1
    54f2:	02 c0       	rjmp	.+4      	; 0x54f8 <vfprintf+0x688>
    54f4:	80 e2       	ldi	r24, 0x20	; 32
    54f6:	01 c0       	rjmp	.+2      	; 0x54fa <vfprintf+0x68a>
    54f8:	8b e2       	ldi	r24, 0x2B	; 43
    54fa:	27 fd       	sbrc	r18, 7
    54fc:	8d e2       	ldi	r24, 0x2D	; 45
    54fe:	b7 01       	movw	r22, r14
    5500:	90 e0       	ldi	r25, 0x00	; 0
    5502:	20 d2       	rcall	.+1088   	; 0x5944 <fputc>
    5504:	c1 16       	cp	r12, r17
    5506:	30 f4       	brcc	.+12     	; 0x5514 <vfprintf+0x6a4>
    5508:	b7 01       	movw	r22, r14
    550a:	80 e3       	ldi	r24, 0x30	; 48
    550c:	90 e0       	ldi	r25, 0x00	; 0
    550e:	1a d2       	rcall	.+1076   	; 0x5944 <fputc>
    5510:	11 50       	subi	r17, 0x01	; 1
    5512:	f8 cf       	rjmp	.-16     	; 0x5504 <vfprintf+0x694>
    5514:	ca 94       	dec	r12
    5516:	f4 01       	movw	r30, r8
    5518:	ec 0d       	add	r30, r12
    551a:	f1 1d       	adc	r31, r1
    551c:	80 81       	ld	r24, Z
    551e:	b7 01       	movw	r22, r14
    5520:	90 e0       	ldi	r25, 0x00	; 0
    5522:	10 d2       	rcall	.+1056   	; 0x5944 <fputc>
    5524:	c1 10       	cpse	r12, r1
    5526:	f6 cf       	rjmp	.-20     	; 0x5514 <vfprintf+0x6a4>
    5528:	55 20       	and	r5, r5
    552a:	09 f4       	brne	.+2      	; 0x552e <vfprintf+0x6be>
    552c:	dd cc       	rjmp	.-1606   	; 0x4ee8 <vfprintf+0x78>
    552e:	b7 01       	movw	r22, r14
    5530:	80 e2       	ldi	r24, 0x20	; 32
    5532:	90 e0       	ldi	r25, 0x00	; 0
    5534:	07 d2       	rcall	.+1038   	; 0x5944 <fputc>
    5536:	5a 94       	dec	r5
    5538:	f7 cf       	rjmp	.-18     	; 0x5528 <vfprintf+0x6b8>
    553a:	f7 01       	movw	r30, r14
    553c:	86 81       	ldd	r24, Z+6	; 0x06
    553e:	97 81       	ldd	r25, Z+7	; 0x07
    5540:	02 c0       	rjmp	.+4      	; 0x5546 <vfprintf+0x6d6>
    5542:	8f ef       	ldi	r24, 0xFF	; 255
    5544:	9f ef       	ldi	r25, 0xFF	; 255
    5546:	63 96       	adiw	r28, 0x13	; 19
    5548:	cd bf       	out	0x3d, r28	; 61
    554a:	de bf       	out	0x3e, r29	; 62
    554c:	df 91       	pop	r29
    554e:	cf 91       	pop	r28
    5550:	1f 91       	pop	r17
    5552:	0f 91       	pop	r16
    5554:	ff 90       	pop	r15
    5556:	ef 90       	pop	r14
    5558:	df 90       	pop	r13
    555a:	cf 90       	pop	r12
    555c:	bf 90       	pop	r11
    555e:	af 90       	pop	r10
    5560:	9f 90       	pop	r9
    5562:	8f 90       	pop	r8
    5564:	7f 90       	pop	r7
    5566:	6f 90       	pop	r6
    5568:	5f 90       	pop	r5
    556a:	4f 90       	pop	r4
    556c:	3f 90       	pop	r3
    556e:	2f 90       	pop	r2
    5570:	08 95       	ret

00005572 <__divmodhi4>:
    5572:	97 fb       	bst	r25, 7
    5574:	07 2e       	mov	r0, r23
    5576:	16 f4       	brtc	.+4      	; 0x557c <__divmodhi4+0xa>
    5578:	00 94       	com	r0
    557a:	06 d0       	rcall	.+12     	; 0x5588 <__divmodhi4_neg1>
    557c:	77 fd       	sbrc	r23, 7
    557e:	08 d0       	rcall	.+16     	; 0x5590 <__divmodhi4_neg2>
    5580:	20 d0       	rcall	.+64     	; 0x55c2 <__udivmodhi4>
    5582:	07 fc       	sbrc	r0, 7
    5584:	05 d0       	rcall	.+10     	; 0x5590 <__divmodhi4_neg2>
    5586:	3e f4       	brtc	.+14     	; 0x5596 <__divmodhi4_exit>

00005588 <__divmodhi4_neg1>:
    5588:	90 95       	com	r25
    558a:	81 95       	neg	r24
    558c:	9f 4f       	sbci	r25, 0xFF	; 255
    558e:	08 95       	ret

00005590 <__divmodhi4_neg2>:
    5590:	70 95       	com	r23
    5592:	61 95       	neg	r22
    5594:	7f 4f       	sbci	r23, 0xFF	; 255

00005596 <__divmodhi4_exit>:
    5596:	08 95       	ret

00005598 <__tablejump2__>:
    5598:	ee 0f       	add	r30, r30
    559a:	ff 1f       	adc	r31, r31

0000559c <__tablejump__>:
    559c:	05 90       	lpm	r0, Z+
    559e:	f4 91       	lpm	r31, Z
    55a0:	e0 2d       	mov	r30, r0
    55a2:	19 94       	eijmp

000055a4 <__umulhisi3>:
    55a4:	a2 9f       	mul	r26, r18
    55a6:	b0 01       	movw	r22, r0
    55a8:	b3 9f       	mul	r27, r19
    55aa:	c0 01       	movw	r24, r0
    55ac:	a3 9f       	mul	r26, r19
    55ae:	70 0d       	add	r23, r0
    55b0:	81 1d       	adc	r24, r1
    55b2:	11 24       	eor	r1, r1
    55b4:	91 1d       	adc	r25, r1
    55b6:	b2 9f       	mul	r27, r18
    55b8:	70 0d       	add	r23, r0
    55ba:	81 1d       	adc	r24, r1
    55bc:	11 24       	eor	r1, r1
    55be:	91 1d       	adc	r25, r1
    55c0:	08 95       	ret

000055c2 <__udivmodhi4>:
    55c2:	aa 1b       	sub	r26, r26
    55c4:	bb 1b       	sub	r27, r27
    55c6:	51 e1       	ldi	r21, 0x11	; 17
    55c8:	07 c0       	rjmp	.+14     	; 0x55d8 <__udivmodhi4_ep>

000055ca <__udivmodhi4_loop>:
    55ca:	aa 1f       	adc	r26, r26
    55cc:	bb 1f       	adc	r27, r27
    55ce:	a6 17       	cp	r26, r22
    55d0:	b7 07       	cpc	r27, r23
    55d2:	10 f0       	brcs	.+4      	; 0x55d8 <__udivmodhi4_ep>
    55d4:	a6 1b       	sub	r26, r22
    55d6:	b7 0b       	sbc	r27, r23

000055d8 <__udivmodhi4_ep>:
    55d8:	88 1f       	adc	r24, r24
    55da:	99 1f       	adc	r25, r25
    55dc:	5a 95       	dec	r21
    55de:	a9 f7       	brne	.-22     	; 0x55ca <__udivmodhi4_loop>
    55e0:	80 95       	com	r24
    55e2:	90 95       	com	r25
    55e4:	bc 01       	movw	r22, r24
    55e6:	cd 01       	movw	r24, r26
    55e8:	08 95       	ret

000055ea <do_rand>:
    55ea:	8f 92       	push	r8
    55ec:	9f 92       	push	r9
    55ee:	af 92       	push	r10
    55f0:	bf 92       	push	r11
    55f2:	cf 92       	push	r12
    55f4:	df 92       	push	r13
    55f6:	ef 92       	push	r14
    55f8:	ff 92       	push	r15
    55fa:	cf 93       	push	r28
    55fc:	df 93       	push	r29
    55fe:	ec 01       	movw	r28, r24
    5600:	68 81       	ld	r22, Y
    5602:	79 81       	ldd	r23, Y+1	; 0x01
    5604:	8a 81       	ldd	r24, Y+2	; 0x02
    5606:	9b 81       	ldd	r25, Y+3	; 0x03
    5608:	61 15       	cp	r22, r1
    560a:	71 05       	cpc	r23, r1
    560c:	81 05       	cpc	r24, r1
    560e:	91 05       	cpc	r25, r1
    5610:	21 f4       	brne	.+8      	; 0x561a <do_rand+0x30>
    5612:	64 e2       	ldi	r22, 0x24	; 36
    5614:	79 ed       	ldi	r23, 0xD9	; 217
    5616:	8b e5       	ldi	r24, 0x5B	; 91
    5618:	97 e0       	ldi	r25, 0x07	; 7
    561a:	2d e1       	ldi	r18, 0x1D	; 29
    561c:	33 ef       	ldi	r19, 0xF3	; 243
    561e:	41 e0       	ldi	r20, 0x01	; 1
    5620:	50 e0       	ldi	r21, 0x00	; 0
    5622:	58 d2       	rcall	.+1200   	; 0x5ad4 <__divmodsi4>
    5624:	49 01       	movw	r8, r18
    5626:	5a 01       	movw	r10, r20
    5628:	9b 01       	movw	r18, r22
    562a:	ac 01       	movw	r20, r24
    562c:	a7 ea       	ldi	r26, 0xA7	; 167
    562e:	b1 e4       	ldi	r27, 0x41	; 65
    5630:	6d d2       	rcall	.+1242   	; 0x5b0c <__muluhisi3>
    5632:	6b 01       	movw	r12, r22
    5634:	7c 01       	movw	r14, r24
    5636:	ac ee       	ldi	r26, 0xEC	; 236
    5638:	b4 ef       	ldi	r27, 0xF4	; 244
    563a:	a5 01       	movw	r20, r10
    563c:	94 01       	movw	r18, r8
    563e:	72 d2       	rcall	.+1252   	; 0x5b24 <__mulohisi3>
    5640:	c6 0e       	add	r12, r22
    5642:	d7 1e       	adc	r13, r23
    5644:	e8 1e       	adc	r14, r24
    5646:	f9 1e       	adc	r15, r25
    5648:	f7 fe       	sbrs	r15, 7
    564a:	06 c0       	rjmp	.+12     	; 0x5658 <do_rand+0x6e>
    564c:	81 e0       	ldi	r24, 0x01	; 1
    564e:	c8 1a       	sub	r12, r24
    5650:	d1 08       	sbc	r13, r1
    5652:	e1 08       	sbc	r14, r1
    5654:	80 e8       	ldi	r24, 0x80	; 128
    5656:	f8 0a       	sbc	r15, r24
    5658:	c8 82       	st	Y, r12
    565a:	d9 82       	std	Y+1, r13	; 0x01
    565c:	ea 82       	std	Y+2, r14	; 0x02
    565e:	fb 82       	std	Y+3, r15	; 0x03
    5660:	c6 01       	movw	r24, r12
    5662:	9f 77       	andi	r25, 0x7F	; 127
    5664:	df 91       	pop	r29
    5666:	cf 91       	pop	r28
    5668:	ff 90       	pop	r15
    566a:	ef 90       	pop	r14
    566c:	df 90       	pop	r13
    566e:	cf 90       	pop	r12
    5670:	bf 90       	pop	r11
    5672:	af 90       	pop	r10
    5674:	9f 90       	pop	r9
    5676:	8f 90       	pop	r8
    5678:	08 95       	ret

0000567a <rand_r>:
    567a:	b7 cf       	rjmp	.-146    	; 0x55ea <do_rand>

0000567c <rand>:
    567c:	80 e0       	ldi	r24, 0x00	; 0
    567e:	90 e2       	ldi	r25, 0x20	; 32
    5680:	b4 cf       	rjmp	.-152    	; 0x55ea <do_rand>

00005682 <srand>:
    5682:	a0 e0       	ldi	r26, 0x00	; 0
    5684:	b0 e0       	ldi	r27, 0x00	; 0
    5686:	80 93 00 20 	sts	0x2000, r24
    568a:	90 93 01 20 	sts	0x2001, r25
    568e:	a0 93 02 20 	sts	0x2002, r26
    5692:	b0 93 03 20 	sts	0x2003, r27
    5696:	08 95       	ret

00005698 <__ftoa_engine>:
    5698:	28 30       	cpi	r18, 0x08	; 8
    569a:	08 f0       	brcs	.+2      	; 0x569e <__ftoa_engine+0x6>
    569c:	27 e0       	ldi	r18, 0x07	; 7
    569e:	33 27       	eor	r19, r19
    56a0:	da 01       	movw	r26, r20
    56a2:	99 0f       	add	r25, r25
    56a4:	31 1d       	adc	r19, r1
    56a6:	87 fd       	sbrc	r24, 7
    56a8:	91 60       	ori	r25, 0x01	; 1
    56aa:	00 96       	adiw	r24, 0x00	; 0
    56ac:	61 05       	cpc	r22, r1
    56ae:	71 05       	cpc	r23, r1
    56b0:	39 f4       	brne	.+14     	; 0x56c0 <__ftoa_engine+0x28>
    56b2:	32 60       	ori	r19, 0x02	; 2
    56b4:	2e 5f       	subi	r18, 0xFE	; 254
    56b6:	3d 93       	st	X+, r19
    56b8:	30 e3       	ldi	r19, 0x30	; 48
    56ba:	2a 95       	dec	r18
    56bc:	e1 f7       	brne	.-8      	; 0x56b6 <__ftoa_engine+0x1e>
    56be:	08 95       	ret
    56c0:	9f 3f       	cpi	r25, 0xFF	; 255
    56c2:	30 f0       	brcs	.+12     	; 0x56d0 <__ftoa_engine+0x38>
    56c4:	80 38       	cpi	r24, 0x80	; 128
    56c6:	71 05       	cpc	r23, r1
    56c8:	61 05       	cpc	r22, r1
    56ca:	09 f0       	breq	.+2      	; 0x56ce <__ftoa_engine+0x36>
    56cc:	3c 5f       	subi	r19, 0xFC	; 252
    56ce:	3c 5f       	subi	r19, 0xFC	; 252
    56d0:	3d 93       	st	X+, r19
    56d2:	91 30       	cpi	r25, 0x01	; 1
    56d4:	08 f0       	brcs	.+2      	; 0x56d8 <__ftoa_engine+0x40>
    56d6:	80 68       	ori	r24, 0x80	; 128
    56d8:	91 1d       	adc	r25, r1
    56da:	df 93       	push	r29
    56dc:	cf 93       	push	r28
    56de:	1f 93       	push	r17
    56e0:	0f 93       	push	r16
    56e2:	ff 92       	push	r15
    56e4:	ef 92       	push	r14
    56e6:	19 2f       	mov	r17, r25
    56e8:	98 7f       	andi	r25, 0xF8	; 248
    56ea:	96 95       	lsr	r25
    56ec:	e9 2f       	mov	r30, r25
    56ee:	96 95       	lsr	r25
    56f0:	96 95       	lsr	r25
    56f2:	e9 0f       	add	r30, r25
    56f4:	ff 27       	eor	r31, r31
    56f6:	e4 59       	subi	r30, 0x94	; 148
    56f8:	f9 4f       	sbci	r31, 0xF9	; 249
    56fa:	99 27       	eor	r25, r25
    56fc:	33 27       	eor	r19, r19
    56fe:	ee 24       	eor	r14, r14
    5700:	ff 24       	eor	r15, r15
    5702:	a7 01       	movw	r20, r14
    5704:	e7 01       	movw	r28, r14
    5706:	05 90       	lpm	r0, Z+
    5708:	08 94       	sec
    570a:	07 94       	ror	r0
    570c:	28 f4       	brcc	.+10     	; 0x5718 <__ftoa_engine+0x80>
    570e:	36 0f       	add	r19, r22
    5710:	e7 1e       	adc	r14, r23
    5712:	f8 1e       	adc	r15, r24
    5714:	49 1f       	adc	r20, r25
    5716:	51 1d       	adc	r21, r1
    5718:	66 0f       	add	r22, r22
    571a:	77 1f       	adc	r23, r23
    571c:	88 1f       	adc	r24, r24
    571e:	99 1f       	adc	r25, r25
    5720:	06 94       	lsr	r0
    5722:	a1 f7       	brne	.-24     	; 0x570c <__ftoa_engine+0x74>
    5724:	05 90       	lpm	r0, Z+
    5726:	07 94       	ror	r0
    5728:	28 f4       	brcc	.+10     	; 0x5734 <__ftoa_engine+0x9c>
    572a:	e7 0e       	add	r14, r23
    572c:	f8 1e       	adc	r15, r24
    572e:	49 1f       	adc	r20, r25
    5730:	56 1f       	adc	r21, r22
    5732:	c1 1d       	adc	r28, r1
    5734:	77 0f       	add	r23, r23
    5736:	88 1f       	adc	r24, r24
    5738:	99 1f       	adc	r25, r25
    573a:	66 1f       	adc	r22, r22
    573c:	06 94       	lsr	r0
    573e:	a1 f7       	brne	.-24     	; 0x5728 <__ftoa_engine+0x90>
    5740:	05 90       	lpm	r0, Z+
    5742:	07 94       	ror	r0
    5744:	28 f4       	brcc	.+10     	; 0x5750 <__ftoa_engine+0xb8>
    5746:	f8 0e       	add	r15, r24
    5748:	49 1f       	adc	r20, r25
    574a:	56 1f       	adc	r21, r22
    574c:	c7 1f       	adc	r28, r23
    574e:	d1 1d       	adc	r29, r1
    5750:	88 0f       	add	r24, r24
    5752:	99 1f       	adc	r25, r25
    5754:	66 1f       	adc	r22, r22
    5756:	77 1f       	adc	r23, r23
    5758:	06 94       	lsr	r0
    575a:	a1 f7       	brne	.-24     	; 0x5744 <__ftoa_engine+0xac>
    575c:	05 90       	lpm	r0, Z+
    575e:	07 94       	ror	r0
    5760:	20 f4       	brcc	.+8      	; 0x576a <__ftoa_engine+0xd2>
    5762:	49 0f       	add	r20, r25
    5764:	56 1f       	adc	r21, r22
    5766:	c7 1f       	adc	r28, r23
    5768:	d8 1f       	adc	r29, r24
    576a:	99 0f       	add	r25, r25
    576c:	66 1f       	adc	r22, r22
    576e:	77 1f       	adc	r23, r23
    5770:	88 1f       	adc	r24, r24
    5772:	06 94       	lsr	r0
    5774:	a9 f7       	brne	.-22     	; 0x5760 <__ftoa_engine+0xc8>
    5776:	84 91       	lpm	r24, Z
    5778:	10 95       	com	r17
    577a:	17 70       	andi	r17, 0x07	; 7
    577c:	41 f0       	breq	.+16     	; 0x578e <__ftoa_engine+0xf6>
    577e:	d6 95       	lsr	r29
    5780:	c7 95       	ror	r28
    5782:	57 95       	ror	r21
    5784:	47 95       	ror	r20
    5786:	f7 94       	ror	r15
    5788:	e7 94       	ror	r14
    578a:	1a 95       	dec	r17
    578c:	c1 f7       	brne	.-16     	; 0x577e <__ftoa_engine+0xe6>
    578e:	e2 e1       	ldi	r30, 0x12	; 18
    5790:	f6 e0       	ldi	r31, 0x06	; 6
    5792:	68 94       	set
    5794:	15 90       	lpm	r1, Z+
    5796:	15 91       	lpm	r17, Z+
    5798:	35 91       	lpm	r19, Z+
    579a:	65 91       	lpm	r22, Z+
    579c:	95 91       	lpm	r25, Z+
    579e:	05 90       	lpm	r0, Z+
    57a0:	7f e2       	ldi	r23, 0x2F	; 47
    57a2:	73 95       	inc	r23
    57a4:	e1 18       	sub	r14, r1
    57a6:	f1 0a       	sbc	r15, r17
    57a8:	43 0b       	sbc	r20, r19
    57aa:	56 0b       	sbc	r21, r22
    57ac:	c9 0b       	sbc	r28, r25
    57ae:	d0 09       	sbc	r29, r0
    57b0:	c0 f7       	brcc	.-16     	; 0x57a2 <__ftoa_engine+0x10a>
    57b2:	e1 0c       	add	r14, r1
    57b4:	f1 1e       	adc	r15, r17
    57b6:	43 1f       	adc	r20, r19
    57b8:	56 1f       	adc	r21, r22
    57ba:	c9 1f       	adc	r28, r25
    57bc:	d0 1d       	adc	r29, r0
    57be:	7e f4       	brtc	.+30     	; 0x57de <__ftoa_engine+0x146>
    57c0:	70 33       	cpi	r23, 0x30	; 48
    57c2:	11 f4       	brne	.+4      	; 0x57c8 <__ftoa_engine+0x130>
    57c4:	8a 95       	dec	r24
    57c6:	e6 cf       	rjmp	.-52     	; 0x5794 <__ftoa_engine+0xfc>
    57c8:	e8 94       	clt
    57ca:	01 50       	subi	r16, 0x01	; 1
    57cc:	30 f0       	brcs	.+12     	; 0x57da <__ftoa_engine+0x142>
    57ce:	08 0f       	add	r16, r24
    57d0:	0a f4       	brpl	.+2      	; 0x57d4 <__ftoa_engine+0x13c>
    57d2:	00 27       	eor	r16, r16
    57d4:	02 17       	cp	r16, r18
    57d6:	08 f4       	brcc	.+2      	; 0x57da <__ftoa_engine+0x142>
    57d8:	20 2f       	mov	r18, r16
    57da:	23 95       	inc	r18
    57dc:	02 2f       	mov	r16, r18
    57de:	7a 33       	cpi	r23, 0x3A	; 58
    57e0:	28 f0       	brcs	.+10     	; 0x57ec <__ftoa_engine+0x154>
    57e2:	79 e3       	ldi	r23, 0x39	; 57
    57e4:	7d 93       	st	X+, r23
    57e6:	2a 95       	dec	r18
    57e8:	e9 f7       	brne	.-6      	; 0x57e4 <__ftoa_engine+0x14c>
    57ea:	10 c0       	rjmp	.+32     	; 0x580c <__ftoa_engine+0x174>
    57ec:	7d 93       	st	X+, r23
    57ee:	2a 95       	dec	r18
    57f0:	89 f6       	brne	.-94     	; 0x5794 <__ftoa_engine+0xfc>
    57f2:	06 94       	lsr	r0
    57f4:	97 95       	ror	r25
    57f6:	67 95       	ror	r22
    57f8:	37 95       	ror	r19
    57fa:	17 95       	ror	r17
    57fc:	17 94       	ror	r1
    57fe:	e1 18       	sub	r14, r1
    5800:	f1 0a       	sbc	r15, r17
    5802:	43 0b       	sbc	r20, r19
    5804:	56 0b       	sbc	r21, r22
    5806:	c9 0b       	sbc	r28, r25
    5808:	d0 09       	sbc	r29, r0
    580a:	98 f0       	brcs	.+38     	; 0x5832 <__ftoa_engine+0x19a>
    580c:	23 95       	inc	r18
    580e:	7e 91       	ld	r23, -X
    5810:	73 95       	inc	r23
    5812:	7a 33       	cpi	r23, 0x3A	; 58
    5814:	08 f0       	brcs	.+2      	; 0x5818 <__ftoa_engine+0x180>
    5816:	70 e3       	ldi	r23, 0x30	; 48
    5818:	7c 93       	st	X, r23
    581a:	20 13       	cpse	r18, r16
    581c:	b8 f7       	brcc	.-18     	; 0x580c <__ftoa_engine+0x174>
    581e:	7e 91       	ld	r23, -X
    5820:	70 61       	ori	r23, 0x10	; 16
    5822:	7d 93       	st	X+, r23
    5824:	30 f0       	brcs	.+12     	; 0x5832 <__ftoa_engine+0x19a>
    5826:	83 95       	inc	r24
    5828:	71 e3       	ldi	r23, 0x31	; 49
    582a:	7d 93       	st	X+, r23
    582c:	70 e3       	ldi	r23, 0x30	; 48
    582e:	2a 95       	dec	r18
    5830:	e1 f7       	brne	.-8      	; 0x582a <__ftoa_engine+0x192>
    5832:	11 24       	eor	r1, r1
    5834:	ef 90       	pop	r14
    5836:	ff 90       	pop	r15
    5838:	0f 91       	pop	r16
    583a:	1f 91       	pop	r17
    583c:	cf 91       	pop	r28
    583e:	df 91       	pop	r29
    5840:	99 27       	eor	r25, r25
    5842:	87 fd       	sbrc	r24, 7
    5844:	90 95       	com	r25
    5846:	08 95       	ret

00005848 <strnlen_P>:
    5848:	fc 01       	movw	r30, r24
    584a:	05 90       	lpm	r0, Z+
    584c:	61 50       	subi	r22, 0x01	; 1
    584e:	70 40       	sbci	r23, 0x00	; 0
    5850:	01 10       	cpse	r0, r1
    5852:	d8 f7       	brcc	.-10     	; 0x584a <strnlen_P+0x2>
    5854:	80 95       	com	r24
    5856:	90 95       	com	r25
    5858:	8e 0f       	add	r24, r30
    585a:	9f 1f       	adc	r25, r31
    585c:	08 95       	ret

0000585e <memcmp>:
    585e:	fb 01       	movw	r30, r22
    5860:	dc 01       	movw	r26, r24
    5862:	04 c0       	rjmp	.+8      	; 0x586c <memcmp+0xe>
    5864:	8d 91       	ld	r24, X+
    5866:	01 90       	ld	r0, Z+
    5868:	80 19       	sub	r24, r0
    586a:	21 f4       	brne	.+8      	; 0x5874 <memcmp+0x16>
    586c:	41 50       	subi	r20, 0x01	; 1
    586e:	50 40       	sbci	r21, 0x00	; 0
    5870:	c8 f7       	brcc	.-14     	; 0x5864 <memcmp+0x6>
    5872:	88 1b       	sub	r24, r24
    5874:	99 0b       	sbc	r25, r25
    5876:	08 95       	ret

00005878 <memcpy>:
    5878:	fb 01       	movw	r30, r22
    587a:	dc 01       	movw	r26, r24
    587c:	02 c0       	rjmp	.+4      	; 0x5882 <memcpy+0xa>
    587e:	01 90       	ld	r0, Z+
    5880:	0d 92       	st	X+, r0
    5882:	41 50       	subi	r20, 0x01	; 1
    5884:	50 40       	sbci	r21, 0x00	; 0
    5886:	d8 f7       	brcc	.-10     	; 0x587e <memcpy+0x6>
    5888:	08 95       	ret

0000588a <memset>:
    588a:	dc 01       	movw	r26, r24
    588c:	01 c0       	rjmp	.+2      	; 0x5890 <memset+0x6>
    588e:	6d 93       	st	X+, r22
    5890:	41 50       	subi	r20, 0x01	; 1
    5892:	50 40       	sbci	r21, 0x00	; 0
    5894:	e0 f7       	brcc	.-8      	; 0x588e <memset+0x4>
    5896:	08 95       	ret

00005898 <strcat>:
    5898:	fb 01       	movw	r30, r22
    589a:	dc 01       	movw	r26, r24
    589c:	0d 90       	ld	r0, X+
    589e:	00 20       	and	r0, r0
    58a0:	e9 f7       	brne	.-6      	; 0x589c <strcat+0x4>
    58a2:	11 97       	sbiw	r26, 0x01	; 1
    58a4:	01 90       	ld	r0, Z+
    58a6:	0d 92       	st	X+, r0
    58a8:	00 20       	and	r0, r0
    58aa:	e1 f7       	brne	.-8      	; 0x58a4 <strcat+0xc>
    58ac:	08 95       	ret

000058ae <strncmp>:
    58ae:	fb 01       	movw	r30, r22
    58b0:	dc 01       	movw	r26, r24
    58b2:	41 50       	subi	r20, 0x01	; 1
    58b4:	50 40       	sbci	r21, 0x00	; 0
    58b6:	30 f0       	brcs	.+12     	; 0x58c4 <strncmp+0x16>
    58b8:	8d 91       	ld	r24, X+
    58ba:	01 90       	ld	r0, Z+
    58bc:	80 19       	sub	r24, r0
    58be:	19 f4       	brne	.+6      	; 0x58c6 <strncmp+0x18>
    58c0:	00 20       	and	r0, r0
    58c2:	b9 f7       	brne	.-18     	; 0x58b2 <strncmp+0x4>
    58c4:	88 1b       	sub	r24, r24
    58c6:	99 0b       	sbc	r25, r25
    58c8:	08 95       	ret

000058ca <strncpy>:
    58ca:	fb 01       	movw	r30, r22
    58cc:	dc 01       	movw	r26, r24
    58ce:	41 50       	subi	r20, 0x01	; 1
    58d0:	50 40       	sbci	r21, 0x00	; 0
    58d2:	48 f0       	brcs	.+18     	; 0x58e6 <strncpy+0x1c>
    58d4:	01 90       	ld	r0, Z+
    58d6:	0d 92       	st	X+, r0
    58d8:	00 20       	and	r0, r0
    58da:	c9 f7       	brne	.-14     	; 0x58ce <strncpy+0x4>
    58dc:	01 c0       	rjmp	.+2      	; 0x58e0 <strncpy+0x16>
    58de:	1d 92       	st	X+, r1
    58e0:	41 50       	subi	r20, 0x01	; 1
    58e2:	50 40       	sbci	r21, 0x00	; 0
    58e4:	e0 f7       	brcc	.-8      	; 0x58de <strncpy+0x14>
    58e6:	08 95       	ret

000058e8 <strnlen>:
    58e8:	fc 01       	movw	r30, r24
    58ea:	61 50       	subi	r22, 0x01	; 1
    58ec:	70 40       	sbci	r23, 0x00	; 0
    58ee:	01 90       	ld	r0, Z+
    58f0:	01 10       	cpse	r0, r1
    58f2:	d8 f7       	brcc	.-10     	; 0x58ea <strnlen+0x2>
    58f4:	80 95       	com	r24
    58f6:	90 95       	com	r25
    58f8:	8e 0f       	add	r24, r30
    58fa:	9f 1f       	adc	r25, r31
    58fc:	08 95       	ret

000058fe <__itoa_ncheck>:
    58fe:	bb 27       	eor	r27, r27
    5900:	4a 30       	cpi	r20, 0x0A	; 10
    5902:	31 f4       	brne	.+12     	; 0x5910 <__itoa_ncheck+0x12>
    5904:	99 23       	and	r25, r25
    5906:	22 f4       	brpl	.+8      	; 0x5910 <__itoa_ncheck+0x12>
    5908:	bd e2       	ldi	r27, 0x2D	; 45
    590a:	90 95       	com	r25
    590c:	81 95       	neg	r24
    590e:	9f 4f       	sbci	r25, 0xFF	; 255
    5910:	01 c0       	rjmp	.+2      	; 0x5914 <__utoa_common>

00005912 <__utoa_ncheck>:
    5912:	bb 27       	eor	r27, r27

00005914 <__utoa_common>:
    5914:	fb 01       	movw	r30, r22
    5916:	55 27       	eor	r21, r21
    5918:	aa 27       	eor	r26, r26
    591a:	88 0f       	add	r24, r24
    591c:	99 1f       	adc	r25, r25
    591e:	aa 1f       	adc	r26, r26
    5920:	a4 17       	cp	r26, r20
    5922:	10 f0       	brcs	.+4      	; 0x5928 <__utoa_common+0x14>
    5924:	a4 1b       	sub	r26, r20
    5926:	83 95       	inc	r24
    5928:	50 51       	subi	r21, 0x10	; 16
    592a:	b9 f7       	brne	.-18     	; 0x591a <__utoa_common+0x6>
    592c:	a0 5d       	subi	r26, 0xD0	; 208
    592e:	aa 33       	cpi	r26, 0x3A	; 58
    5930:	08 f0       	brcs	.+2      	; 0x5934 <__utoa_common+0x20>
    5932:	a9 5d       	subi	r26, 0xD9	; 217
    5934:	a1 93       	st	Z+, r26
    5936:	00 97       	sbiw	r24, 0x00	; 0
    5938:	79 f7       	brne	.-34     	; 0x5918 <__utoa_common+0x4>
    593a:	b1 11       	cpse	r27, r1
    593c:	b1 93       	st	Z+, r27
    593e:	11 92       	st	Z+, r1
    5940:	cb 01       	movw	r24, r22
    5942:	b8 c0       	rjmp	.+368    	; 0x5ab4 <strrev>

00005944 <fputc>:
    5944:	0f 93       	push	r16
    5946:	1f 93       	push	r17
    5948:	cf 93       	push	r28
    594a:	df 93       	push	r29
    594c:	18 2f       	mov	r17, r24
    594e:	09 2f       	mov	r16, r25
    5950:	eb 01       	movw	r28, r22
    5952:	8b 81       	ldd	r24, Y+3	; 0x03
    5954:	81 fd       	sbrc	r24, 1
    5956:	03 c0       	rjmp	.+6      	; 0x595e <fputc+0x1a>
    5958:	8f ef       	ldi	r24, 0xFF	; 255
    595a:	9f ef       	ldi	r25, 0xFF	; 255
    595c:	20 c0       	rjmp	.+64     	; 0x599e <fputc+0x5a>
    595e:	82 ff       	sbrs	r24, 2
    5960:	10 c0       	rjmp	.+32     	; 0x5982 <fputc+0x3e>
    5962:	4e 81       	ldd	r20, Y+6	; 0x06
    5964:	5f 81       	ldd	r21, Y+7	; 0x07
    5966:	2c 81       	ldd	r18, Y+4	; 0x04
    5968:	3d 81       	ldd	r19, Y+5	; 0x05
    596a:	42 17       	cp	r20, r18
    596c:	53 07       	cpc	r21, r19
    596e:	7c f4       	brge	.+30     	; 0x598e <fputc+0x4a>
    5970:	e8 81       	ld	r30, Y
    5972:	f9 81       	ldd	r31, Y+1	; 0x01
    5974:	9f 01       	movw	r18, r30
    5976:	2f 5f       	subi	r18, 0xFF	; 255
    5978:	3f 4f       	sbci	r19, 0xFF	; 255
    597a:	28 83       	st	Y, r18
    597c:	39 83       	std	Y+1, r19	; 0x01
    597e:	10 83       	st	Z, r17
    5980:	06 c0       	rjmp	.+12     	; 0x598e <fputc+0x4a>
    5982:	e8 85       	ldd	r30, Y+8	; 0x08
    5984:	f9 85       	ldd	r31, Y+9	; 0x09
    5986:	81 2f       	mov	r24, r17
    5988:	19 95       	eicall
    598a:	89 2b       	or	r24, r25
    598c:	29 f7       	brne	.-54     	; 0x5958 <fputc+0x14>
    598e:	2e 81       	ldd	r18, Y+6	; 0x06
    5990:	3f 81       	ldd	r19, Y+7	; 0x07
    5992:	2f 5f       	subi	r18, 0xFF	; 255
    5994:	3f 4f       	sbci	r19, 0xFF	; 255
    5996:	2e 83       	std	Y+6, r18	; 0x06
    5998:	3f 83       	std	Y+7, r19	; 0x07
    599a:	81 2f       	mov	r24, r17
    599c:	90 2f       	mov	r25, r16
    599e:	df 91       	pop	r29
    59a0:	cf 91       	pop	r28
    59a2:	1f 91       	pop	r17
    59a4:	0f 91       	pop	r16
    59a6:	08 95       	ret

000059a8 <sprintf>:
    59a8:	0f 93       	push	r16
    59aa:	1f 93       	push	r17
    59ac:	cf 93       	push	r28
    59ae:	df 93       	push	r29
    59b0:	cd b7       	in	r28, 0x3d	; 61
    59b2:	de b7       	in	r29, 0x3e	; 62
    59b4:	2e 97       	sbiw	r28, 0x0e	; 14
    59b6:	cd bf       	out	0x3d, r28	; 61
    59b8:	de bf       	out	0x3e, r29	; 62
    59ba:	0e 89       	ldd	r16, Y+22	; 0x16
    59bc:	1f 89       	ldd	r17, Y+23	; 0x17
    59be:	86 e0       	ldi	r24, 0x06	; 6
    59c0:	8c 83       	std	Y+4, r24	; 0x04
    59c2:	09 83       	std	Y+1, r16	; 0x01
    59c4:	1a 83       	std	Y+2, r17	; 0x02
    59c6:	8f ef       	ldi	r24, 0xFF	; 255
    59c8:	9f e7       	ldi	r25, 0x7F	; 127
    59ca:	8d 83       	std	Y+5, r24	; 0x05
    59cc:	9e 83       	std	Y+6, r25	; 0x06
    59ce:	ae 01       	movw	r20, r28
    59d0:	46 5e       	subi	r20, 0xE6	; 230
    59d2:	5f 4f       	sbci	r21, 0xFF	; 255
    59d4:	68 8d       	ldd	r22, Y+24	; 0x18
    59d6:	79 8d       	ldd	r23, Y+25	; 0x19
    59d8:	ce 01       	movw	r24, r28
    59da:	01 96       	adiw	r24, 0x01	; 1
    59dc:	49 da       	rcall	.-2926   	; 0x4e70 <vfprintf>
    59de:	ef 81       	ldd	r30, Y+7	; 0x07
    59e0:	f8 85       	ldd	r31, Y+8	; 0x08
    59e2:	e0 0f       	add	r30, r16
    59e4:	f1 1f       	adc	r31, r17
    59e6:	10 82       	st	Z, r1
    59e8:	2e 96       	adiw	r28, 0x0e	; 14
    59ea:	cd bf       	out	0x3d, r28	; 61
    59ec:	de bf       	out	0x3e, r29	; 62
    59ee:	df 91       	pop	r29
    59f0:	cf 91       	pop	r28
    59f2:	1f 91       	pop	r17
    59f4:	0f 91       	pop	r16
    59f6:	08 95       	ret

000059f8 <__ultoa_invert>:
    59f8:	fa 01       	movw	r30, r20
    59fa:	aa 27       	eor	r26, r26
    59fc:	28 30       	cpi	r18, 0x08	; 8
    59fe:	51 f1       	breq	.+84     	; 0x5a54 <__ultoa_invert+0x5c>
    5a00:	20 31       	cpi	r18, 0x10	; 16
    5a02:	81 f1       	breq	.+96     	; 0x5a64 <__ultoa_invert+0x6c>
    5a04:	e8 94       	clt
    5a06:	6f 93       	push	r22
    5a08:	6e 7f       	andi	r22, 0xFE	; 254
    5a0a:	6e 5f       	subi	r22, 0xFE	; 254
    5a0c:	7f 4f       	sbci	r23, 0xFF	; 255
    5a0e:	8f 4f       	sbci	r24, 0xFF	; 255
    5a10:	9f 4f       	sbci	r25, 0xFF	; 255
    5a12:	af 4f       	sbci	r26, 0xFF	; 255
    5a14:	b1 e0       	ldi	r27, 0x01	; 1
    5a16:	3e d0       	rcall	.+124    	; 0x5a94 <__ultoa_invert+0x9c>
    5a18:	b4 e0       	ldi	r27, 0x04	; 4
    5a1a:	3c d0       	rcall	.+120    	; 0x5a94 <__ultoa_invert+0x9c>
    5a1c:	67 0f       	add	r22, r23
    5a1e:	78 1f       	adc	r23, r24
    5a20:	89 1f       	adc	r24, r25
    5a22:	9a 1f       	adc	r25, r26
    5a24:	a1 1d       	adc	r26, r1
    5a26:	68 0f       	add	r22, r24
    5a28:	79 1f       	adc	r23, r25
    5a2a:	8a 1f       	adc	r24, r26
    5a2c:	91 1d       	adc	r25, r1
    5a2e:	a1 1d       	adc	r26, r1
    5a30:	6a 0f       	add	r22, r26
    5a32:	71 1d       	adc	r23, r1
    5a34:	81 1d       	adc	r24, r1
    5a36:	91 1d       	adc	r25, r1
    5a38:	a1 1d       	adc	r26, r1
    5a3a:	20 d0       	rcall	.+64     	; 0x5a7c <__ultoa_invert+0x84>
    5a3c:	09 f4       	brne	.+2      	; 0x5a40 <__ultoa_invert+0x48>
    5a3e:	68 94       	set
    5a40:	3f 91       	pop	r19
    5a42:	2a e0       	ldi	r18, 0x0A	; 10
    5a44:	26 9f       	mul	r18, r22
    5a46:	11 24       	eor	r1, r1
    5a48:	30 19       	sub	r19, r0
    5a4a:	30 5d       	subi	r19, 0xD0	; 208
    5a4c:	31 93       	st	Z+, r19
    5a4e:	de f6       	brtc	.-74     	; 0x5a06 <__ultoa_invert+0xe>
    5a50:	cf 01       	movw	r24, r30
    5a52:	08 95       	ret
    5a54:	46 2f       	mov	r20, r22
    5a56:	47 70       	andi	r20, 0x07	; 7
    5a58:	40 5d       	subi	r20, 0xD0	; 208
    5a5a:	41 93       	st	Z+, r20
    5a5c:	b3 e0       	ldi	r27, 0x03	; 3
    5a5e:	0f d0       	rcall	.+30     	; 0x5a7e <__ultoa_invert+0x86>
    5a60:	c9 f7       	brne	.-14     	; 0x5a54 <__ultoa_invert+0x5c>
    5a62:	f6 cf       	rjmp	.-20     	; 0x5a50 <__ultoa_invert+0x58>
    5a64:	46 2f       	mov	r20, r22
    5a66:	4f 70       	andi	r20, 0x0F	; 15
    5a68:	40 5d       	subi	r20, 0xD0	; 208
    5a6a:	4a 33       	cpi	r20, 0x3A	; 58
    5a6c:	18 f0       	brcs	.+6      	; 0x5a74 <__ultoa_invert+0x7c>
    5a6e:	49 5d       	subi	r20, 0xD9	; 217
    5a70:	31 fd       	sbrc	r19, 1
    5a72:	40 52       	subi	r20, 0x20	; 32
    5a74:	41 93       	st	Z+, r20
    5a76:	02 d0       	rcall	.+4      	; 0x5a7c <__ultoa_invert+0x84>
    5a78:	a9 f7       	brne	.-22     	; 0x5a64 <__ultoa_invert+0x6c>
    5a7a:	ea cf       	rjmp	.-44     	; 0x5a50 <__ultoa_invert+0x58>
    5a7c:	b4 e0       	ldi	r27, 0x04	; 4
    5a7e:	a6 95       	lsr	r26
    5a80:	97 95       	ror	r25
    5a82:	87 95       	ror	r24
    5a84:	77 95       	ror	r23
    5a86:	67 95       	ror	r22
    5a88:	ba 95       	dec	r27
    5a8a:	c9 f7       	brne	.-14     	; 0x5a7e <__ultoa_invert+0x86>
    5a8c:	00 97       	sbiw	r24, 0x00	; 0
    5a8e:	61 05       	cpc	r22, r1
    5a90:	71 05       	cpc	r23, r1
    5a92:	08 95       	ret
    5a94:	9b 01       	movw	r18, r22
    5a96:	ac 01       	movw	r20, r24
    5a98:	0a 2e       	mov	r0, r26
    5a9a:	06 94       	lsr	r0
    5a9c:	57 95       	ror	r21
    5a9e:	47 95       	ror	r20
    5aa0:	37 95       	ror	r19
    5aa2:	27 95       	ror	r18
    5aa4:	ba 95       	dec	r27
    5aa6:	c9 f7       	brne	.-14     	; 0x5a9a <__ultoa_invert+0xa2>
    5aa8:	62 0f       	add	r22, r18
    5aaa:	73 1f       	adc	r23, r19
    5aac:	84 1f       	adc	r24, r20
    5aae:	95 1f       	adc	r25, r21
    5ab0:	a0 1d       	adc	r26, r0
    5ab2:	08 95       	ret

00005ab4 <strrev>:
    5ab4:	dc 01       	movw	r26, r24
    5ab6:	fc 01       	movw	r30, r24
    5ab8:	67 2f       	mov	r22, r23
    5aba:	71 91       	ld	r23, Z+
    5abc:	77 23       	and	r23, r23
    5abe:	e1 f7       	brne	.-8      	; 0x5ab8 <strrev+0x4>
    5ac0:	32 97       	sbiw	r30, 0x02	; 2
    5ac2:	04 c0       	rjmp	.+8      	; 0x5acc <strrev+0x18>
    5ac4:	7c 91       	ld	r23, X
    5ac6:	6d 93       	st	X+, r22
    5ac8:	70 83       	st	Z, r23
    5aca:	62 91       	ld	r22, -Z
    5acc:	ae 17       	cp	r26, r30
    5ace:	bf 07       	cpc	r27, r31
    5ad0:	c8 f3       	brcs	.-14     	; 0x5ac4 <strrev+0x10>
    5ad2:	08 95       	ret

00005ad4 <__divmodsi4>:
    5ad4:	05 2e       	mov	r0, r21
    5ad6:	97 fb       	bst	r25, 7
    5ad8:	16 f4       	brtc	.+4      	; 0x5ade <__divmodsi4+0xa>
    5ada:	00 94       	com	r0
    5adc:	0f d0       	rcall	.+30     	; 0x5afc <__negsi2>
    5ade:	57 fd       	sbrc	r21, 7
    5ae0:	05 d0       	rcall	.+10     	; 0x5aec <__divmodsi4_neg2>
    5ae2:	24 d0       	rcall	.+72     	; 0x5b2c <__udivmodsi4>
    5ae4:	07 fc       	sbrc	r0, 7
    5ae6:	02 d0       	rcall	.+4      	; 0x5aec <__divmodsi4_neg2>
    5ae8:	46 f4       	brtc	.+16     	; 0x5afa <__divmodsi4_exit>
    5aea:	08 c0       	rjmp	.+16     	; 0x5afc <__negsi2>

00005aec <__divmodsi4_neg2>:
    5aec:	50 95       	com	r21
    5aee:	40 95       	com	r20
    5af0:	30 95       	com	r19
    5af2:	21 95       	neg	r18
    5af4:	3f 4f       	sbci	r19, 0xFF	; 255
    5af6:	4f 4f       	sbci	r20, 0xFF	; 255
    5af8:	5f 4f       	sbci	r21, 0xFF	; 255

00005afa <__divmodsi4_exit>:
    5afa:	08 95       	ret

00005afc <__negsi2>:
    5afc:	90 95       	com	r25
    5afe:	80 95       	com	r24
    5b00:	70 95       	com	r23
    5b02:	61 95       	neg	r22
    5b04:	7f 4f       	sbci	r23, 0xFF	; 255
    5b06:	8f 4f       	sbci	r24, 0xFF	; 255
    5b08:	9f 4f       	sbci	r25, 0xFF	; 255
    5b0a:	08 95       	ret

00005b0c <__muluhisi3>:
    5b0c:	4b dd       	rcall	.-1386   	; 0x55a4 <__umulhisi3>
    5b0e:	a5 9f       	mul	r26, r21
    5b10:	90 0d       	add	r25, r0
    5b12:	b4 9f       	mul	r27, r20
    5b14:	90 0d       	add	r25, r0
    5b16:	a4 9f       	mul	r26, r20
    5b18:	80 0d       	add	r24, r0
    5b1a:	91 1d       	adc	r25, r1
    5b1c:	11 24       	eor	r1, r1
    5b1e:	08 95       	ret

00005b20 <__mulshisi3>:
    5b20:	b7 ff       	sbrs	r27, 7
    5b22:	f4 cf       	rjmp	.-24     	; 0x5b0c <__muluhisi3>

00005b24 <__mulohisi3>:
    5b24:	f3 df       	rcall	.-26     	; 0x5b0c <__muluhisi3>
    5b26:	82 1b       	sub	r24, r18
    5b28:	93 0b       	sbc	r25, r19
    5b2a:	08 95       	ret

00005b2c <__udivmodsi4>:
    5b2c:	a1 e2       	ldi	r26, 0x21	; 33
    5b2e:	1a 2e       	mov	r1, r26
    5b30:	aa 1b       	sub	r26, r26
    5b32:	bb 1b       	sub	r27, r27
    5b34:	fd 01       	movw	r30, r26
    5b36:	0d c0       	rjmp	.+26     	; 0x5b52 <__udivmodsi4_ep>

00005b38 <__udivmodsi4_loop>:
    5b38:	aa 1f       	adc	r26, r26
    5b3a:	bb 1f       	adc	r27, r27
    5b3c:	ee 1f       	adc	r30, r30
    5b3e:	ff 1f       	adc	r31, r31
    5b40:	a2 17       	cp	r26, r18
    5b42:	b3 07       	cpc	r27, r19
    5b44:	e4 07       	cpc	r30, r20
    5b46:	f5 07       	cpc	r31, r21
    5b48:	20 f0       	brcs	.+8      	; 0x5b52 <__udivmodsi4_ep>
    5b4a:	a2 1b       	sub	r26, r18
    5b4c:	b3 0b       	sbc	r27, r19
    5b4e:	e4 0b       	sbc	r30, r20
    5b50:	f5 0b       	sbc	r31, r21

00005b52 <__udivmodsi4_ep>:
    5b52:	66 1f       	adc	r22, r22
    5b54:	77 1f       	adc	r23, r23
    5b56:	88 1f       	adc	r24, r24
    5b58:	99 1f       	adc	r25, r25
    5b5a:	1a 94       	dec	r1
    5b5c:	69 f7       	brne	.-38     	; 0x5b38 <__udivmodsi4_loop>
    5b5e:	60 95       	com	r22
    5b60:	70 95       	com	r23
    5b62:	80 95       	com	r24
    5b64:	90 95       	com	r25
    5b66:	9b 01       	movw	r18, r22
    5b68:	ac 01       	movw	r20, r24
    5b6a:	bd 01       	movw	r22, r26
    5b6c:	cf 01       	movw	r24, r30
    5b6e:	08 95       	ret

00005b70 <_exit>:
    5b70:	f8 94       	cli

00005b72 <__stop_program>:
    5b72:	ff cf       	rjmp	.-2      	; 0x5b72 <__stop_program>
